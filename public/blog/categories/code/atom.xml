<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2014-04-03T20:52:27-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Link to Broccoli Assets on a Webpage]]></title>
    <link href="http://jaketrent.com/post/link-broccoli-assets-on-webpage/"/>
    <updated>2014-03-18T08:06:00-06:00</updated>
    <id>http://jaketrent.com/post/link-broccoli-assets-on-webpage</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/joliss/broccoli">Broccoli.js</a> is good at <a href="http://www.solitr.com/blog/2014/02/broccoli-first-release/">building assets</a>.  But now that they're built, how does one use them on a webpage?</p>

<p><img src="http://i.imgur.com/oYpiHcU.jpg" alt="Broccoli" /></p>

<!--more-->


<h2>Broccoli Serve</h2>

<p>Broccoli has a great feature of having assets cached at every step in a list of transforms.  This makes it quite fast.  It can selectively reprocess only the subset of assets that have changed, and it can selectively transform only what's required.</p>

<p>Broccoli provides a command, <code>serve</code> that watches for changes to the trees specified in your <code>Brocfile.js</code> and spits them out to its temporary directory.  From there, it sets up a small webserver to serve the built assets to anyone who wants them.  The intent is that you can use this server in local dev on your sites.</p>

<p>Open your project and run:</p>

<p><code>
$ broccoli serve
Serving on http://localhost:4200
</code></p>

<p>And you'll get a local server defaulting on port 4200.</p>

<h2>Webpage Reference</h2>

<p>Now that you have this server for local assets, you need to reference it from your webpage.  Just as when you get to production, you'll want to reference a deployed asset on a CDN, locally broccoli can serve as your asset host.</p>

<p>You can accomplish this in any number of ways.  Essentially, you need two things:</p>

<h3>1. Environment Detection</h3>

<p>If you're in development, you'll want to use <code>http://localhost:4200</code> for asset host, otherwise you'll want to use something like <code>http://mycdn.com</code>.</p>

<p>Assuming less of your other infrastructure, we'll make Broccoli accomplish this (but you could do this easily with <code>NODE_ENV</code> or something similar).  Broccoli internally uses <code>BROCCOLI_ENV</code> to switch functionality.  To detect this value easily, you can install <a href="https://github.com/joliss/broccoli-env">the plugin</a>:</p>

<p><code>
npm install broccoli-env --save-dev
</code></p>

<p>Then you'll be able to use it in your <code>Brocfile.js</code> to switch on important things:</p>

<p><code>javascript
var env = require('broccoli-env').getEnv()
if (env === 'development') // do stuff
</code></p>

<p>Currently, the plugin only supports <code>development</code> and <code>production</code> values.</p>

<h3>2. View Compilation</h3>

<p>If you have a server-side component in your project that serves UI, you likely have this built in already with the likes of <code>erb</code>, <code>jade</code>, <code>swig</code>, or something else.  If you don't, again you can defer to Broccoli.  It's good at building assets after all.</p>

<p>As an example, there is a plugin for compiling <code>jade</code> templates, <a href="https://github.com/sindresorhus/broccoli-jade">broccoli-jade</a>.  First, install:</p>

<p><code>
npm install broccoli-jade --save-dev
</code></p>

<p>Then create a view to meet your needs.  Perhaps in part, that might look like:</p>

<p>```jade
doctype html
html
  head</p>

<pre><code>script(src="#{assetsHost}/main.js", type="text/javascript")
/ ...
</code></pre>

<p>```</p>

<p>Here, <code>assetsHost</code> is a variable that will be replaced at compile time with the appropriate asset host value.</p>

<p>Finally, in your <code>Brocfile.js</code> you can tie it all together with something like:</p>

<p>```javascript
var env = require('broccoli-env').getEnv()
var jade = require('broccoli-jade')
var tree = broccoli.makeTree('my/views/path')
tree =  jade(tree, {
  data: {</p>

<pre><code>assetsHost: env === 'development' ? 'http://localhost:4200' : 'http://mycdn.com'
</code></pre>

<p>  }
})
return tree
```</p>

<p>Now when the <code>jade</code> template is compiled, it will have as local data the value of <code>assetHost</code> according to the env set by <code>BROCCOLI_ENV</code>.</p>

<p>And since Broccoli is handling the building of your view, you can even use Broccoli to serve it.  If it's called <code>index.jade</code> and ends up at the root directory after building with Broccoli, you could serve your whole site at <code>http://localhost:4200</code>.</p>

<p>And just like that, you can dev locally referencing the assets that Broccoli is building for you.  Does it work for you?  Is the picture clear?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Convert App From EmberFire to Fireplace]]></title>
    <link href="http://jaketrent.com/post/convert-app-from-emberfire-to-fireplace/"/>
    <updated>2014-03-17T16:17:00-06:00</updated>
    <id>http://jaketrent.com/post/convert-app-from-emberfire-to-fireplace</id>
    <content type="html"><![CDATA[<p>There are a few changes required to convert your Ember app from using EmberFire to Fireplace.  Here are a few that I found to be required.  There are probably more.</p>

<p><img src="http://i.imgur.com/1Jg69Pf.jpg" alt="Firebase" /></p>

<!--more-->


<h2>Your Options</h2>

<p><a href="https://github.com/firebase/emberFire">EmberFire</a> and <a href="https://github.com/rlivsey/fireplace">Fireplace</a> both provide an API for you to integrate your Ember app with a <a href="https://www.firebase.com/">Firebase</a> backend.  You don't need either library; they provide a more high-level API and help handle some of the nitty gritties of making Ember data-binding work with your socket traffic.  You can just use the <a href="https://www.firebase.com/docs/javascript/firebase/index.html">Firebase JavaScript API</a>.</p>

<p>I was using EmberFire with ember-data first.  It worked pretty well.  I ran into a few hiccups where it seemed like model relationships weren't working quite right in a couple places, but I worked around it for my simple app.  Fireplace was recommended to me as a good option instead of EmberFire.  From those that know more about this than I do, Fireplace was described as "the thing that ember-data should have been," and way more capable than EmberFire.  As far as I can tell, they look very similar.  But, if you should want to switch, here are the basic changes:</p>

<h2>Changes Required</h2>

<h3>Set the Store</h3>

<p>Instead of setting up an adapter for Firebase to work with Ember data, you want to define a store on your app.  That might look like this:</p>

<p><code>coffeescript
App.Store = FP.Store.extend
  firebaseRoot: 'https://myfirebase.firebaseio.com'
</code></p>

<p>Note that the store is of type <code>FP.Store</code> instead of <code>DS.Store</code>.</p>

<h3>Remove ember-data</h3>

<p>Now that you have another store set, you want to make sure you remove ember-data so it doesn't try to interact with it.  If you forget, you will get an error at runtime:</p>

<p><code>
Uncaught Error: Assertion Failed: The initializer 'store' has already been registered
</code></p>

<h3>Add ember-inflector</h3>

<p>Ember-data comes bundled with ember-inflector.  But, now that ember-data is gone, we need to fetch this library separately.  This is the library responsible for inferring types in your models based on property names.  To get it, you'll need the <a href="https://github.com/stefanpenner/ember-inflector">ember-inflector source</a>.  You'll notice that there isn't a nice package built for you.  Instead, you'll have to build it with Ruby tools.</p>

<p>To make your own version from source, follow these steps:</p>

<p><code>
git clone git@github.com:stefanpenner/ember-inflector.git
rake bundle
rake dist
cp dist/modules/ember-inflector.js your_project_dir
</code></p>

<p>For convenience, at the risk of being out-dated, I've uploaded the version that I built as of 17 Mar 2014 to a <a href="https://gist.github.com/jaketrent/9621891">gist of ember-inflector at 32e30eb</a>.`</p>

<h3>Change Model Definitions</h3>

<p>Your models will need to change, but not by much.  <code>DS.Model</code> becomes <code>FP.Model</code>.  <code>DS.attr</code> becomes <code>FP.attr</code>.  The changes are pretty much one-to-one in requiring just a namespace change.</p>

<h3>Optionally Change Finds</h3>

<p>Where you use ember-data's <code>model.find</code> function, you may want to change to use Fireplace's <code>model.fetch</code>.  <code>fetch</code>, in this case will return a promise where <code>find</code> does not.</p>

<h3>Change Deletes</h3>

<p>Beyond the above, only API that broke for me was ember-data's <code>model.destroyRecord</code>.  It seems on that this is the different, because <code>save</code> and <code>createRecord</code> remain the same.  But, for the delete, the API becomes simply <code>model.delete</code>.</p>

<h3>Other Changes</h3>

<p>The app I converted was quite simple, so I'm thinking that there will be other changes required.  What have you run into?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Detecting Window Closing in Ember]]></title>
    <link href="http://jaketrent.com/post/ember-window-beforeunload/"/>
    <updated>2014-03-17T08:04:00-06:00</updated>
    <id>http://jaketrent.com/post/ember-window-beforeunload</id>
    <content type="html"><![CDATA[<p>In a long-running app such as you might build in Ember, it can be useful to detect when the window is closing.  This is easily detected with JavaScript, and there are easy places to put the code in your Ember app.</p>

<p><img src="http://i.imgur.com/85v8PQP.png" alt="Ember beforeunload" /></p>

<!--more-->


<h2>beforeunload</h2>

<p>The <code>window</code> event that you want to listen for is <code>beforeunload</code>.  You might bind to the event like so:</p>

<p><code>coffeescript
$(window).bind 'beforeunload', -&gt;
  'Are you sure you want to close this window?'
</code></p>

<p>Return a string from the function.  This string will be displayed in a browser-native confirm-style dialogue.</p>

<h2>beforeunload in Ember</h2>

<p>Now, if your app is controlled by Ember, you're likely going to want it to handle bindings such as this from within Ember.  There are several places you might want to put this code.  Your decision will depend on the needs of your app.  You can put it in a route or controller.  The scope of that route or controller should match the scope for which you want the <code>beforeunload</code> event to be caught.  In other words, if you want <code>beforeunload</code> to be caught for the entire app, put the listener in <code>ApplicationRoute</code> (or <code>ApplicationController</code>).  Or if you wanted a more limited scope, put the listener in a more specific route.</p>

<p>For instance, if you wanted to save a blog post when the user closes a tab, you might implement something like this:</p>

<p>```coffeescript
App.BlogEditController = Ember.ObjectController.extend
  saveBeforeClose: (-></p>

<pre><code>$(window).bind 'beforeunload', =&gt;
  @get('model').save()
  'Are you sure you want to leave unsaved work?'
</code></pre>

<p>  ).on 'init'
```</p>

<h2>In Practice</h2>

<p>In practice, the UX for this kind of feature can be tricky.  If someone closes a tab, odds are they meant to and don't want to be bothered with a confirm dialogue asking them to reiterate their decision.  On the other hand, maybe the didn't realize the implications of closing out the app, such as in the case of unsaved work, and they become very grateful for the reminder to stay and save something.</p>

<p>In the case of the last example, it would be cool if we could detect the window closing, save the work automatically, and let the user close the tab as they indicated without interruption.  For asynchronous actions such as network requests, this is problematic.  The request will not finish before the browser has trashed the whole window.  In cases such as this, you will need to synchronize your requests to block before finishing execution of the <code>beforeunload</code> event callback.</p>

<p>So, does this work for you?  How might you make it better?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Express Validator]]></title>
    <link href="http://jaketrent.com/post/testing-express-validator/"/>
    <updated>2014-03-10T07:37:00-06:00</updated>
    <id>http://jaketrent.com/post/testing-express-validator</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/ctavan/express-validator">Express-validator</a> is a <a href="http://expressjs.com/api.html#middleware">middleware for Express</a> on Node.js that can help you validate user input.  It's a lovely library.  Here's a pattern for testing code that uses it.</p>

<p><img src="http://i.imgur.com/ZfK9bv4.png" alt="express-validator" /></p>

<!--more-->


<h2>Install</h2>

<p>To get <code>express-validator</code> in your project, install with npm:</p>

<p><code>bash
npm install express-validator --save
</code></p>

<h2>Plug in the Middleware</h2>

<p>To use the middleware in your code, crack open the part of your app that sets up Express middlewares, and add in a reference to this lil beaut:</p>

<p>```coffeescript
expressValidator = require 'express-validator'</p>

<h1>...</h1>

<p>app.use express.json()
app.use expressValidator()
```</p>

<p>Note that you should insert the new <code>express-validator</code> middleware directly after the <code>json</code> middleware.  Also note that the <code>json</code> middleware, used in conjunction with <code>urlencoded</code> now <a href="http://andrewkelley.me/post/do-not-use-bodyparser-with-express-js.html">replace <code>bodyParser</code></a> to avoid deprecation warnings on startup.</p>

<h2>Validate Something</h2>

<p>Let's say you're writing a validator for new posts to a blog.  That code might look like this.</p>

<p>```coffeescript blog-new-validator.coffee
module.exports = (req) -></p>

<p>  req.checkBody('title', 'Title is required').notEmpty()
  req.checkBody('body', 'Body is required').notEmpty()</p>

<p>  !req.validationErrors() or req.validationErrors().length is 0
```</p>

<p>It checks to see if there is a title and a body given.  If there is not, the validator will return false, and there will be a validation errors array on the <code>req</code> object.  There are many <a href="https://github.com/chriso/validator.js">other assertions (provided internally by validator.js)</a> besides <code>notEmpty</code> that you can use.</p>

<h2>Validating the Validator</h2>

<p>First, setup a test helper that stubs the request, <code>req</code>, for validation:</p>

<p>```coffeescript req.coffee
expressValidator = require('express-validator')()</p>

<p>exports.stubForValidation = (done) ->
  req =</p>

<pre><code>query: {}
body: {}
params: {}
param: (name) -&gt;
  @params[name]
</code></pre>

<p>  expressValidator req, {}, -></p>

<pre><code>done(req)
</code></pre>

<p>```</p>

<p>There's nothing too incredibly special here.  It's just abstracted out of your test into a reusable helper.  The <code>req</code> object has empty objects to slap fixture data onto in your tests.  It includes a stubbed <code>param</code> function that can return params by name.  Finally, the <code>express-validator</code> middleware is called with the stubbed <code>req</code> object.</p>

<p>Now, in your test, you can simply:</p>

<ol>
<li>Stub the request before each test</li>
<li>Setup your fixture data to make the test pass (or not)</li>
<li>Assert validation errors' existence and messages</li>
</ol>


<p>```coffeescript blog-new-validator.spec.coffee
stubReq = require('req').stubForValidation
validateNew = require 'blog-new-validator'</p>

<p>describe 'blog-new-validator', -></p>

<p>  req = null</p>

<p>  beforeEach (done) -></p>

<pre><code>stubReq (r) -&gt;
  req = r
  done()
</code></pre>

<p>  it 'is invalid without title', -></p>

<pre><code>validateNew(req).should.be.false
req.validationErrors(true).title.msg.should.eql 'Title is required'
</code></pre>

<p>  it 'is invalid without body', -></p>

<pre><code>validateNew(req).should.be.false
req.validationErrors(true).body.msg.should.eql 'Body is required'
</code></pre>

<p>  it 'is valid with title and body', -></p>

<pre><code>req.body.title = 'New Blog Title'
req.body.body = 'The body of the blog.'
validateNew(req).should.be.true
</code></pre>

<p>```</p>

<p>What do you think?  Is there an easier way?  A way to get better assertions?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Permit Array in Rails Strong Parameters]]></title>
    <link href="http://jaketrent.com/post/permit-array-rails-strong-parameters/"/>
    <updated>2014-01-22T11:19:00-07:00</updated>
    <id>http://jaketrent.com/post/permit-array-rails-strong-parameters</id>
    <content type="html"><![CDATA[<p>Rails 4 introduced the pattern of strong parameters at the controller layer.  As a best practice, you will explicitly list the parameters that an endpoint should accept in payloads.  Arrays are specified just slightly different.</p>

<p><img src="http://i.imgur.com/XOUecnw.jpg" alt="Rails" /></p>

<!--more-->


<h2>Strong Parameters</h2>

<p>You don't want those blackhats to update any field they want on your poor models.  Raise the shields -- strong parameters!  In ye olden days, <code>attr_accessible</code> could add some protection to your models.  Since Rails 4, it has been best practice to move this responsibility to the controller.  At that layer, you can make adjustments and allowances on a per-endpoint basis (eg, admin functionality has more power over a particular model than the layman user).</p>

<p>So, create a private function in your controller where you can filter your params for your model.  It might look like:</p>

<p>```ruby
private</p>

<p>def luchador_params
  params.require(:luchador).permit(:favorite_move, :weight)
end
```</p>

<p>You have two main methods to use:</p>

<ul>
<li><code>require</code> - ensures that the parameter is present (as in this root <code>luchador</code> key)</li>
<li><code>permit</code> - whitelist filters the parameters to the set specified</li>
</ul>


<h2>Arrays in <code>permit</code></h2>

<p>The most standard use case for <code>permit</code> is to pass it a collection of :symbols.  These keys must represent scalar values (string, number, that sort) only.  But what about arrays?  They're represented differently by an empty array:</p>

<p><code>ruby
params.require(:luchador).permit(:favorite_move, :weight, wins: [])
</code></p>

<p>But wait -- one more problem, and I don't like the answer here.  My client might send back a <code>nil</code> instead of an array (ie, when the luchador has no <code>wins</code>).  If this happens, cue ugly error:</p>

<p><code>text
Unpermitted parameter: wins
</code></p>

<p>To fix, default to empty array:</p>

<p><code>ruby
params[:luchador][:wins] ||= []
params.require(:luchador).permit(:favorite_move, :weight, wins: [])
</code></p>

<p>What have you done that looks better?  Please! :)</p>
]]></content>
  </entry>
  
</feed>
