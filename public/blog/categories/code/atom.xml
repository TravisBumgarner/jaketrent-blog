<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2014-06-30T17:27:56-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Set State in Callbacks in React]]></title>
    <link href="http://jaketrent.com/post/set-state-in-callbacks-in-react/"/>
    <updated>2014-06-23T08:30:00-06:00</updated>
    <id>http://jaketrent.com/post/set-state-in-callbacks-in-react</id>
    <content type="html"><![CDATA[<p>In React, you can setup components that fetch their own data and set their own state with that data.  Because of the async nature of data fetching, you’ll have to make sure to keep things cleaned up to avoid the error of trying to set state in an unmounted component.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="React" /></p>

<!--more-->


<h2>React Components setState</h2>

<p>If a React component fetches its own data, it will usually do so in the <code>componentDidMount</code> method.  In the data request callback, it will set its own state via the <code>this.setState</code> method.  (<code>this.state</code> should be treated as immutable.)  State should only be set on mounted components, or those components that are inserted into the dom.</p>

<p>If you attempt to set state on an unmounted component, you'll get an error that looks like this:</p>

<p><code>
Uncaught Error: Invariant Violation: replaceState(...): Can only update a mounted or mounting component.
</code></p>

<p>Others have reported this variation:</p>

<p><code>
Invariant Violation: replaceState(...): Cannot update while unmounting component. This usually means you called setState() on an unmounted component.
</code></p>

<p>Both indicate that you're setting state on a component that is not mounted.  How should one avoid this?  In my case, <code>setState</code> was being called in a callback that was firing after the component that initially started the request had already been unmounted from the dom.  Here are the two ways I addressed the problem...</p>

<h2>Assure Component isMounted</h2>

<p>If the component is mounted, <code>setState</code> is a safe bet.  If it's not mounted, never do it.  If it's not mounted, you probably don't about the state at that point either.  So wrap your state setting in <code>this.isMounted()</code>:</p>

<p>```js
React.createClass({
  componentDidMount: function () {</p>

<pre><code>MyModel.find(function (err, data) {
  if (this.isMounted()) {
    this.setState({ 
      goodiesFrom: data 
    })
  }
}).bind(this)
</code></pre>

<p>  }
  // ...
})
```</p>

<p>It feels a bit like a hack, but it makes the code safe.  Another option...</p>

<h2>Abort the Request</h2>

<p>My asynchronous action is a network request that, when finished, will call the callback function.  When the component unmounts, I can just throw away the request so the callback is never invoked.  To do this, we'll take advantage of another React lifecycle hook, <code>componentWillUnmount</code>:</p>

<p>```js my-component.js
React.createClass({
  componentDidMount: function () {</p>

<pre><code>this.req = MyModel.find(function (err, data) {
  this.setState({})
})
</code></pre>

<p>  },
  componentWillUnmount: function () {</p>

<pre><code>this.req.abort()
</code></pre>

<p>  }
  // ...
})
```</p>

<p>In my model, I'm using the <a href="https://github.com/visionmedia/superagent">superagent</a> library for network requests which provides an <a href="http://visionmedia.github.io/superagent/#aborting-requests">abort</a> method.</p>

<p>```js my-model.js
var request = require(‘superagent')
MyModel.prototype.find = function (done) {
  return request(‘modelUrl’)</p>

<pre><code>.end(function (err, data) {
  if (data) {
    done(err, data.body)
  }
})
</code></pre>

<p>}
```</p>

<p>Also note that in my <code>end</code> function callback, I'm checking for the existence of data.  This is because when a request is aborted, data will come back as undefined.</p>

<p>My favored method for solving the problem is the latter request abort method.  It feels cleaner that we're relying on the lifecycle functions of the component to deal with cleanup, much like we would for <a href="http://facebook.github.io/react/tips/dom-event-listeners.html">events</a>.  How have you dealt with this problem?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Broccoli Ember Emblem]]></title>
    <link href="http://jaketrent.com/post/broccoli-ember-emblem/"/>
    <updated>2014-05-30T07:18:00-06:00</updated>
    <id>http://jaketrent.com/post/broccoli-ember-emblem</id>
    <content type="html"><![CDATA[<p>Make broccoli compile your emblem templates so they're ready for your ember app.</p>

<p><img src="http://i.imgur.com/85v8PQP.png" alt="Broccoli Ember Emblem" /></p>

<!--more-->


<h2>The Libraries</h2>

<p><a href="https://www.npmjs.org/package/broccoli">Broccoli</a> builds your assets quickly.  It makes heavy use of caching so it only has to rebuild affected subtrees when files change.  <a href="http://emblemjs.com/">Emblem</a> is a significant whitespace version of <a href="http://handlebarsjs.com/">Handlebars</a> templates, similar in style to <a href="http://slim-lang.com/">Slim</a> or <a href="http://jade-lang.com/">Jade</a>.  <a href="http://emberjs.com/">Ember</a> is a MVC framework for building browser apps.</p>

<p>Put them all together, and you have something that will help you compile your templates quickly for your browser app.  The <a href="https://github.com/jaketrent/broccoli-ember-emblem">broccoli-ember-emblem</a> plugin for Broccoli will do just that.</p>

<h2>Install</h2>

<p>To use the library, you'll need broccoli installed first.  Then, you'll install the plugin via npm:</p>

<p><code>
npm install --save-dev broccoli-ember-emblem
</code></p>

<h2>Usage</h2>

<p>You'll setup the plugin in your app's <code>Brocfile.js</code>.  That setup might look something like this:</p>

<p>```js
var emblem = require('broccoli-ember-emblem')
var mergeTrees = require('broccoli-merge-trees')
var pickFiles = require('broccoli-static-compiler')</p>

<p>function preprocess (tree) {
  tree = emblem(tree, {</p>

<pre><code>stripPathFromName: 'tmpl/'
</code></pre>

<p>  })
  return tree
}</p>

<p>var tmplTree = 'client/tmpl'
tmplTree = pickFiles(tmplTree, {
  srcDir: '/',
  destDir: '/tmpl'
})
tmplTree = preprocess(tmplTree)</p>

<p>module.exports = mergeTrees([ /<em> other trees, </em>/ tmplTree ])
```</p>

<p>Note a few things:</p>

<ul>
<li>I'm using another plugin, <code>broccoli-static-compiler</code> to move files around in the broccoli build directories.  This is to be able to identify separate trees that both use similar file filters (eg, *.js for both src scripts and templates).</li>
<li>I'm using the one option for the <code>broccoli-ember-emblem</code> plugin, <code>stripPathFromName</code>, which allows me to remove the path name from the template name in output.  For example, if I have a file at <code>tmpl/application.emblem</code>, I want the template name in ember to be <code>application</code>, not <code>tmpl/application</code>.</li>
<li>Final output is merged into a single tree via another plugin, <code>broccoli-merge-trees</code>.</li>
</ul>


<h2>Output</h2>

<p>Broccoli will take care of finding all of your template files.  It will use directories and filenames as the input for template names.  As a few examples, here is input and output as it might happen in the above configuration:</p>

<ul>
<li>File: <code>client/tmpl/application.emblem</code> becomes: <code>Ember.TEMPLATES['application']</code></li>
<li>File: <code>client/tmpl/components/song.emblem</code> becomes: <code>Ember.TEMPLATES['components/song']</code></li>
</ul>


<p>Notice that Ember requires all templates to be registered on the <code>Ember.TEMPLATES</code> object.  Later, at app runtime, they are looked up on that object by name.</p>

<p>So, use the plugin and win.  How does your template compilation for Ember/Emblem differ?  What other features do you wish were supported here?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bower Resolutions]]></title>
    <link href="http://jaketrent.com/post/bower-resolutions/"/>
    <updated>2014-05-29T07:18:00-06:00</updated>
    <id>http://jaketrent.com/post/bower-resolutions</id>
    <content type="html"><![CDATA[<p>When you specify dependencies for you app via Bower, some of the packages might rely on different versions of the same library.  You will have to resolve what version of libraries your app actually wants.  In other words, you break the tie.  But you don't want to break it every time, so save your choice.</p>

<p><img src="http://i.imgur.com/t4XxrHn.jpg" alt="Bower" /></p>

<!--more-->


<h2>bower.json Resolutions</h2>

<p>When you run <code>bower install</code>, the resolution process is interactive.  When bower recognizes that there are two packages that depend on a package at different versions, it'll list all those versions and ask:</p>

<p>```
Unable to find a suitable version for ember, please choose one:</p>

<pre><code>1) ember#~1.0.0 which resolved to 1.0.1 and is required by ember-data#0.0.14
2) ember#1.5.1 which resolved to 1.5.1 and is required by melodrama
</code></pre>

<p>```</p>

<p>In this case, the library in question is ember.  I can press the number <code>2</code> and bower will install the 2nd option, <code>ember#1.5.1</code>.</p>

<p>The next line in the prompt is very handy.  It reads:</p>

<p><code>
Prefix the choice with ! to persist it to bower.json
</code></p>

<p>Awesome! So, if I type <code>!2</code> instead, my choice is saved in <code>bower.json</code>.  Specifically, it'll add a <code>resolutions</code> entry:</p>

<p><code>js
"resolutions": {
  "ember": "1.5.1"
}
</code></p>

<p>Now, the next time you run <code>bower install</code>, there is no interactive question of what version I want because I've already resolved that <code>ember</code> for my app should be version <code>1.5.1</code>.</p>

<h2>Bonus: Heroku install</h2>

<p>Not only do you save your brain from having to remember what version you want in your app, you save your fingers the added stress of typing numbers.  And as a bonus, you also make <code>bower install</code> possible for automated processes.  For instance, if you want to run <code>bower install</code> in a Heroku deploy of a Node app, you can add a postinstall script for npm in your <code>package.json</code>:</p>

<p>```js
{
  "scripts": {</p>

<pre><code>"postinstall": "./node_modules/bower/bin/bower install"
</code></pre>

<p>  },
  "dependencies": {</p>

<pre><code>"bower": "~1.3.3"
</code></pre>

<p>  }
}
```</p>

<p>Now you should be able to push to heroku, have npm install, then have bower install.  Because you've recorded your resolutions choices, the process can work automatically on heroku without prompts.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Link to Broccoli Assets on a Webpage]]></title>
    <link href="http://jaketrent.com/post/link-broccoli-assets-on-webpage/"/>
    <updated>2014-03-18T08:06:00-06:00</updated>
    <id>http://jaketrent.com/post/link-broccoli-assets-on-webpage</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/joliss/broccoli">Broccoli.js</a> is good at <a href="http://www.solitr.com/blog/2014/02/broccoli-first-release/">building assets</a>.  But now that they're built, how does one use them on a webpage?</p>

<p><img src="http://i.imgur.com/oYpiHcU.jpg" alt="Broccoli" /></p>

<!--more-->


<h2>Broccoli Serve</h2>

<p>Broccoli has a great feature of having assets cached at every step in a list of transforms.  This makes it quite fast.  It can selectively reprocess only the subset of assets that have changed, and it can selectively transform only what's required.</p>

<p>Broccoli provides a command, <code>serve</code> that watches for changes to the trees specified in your <code>Brocfile.js</code> and spits them out to its temporary directory.  From there, it sets up a small webserver to serve the built assets to anyone who wants them.  The intent is that you can use this server in local dev on your sites.</p>

<p>Open your project and run:</p>

<p><code>
$ broccoli serve
Serving on http://localhost:4200
</code></p>

<p>And you'll get a local server defaulting on port 4200.</p>

<h2>Webpage Reference</h2>

<p>Now that you have this server for local assets, you need to reference it from your webpage.  Just as when you get to production, you'll want to reference a deployed asset on a CDN, locally broccoli can serve as your asset host.</p>

<p>You can accomplish this in any number of ways.  Essentially, you need two things:</p>

<h3>1. Environment Detection</h3>

<p>If you're in development, you'll want to use <code>http://localhost:4200</code> for asset host, otherwise you'll want to use something like <code>http://mycdn.com</code>.</p>

<p>Assuming less of your other infrastructure, we'll make Broccoli accomplish this (but you could do this easily with <code>NODE_ENV</code> or something similar).  Broccoli internally uses <code>BROCCOLI_ENV</code> to switch functionality.  To detect this value easily, you can install <a href="https://github.com/joliss/broccoli-env">the plugin</a>:</p>

<p><code>
npm install broccoli-env --save-dev
</code></p>

<p>Then you'll be able to use it in your <code>Brocfile.js</code> to switch on important things:</p>

<p><code>javascript
var env = require('broccoli-env').getEnv()
if (env === 'development') // do stuff
</code></p>

<p>Currently, the plugin only supports <code>development</code> and <code>production</code> values.</p>

<h3>2. View Compilation</h3>

<p>If you have a server-side component in your project that serves UI, you likely have this built in already with the likes of <code>erb</code>, <code>jade</code>, <code>swig</code>, or something else.  If you don't, again you can defer to Broccoli.  It's good at building assets after all.</p>

<p>As an example, there is a plugin for compiling <code>jade</code> templates, <a href="https://github.com/sindresorhus/broccoli-jade">broccoli-jade</a>.  First, install:</p>

<p><code>
npm install broccoli-jade --save-dev
</code></p>

<p>Then create a view to meet your needs.  Perhaps in part, that might look like:</p>

<p>```jade
doctype html
html
  head</p>

<pre><code>script(src="#{assetsHost}/main.js", type="text/javascript")
/ ...
</code></pre>

<p>```</p>

<p>Here, <code>assetsHost</code> is a variable that will be replaced at compile time with the appropriate asset host value.</p>

<p>Finally, in your <code>Brocfile.js</code> you can tie it all together with something like:</p>

<p>```javascript
var env = require('broccoli-env').getEnv()
var jade = require('broccoli-jade')
var tree = broccoli.makeTree('my/views/path')
tree =  jade(tree, {
  data: {</p>

<pre><code>assetsHost: env === 'development' ? 'http://localhost:4200' : 'http://mycdn.com'
</code></pre>

<p>  }
})
return tree
```</p>

<p>Now when the <code>jade</code> template is compiled, it will have as local data the value of <code>assetHost</code> according to the env set by <code>BROCCOLI_ENV</code>.</p>

<p>And since Broccoli is handling the building of your view, you can even use Broccoli to serve it.  If it's called <code>index.jade</code> and ends up at the root directory after building with Broccoli, you could serve your whole site at <code>http://localhost:4200</code>.</p>

<p>And just like that, you can dev locally referencing the assets that Broccoli is building for you.  Does it work for you?  Is the picture clear?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Convert App From EmberFire to Fireplace]]></title>
    <link href="http://jaketrent.com/post/convert-app-from-emberfire-to-fireplace/"/>
    <updated>2014-03-17T16:17:00-06:00</updated>
    <id>http://jaketrent.com/post/convert-app-from-emberfire-to-fireplace</id>
    <content type="html"><![CDATA[<p>There are a few changes required to convert your Ember app from using EmberFire to Fireplace.  Here are a few that I found to be required.  There are probably more.</p>

<p><img src="http://i.imgur.com/1Jg69Pf.jpg" alt="Firebase" /></p>

<!--more-->


<h2>Your Options</h2>

<p><a href="https://github.com/firebase/emberFire">EmberFire</a> and <a href="https://github.com/rlivsey/fireplace">Fireplace</a> both provide an API for you to integrate your Ember app with a <a href="https://www.firebase.com/">Firebase</a> backend.  You don't need either library; they provide a more high-level API and help handle some of the nitty gritties of making Ember data-binding work with your socket traffic.  You can just use the <a href="https://www.firebase.com/docs/javascript/firebase/index.html">Firebase JavaScript API</a>.</p>

<p>I was using EmberFire with ember-data first.  It worked pretty well.  I ran into a few hiccups where it seemed like model relationships weren't working quite right in a couple places, but I worked around it for my simple app.  Fireplace was recommended to me as a good option instead of EmberFire.  From those that know more about this than I do, Fireplace was described as "the thing that ember-data should have been," and way more capable than EmberFire.  As far as I can tell, they look very similar.  But, if you should want to switch, here are the basic changes:</p>

<h2>Changes Required</h2>

<h3>Set the Store</h3>

<p>Instead of setting up an adapter for Firebase to work with Ember data, you want to define a store on your app.  That might look like this:</p>

<p><code>coffeescript
App.Store = FP.Store.extend
  firebaseRoot: 'https://myfirebase.firebaseio.com'
</code></p>

<p>Note that the store is of type <code>FP.Store</code> instead of <code>DS.Store</code>.</p>

<h3>Remove ember-data</h3>

<p>Now that you have another store set, you want to make sure you remove ember-data so it doesn't try to interact with it.  If you forget, you will get an error at runtime:</p>

<p><code>
Uncaught Error: Assertion Failed: The initializer 'store' has already been registered
</code></p>

<h3>Add ember-inflector</h3>

<p>Ember-data comes bundled with ember-inflector.  But, now that ember-data is gone, we need to fetch this library separately.  This is the library responsible for inferring types in your models based on property names.  To get it, you'll need the <a href="https://github.com/stefanpenner/ember-inflector">ember-inflector source</a>.  You'll notice that there isn't a nice package built for you.  Instead, you'll have to build it with Ruby tools.</p>

<p>To make your own version from source, follow these steps:</p>

<p><code>
git clone git@github.com:stefanpenner/ember-inflector.git
rake bundle
rake dist
cp dist/modules/ember-inflector.js your_project_dir
</code></p>

<p>For convenience, at the risk of being out-dated, I've uploaded the version that I built as of 17 Mar 2014 to a <a href="https://gist.github.com/jaketrent/9621891">gist of ember-inflector at 32e30eb</a>.`</p>

<h3>Change Model Definitions</h3>

<p>Your models will need to change, but not by much.  <code>DS.Model</code> becomes <code>FP.Model</code>.  <code>DS.attr</code> becomes <code>FP.attr</code>.  The changes are pretty much one-to-one in requiring just a namespace change.</p>

<h3>Optionally Change Finds</h3>

<p>Where you use ember-data's <code>model.find</code> function, you may want to change to use Fireplace's <code>model.fetch</code>.  <code>fetch</code>, in this case will return a promise where <code>find</code> does not.</p>

<h3>Change Deletes</h3>

<p>Beyond the above, only API that broke for me was ember-data's <code>model.destroyRecord</code>.  It seems on that this is the different, because <code>save</code> and <code>createRecord</code> remain the same.  But, for the delete, the API becomes simply <code>model.delete</code>.</p>

<h3>Other Changes</h3>

<p>The app I converted was quite simple, so I'm thinking that there will be other changes required.  What have you run into?</p>
]]></content>
  </entry>
  
</feed>
