<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2013-08-14T16:18:51-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Disable ngClick]]></title>
    <link href="http://jaketrent.com/post/disable-ng-click/"/>
    <updated>2013-08-14T07:53:00-06:00</updated>
    <id>http://jaketrent.com/post/disable-ng-click</id>
    <content type="html"><![CDATA[<p>Angular's ngClicks can be attached to anything.  This makes it easy to add interactivity to elements on the DOM.  Your program might require that these click callbacks be disabled at certain points, such as during form processing.  ngClick doesn't have a toggle built in.  Let's build one that might help.</p>

<p><img src="http://i.imgur.com/wVBKD.png" alt="Angularjs" /></p>

<!--more-->


<p>In our app we're going to track the state of the UI via various events that get passed in scope.  We slap our directive as an attribute on an element and it will respond by disabling or enabling on certain events.  Here's the directive:</p>

<p>```coffeescript disable-toggle.coffee
angular.module('app.directives').directive 'disableToggle', ->
  restrict: 'A'
  replace: false
  link: (scope, element, attrs) -></p>

<pre><code>defaultDisableEvt = 'click:disable'
defaultEnableEvt = 'click:enable'

disableEvt = attrs.disableEvt || defaultDisableEvt
enableEvt = attrs.enableEvt || defaultEnableEvt

disableEvts = disableEvt.split(/\ *?,\ *?/)
enableEvts = enableEvt.split(/\ *?,\ *?/)

for evt in disableEvts
  scope.$on evt, (evt) -&gt;
    element.attr 'disabled', 'disabled'
    element.addClass 'is-disabled'
    scope.disabledToggled = true

for evt in enableEvts
  scope.$on evt, (evt) -&gt;
    element.removeAttr 'disabled'
    element.removeClass 'is-disabled'
    scope.disabledToggled = false
</code></pre>

<p>```</p>

<p>The directive allows for listening on multiple events.  This is useful if your button should be disabled/enabled via multiple events.  Just separate your event list with commas.  If you don't want to specify any events, the directive uses two default events, 'click:disable' and 'click:enable'.</p>

<p>The directive sets the <code>disabled</code> attribute, commonly used in form fields.  It also sets the <code>is-disabled</code> class so your app can style this state consistently in the UI.</p>

<p>Lastly, the directive also sets a <code>scope.disabledToggled</code> variable on the scope of the element.  This will be useful for elements which are not form elements and which do not prevent clicking just because their <code>disabled</code> attribute is set to <code>disabled</code>.  Instead, we'll use this value to short-circuit the <code>ng-click</code> event itself.</p>

<p>So here it is in action on the template:</p>

<p>```html
  &lt;button ng-click="disabledToggled || doClickyThings()"</p>

<pre><code>      disable-toggle enable-evt="click:enable,photo:clear" disable-evt="photo:add"&gt;Click Me&lt;/button&gt;
</code></pre>

<p>```</p>

<p>Here, we're setting custom events for disabling and enabling the button.  And note the <code>ng-click</code> value.  The <code>doClickyThings()</code> function will not get called if <code>disabledToggled</code> is true.</p>

<p>So, what do you think.  Is there an easier way to get this kind of functionality?  What could we do to make it better?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Preload Route Data in Angular]]></title>
    <link href="http://jaketrent.com/post/preload-route-data-angular/"/>
    <updated>2013-08-13T08:10:00-06:00</updated>
    <id>http://jaketrent.com/post/preload-route-data-angular</id>
    <content type="html"><![CDATA[<p>It's sometimes useful to be able to preload or resolve data previous to an Angular view being displayed.  Such was the case recently for our current user object.  It simplified a lot of things in the app to have the guarantee of a loaded current user previous to displaying pages.  The Angular router has a great mechanism built in to do just this sort of thing, called <code>resolve</code>.</p>

<p><img src="http://i.imgur.com/wVBKD.png" alt="Angularjs" /></p>

<!--more-->


<h2>Current User</h2>

<p>For the example, our current user object is super simple.  Just pretend that it holds all of the relevant details of a user.  These details are useful for displaying various things in the app that need the context of who the currently logged-in user is.</p>

<p>```coffeescript current-user.coffee
  angular.module('app.services').factory 'CurrentUser', ($http, User) -></p>

<pre><code>class CurrentUser extends User
  fetch: -&gt;
    # do $http things to request user data
  isLoaded: -&gt;
    # true if fetched and ready to go

new CurrentUser
</code></pre>

<p>```</p>

<p>Note that for our app there is just one <code>CurrentUser</code> object, a singleton, because we return a single instance from our factory, not a class.</p>

<h2>Router</h2>

<p>The Angular router is used for client-side routing of urls.  Our angular app is called <code>app</code>.  We setup some angular submodules to hold config, services, and controllers.</p>

<p>Let's say that we have a home page and a profile page for our example.</p>

<p>Each route can be configured with a <code>resolve</code> object.  The key of that object is the name of a local variable and the value is a function which returns a promise.  The resolution value of the promise is the data you want before the route executes.After all the promises are resolved, the route is free to switch and execute.  Until then, each unresolved promise will block the route from executing.</p>

<p>```coffeescript app.coffee
angular.module 'app.config', []
angular.module 'app.services', []
angular.module 'app.controllers', []</p>

<p>angular.module('app', ['app.config', 'app.services', 'app.controllers'])</p>

<p>angular.module('app').config ($routeProvider, $locationProvider, resolves) ->
  $locationProvider.html5Mode true</p>

<p>  $routeProvider</p>

<pre><code>.when '/',
  controller: 'HomeCtrl'
  templateUrl: '/templates/home.html'
.when '/profile',
  controller: 'ProfileCtrl'
  templateUrl: '/templates/profile.html'
</code></pre>

<p>angular.module('app').run ($route, resolves)->
  for r in $route.routes</p>

<pre><code>r.resolve ?= {}
r.resolve.CurrentUser = resolves.getCurrentUser
</code></pre>

<p>```</p>

<p>The <code>run</code> method is essentially the Angular app's main method, starting the program.  I want to ensure the current user is loaded for each route.  In this case, instead of putting a <code>resolve</code> config on each route, I'm looping through all routes after their initial definition and adding the <code>CurrentUser: resolves.getCurrentUser</code> config.</p>

<h2>Resolve Function</h2>

<p>In our resolve function we setup our own promise via the <code>$q</code> service.  We check to see if our singleton <code>CurrentUser</code> is already loaded.  If it's not, we fetch it.  If it has been fetched once already, we resolve the promise with the value that's already available.</p>

<p>```coffeescript resolves.coffee
angular.module('app.config').constant 'resolves',</p>

<p>  getCurrentUser: ($q, CurrentUser) -></p>

<pre><code>defer = $q.defer()

if not CurrentUser.isLoaded()
  req = CurrentUser.fetch()
  req.success -&gt; defer.resolve CurrentUser
  req.error -&gt; defer.reject()
else
  defer.resolve CurrentUser

defer.promise
</code></pre>

<p>```</p>

<h2>Application Controller</h2>

<p>Now that we have the <code>CurrentUser</code> guaranteed to be resolved (fetched and returned) by the time we enter all routes, we need to grab the value of <code>CurrentUser</code> and put it in <code>$scope</code> where our program would normally pick up and start using variables.</p>

<p>```coffeescript app-ctrl.coffee
angular.module('app.controllers').controller 'AppCtrl', ($scope) -></p>

<p>  $scope.$on '$routeChangeSuccess', (next, current) -></p>

<pre><code>if current.locals.CurrentUser?
  $scope.currentUser = current.locals.CurrentUser
</code></pre>

<p>```</p>

<p>We listen the Angular-provided event when a route is successfully entered: <code>$routeChangeSuccess</code>.  The value we care about is available on the <code>current</code> route's <code>locals</code> object, placed there magically by the resolve function.</p>

<h2>When to Use</h2>

<p>There are a few bits to piece together to make this happen.  It might be simpler than other solutions or make more sense for you in your app if you need something(s) loaded previous to executing on a route.</p>

<p>I would definitely use this feature judiciously, as it seems to eat away at one of the advantages of a client-side app in the first place: asynchronous loading.  We'8re blocking the whole app from going forward when we're in the process of resolving.  That boundary used to be on the edge of the server, building up the page before it was servable to the client.  Now, on a web client, we have multiple requests that can happen in parallel and we can render bits as they're available -- important bits first and so on.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember Dynamic Classes]]></title>
    <link href="http://jaketrent.com/post/ember-dynamic-classes/"/>
    <updated>2013-08-02T13:02:00-06:00</updated>
    <id>http://jaketrent.com/post/ember-dynamic-classes</id>
    <content type="html"><![CDATA[<p>In Ember, your state is separated from the UI inside models.  But, often you want the state of your models to be represented visually in the UI via dynamic class names.  Make it happen with <code>Ember.View</code>s.</p>

<p><img src="http://i.imgur.com/85v8PQP.png" alt="Dynamic Classes with Ember Views" /></p>

<!--more-->


<h2>Use an Ember.View</h2>

<p>A view will function as the translation layer between the state of your models and the DOM.  It will provide the logic to observe the properties within your model and expose it as a class name on the associated DOM element.</p>

<p>If I have a model with state:</p>

<p><code>coffeescript my-model.coffee
App.MyModel = App.Model.extend
  hasSomeState: true
</code></p>

<h2>Use classNameBindings</h2>

<p>Based on that state, I want to add a <code>has-some-state</code> class to the UI if it's true, and remove the class if it's false.  The view might look like:</p>

<p>```coffeescript my-model-view.coffee
App.MyModelView = Ember.View.extend
  # ...
  classNameBindings: ['hasSomeState']
  hasSomeState: (-></p>

<pre><code>@get('content').get('hasSomeState')
</code></pre>

<p>  ).property('content.hasSomeState')
```</p>

<p>The <code>hasSomeState</code> function will return a boolean has to whether or not the <code>has-some-state</code> class should be added to the element.</p>

<h2>Bind to Model Properties</h2>

<p>Now use the view in the template, being careful to match the binding of <code>content</code> so the property watching works:</p>

<p><code>haml template-fragment.jade
App.MyModelView contentBinding="this.myModelInstance"
</code></p>

<p>In the example, make sure <code>myModelInstance</code> is available in the scope of your route/controller.</p>

<p>As your model's <code>hasSomeState</code> value is changed internally with the <code>@set</code> function, the view will be notified that it needs to re-run the <code>hasSomeState</code> function, and the UI will update if needed.</p>

<p>What other methods do you utilize in Ember to get dynamic classes?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Style File Input]]></title>
    <link href="http://jaketrent.com/post/style-file-input/"/>
    <updated>2013-07-23T16:44:00-06:00</updated>
    <id>http://jaketrent.com/post/style-file-input</id>
    <content type="html"><![CDATA[<p>File input fields are notoriously painful to style.  Here are a few quick tips to that will save you some dead ends.</p>

<p><img src="http://i.imgur.com/sm1b2ok.jpg" alt="File input" /></p>

<!--more-->


<h2>The Problem with File Inputs</h2>

<p>File inputs are inconsistent to start with.  They differ even in their native form across all browsers.  They also have internal elements that are not individually accessible, such as the "Browse" button.  They are also subject to more browser-imposed security constraints than input fields of other types.</p>

<p>Given these inherent problems/constraints, try to follow two basic rules:</p>

<ol>
<li>Don't expect to make your file input look exactly like you'd like</li>
<li>Don't trigger clicks on the file input</li>
</ol>


<h2>Styling the File Input</h2>

<p>Why is file input rule reasonable?  Shouldn't you be able to match the UI design you desire?  Yes, on both counts.</p>

<p>Don't style the file input to make it look like a photo upload button (or whatever you're marking).  Instead, <strong>hide it</strong>.  And after you hide it, position it <strong>over</strong> another another element, such as a <code>div</code>, that you can style much more easily to look like the UI you envision.</p>

<p>Here is some example css on how you might accomplish this:</p>

<p><code>haml fileinput.jade
.file-wrapper
  .file-input(type="file")
</code></p>

<p>```sass fileinput.styl
.file-wrapper
  position: relative
  overflow: hidden
  cursor: pointer</p>

<p>.file-input
  position: absolute
  top: 0
  right: 0
  z-index: 2
  opacity: 0.01
  height: 100%
  font-size: 150px
```</p>

<p>The add additional styles to <code>.file-wrapper</code> to make it look as you wish.  Remember any vendor prefixes you may/not need for <code>opacity</code>, etc.</p>

<h2>Handling Double Clicks in IE</h2>

<p>It's important to position the <code>.file-input</code> as <code>right: 0</code>.  Otherwise, in IE the file input field will not activate on a single click.  Instead it'll need a double click.  This is because in IE clicking on the text box portion of the file input requires a double click.  Clicking on the browse button requires just a single click.  And the browse button is on the right side of the file input field in IE.  Finally, make the <code>font-size</code> big enough that you're guaranteed to cover the <code>.file-wrapper</code> area.</p>

<h2>Handling Clicks</h2>

<p>Now you don't need to have JavaScript to trigger click events on the file input field.  You will just be relying on direct user interaction to click the native file input field.  This will make <a href="http://stackoverflow.com/questions/210643/in-javascript-can-i-make-a-click-event-fire-programmatically-for-a-file-input">some browsers</a>, like Chrome and Firefox, happy.  This is because these browsers won't hold file values given to the input programmatically as a security precaution.  Oddly, IE, which sometimes balks more about innane security constraints like this, is ok.</p>

<p>So, what do you think?  Does this work for you?  Anything else to make the solution more solid?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Namespacing Angular Controller Attributes]]></title>
    <link href="http://jaketrent.com/post/namespacing-angular-controller-attributes/"/>
    <updated>2013-07-10T18:17:00-06:00</updated>
    <id>http://jaketrent.com/post/namespacing-angular-controller-attributes</id>
    <content type="html"><![CDATA[<p>Usually attributes of your Angular controllers are not namespaced.  But you can namespace them.  But you might not want to.</p>

<p><img src="http://i.imgur.com/wVBKD.png" alt="AngularJs controller namespacing" /></p>

<!--more-->


<h2>Angular Controllers Usually Attach Attributes to Scope</h2>

<p>Usually attributes in an Angular controller, such as functions and variables, are attached to the <code>$scope</code> object.  That looks like this:</p>

<p>```coffeescript my-ctrl.coffee
angular.module('myapp').controller 'MyCtrl', ($scope) ->
  $scope.myVar = 'myVal'
  $scope.myFn = -></p>

<pre><code>console.log 'does stuff'
</code></pre>

<p>```</p>

<p>Then in my template I don't know, nor do I need to know, where the attribute comes from.  I just reference it:</p>

<p>```haml my-app.jade
html(ng-app="myapp")
  body(ng-controller="MyCtrl")</p>

<pre><code>h1 My Var: 
button(ng-click="myFun()") Does Stuff
</code></pre>

<p>```</p>

<h2>Namespaced Angular Controller Attributes</h2>

<p>In this simple example, this is no big deal.  But as your app grows in complexity with many, nested controllers and templates, it can become difficult to read the code.  If you have common function names, it might be hard to tell which controller's function is referenced in your templates.  To make this less of a problem and the code more clear, you might namespace your controller attributes in the template.</p>

<p>To do this, you can write your controllers to attach attributes to the controller instead of scope and then put the controller itself on scope.  That looks like this:</p>

<p>```coffeescript my-ctrl.coffee
angular.module('myapp').controller 'MyCtrl', ($scope) ->
  @myVar = 'myVal'
  @myFn = -></p>

<pre><code>console.log 'does stuff'
</code></pre>

<p>  $scope.MyCtrl = @
```</p>

<p>Then your template changes to look like this:</p>

<p>```haml my-app.jade
html(ng-app="myapp")
  body(ng-controller="MyCtrl")</p>

<pre><code>h1 My Var: 
button(ng-click="MyCtrl.myFun()") Does Stuff
</code></pre>

<p>```</p>

<p>It's kind of nice for the reasons stated above.  I saw this strategy referenced on the Interwebs at one point and thought it seemed like a good idea.</p>

<h2>Why You Might Avoid This</h2>

<p>Maybe you love the idea.  Maybe you don't.  I thought I did.  I have been writing controllers this way for a while.  Now I don't.  Here's why:</p>

<h3>1. It Makes Templates Less Reusable</h3>

<p>It's quite probable that I'll have templates that I don't want permanently attached to a specific controller.  An example I ran into recently was on a profile page.  I had two pages to show profiles: one for my profile and one for an arbitrary person in the system.  They looked the same in the UI.  They had the same basic functions.  But the source of data for the variables and the implementation of the functions was different in the two scenarios.  Thus, I had to refactor to remove the namespacing to be able to reuse the template across pages.</p>

<h3>2. It's More Typing</h3>

<p>It's silly.  It adds up.  The less superfluous typing I can do, the more I consider that solution.</p>

<h3>3. The Creators Don't Do It</h3>

<p>I haven't seen this strategy featured in official tutorials, guides, or API examples.  Not that the Angular d00ds have all the ideas or do everything right -- it just isn't a pattern I see widely accepted or used.</p>

<p>These days, I don't namespace my controller attributes, and I don't recommend it.</p>

<p>So what do you think?  Do you write your controllers this way?  Good idea?  Bad idea?  What are some alternative methods you've found to balance template reuse with readability?</p>
]]></content>
  </entry>
  
</feed>
