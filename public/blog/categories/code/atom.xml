<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-04-22T06:26:53-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[react-dnd With Text Drag Preview]]></title>
    <link href="http://jaketrent.com/post/react-dnd-text-drag-preview/"/>
    <updated>2016-04-21T08:04:00-06:00</updated>
    <id>http://jaketrent.com/post/react-dnd-text-drag-preview</id>
    <content type="html"><![CDATA[<p><a href="http://gaearon.github.io/react-dnd/">react-dnd</a> is a fantastic library for implementing drag and drop features in a React application.  In browsers, you have the ability to specify a drag preview for the thing your dragging.  Images are easy.  Text takes more work -- because you need to generate an image.</p>

<p><img src="http://i.imgur.com/E5NwBek.png" alt="react-dnd text drag previews" /></p>

<!--more-->


<p>I love the abstractions in react-dnd.  They seem very elegant.  We're going to need another abstraction here, because there's a short list of things that we need to do in order to get a text-based drag preview showing up in our app.  These things are required because drag previews in browsers only support images.  Thus we will need to take source text from our app code and convert it into an image in order to hand it off to the drag and drop api.</p>

<h2>Drag Text from a Canvas</h2>

<p>To convert text to an image, we must:</p>

<ol>
<li>Create a canvas element</li>
<li>Fit the canvas to our text</li>
<li>Style the canvas</li>
<li>Create a new image element with the canvas data as src</li>
</ol>


<h4>Create a Canvas Element</h4>

<p>We choose a canvas element because we can write text onto it and eventually export its bytes.</p>

<p><code>js
var c = document.createElement('canvas')
var ctx = c.getContext('2d')
</code></p>

<h4>Fit Canvas to the Text</h4>

<p>We want the drag preview to be dynamically sized.  This is because the text can change in length.   The key to our success is available on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/measureText">Canvas 2D context as <code>measureText</code></a>.  This function is available in IE9+.  In case you don't have access to this function, you can attempt a crude fallback.</p>

<p>```js
function getTextWidth(ctx, fontSize, text) {
  if (typeof ctx.measureText === 'function') {</p>

<pre><code>return ctx.measureText(text).width
</code></pre>

<p>  } else {</p>

<pre><code>var perCharWidth = fontSize / 1.7
return text.length * perCharWidth
</code></pre>

<p>  }
}
```</p>

<h4>Style the Canvas</h4>

<p>Once you know how big to make your drag preview, draw a rectangle upon which you can then draw your text.</p>

<p>In addition to drawing the main content, there are also other stylistic adjustments that you can make via <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D">attributes on <code>CanvasRenderingContext2D</code></a>.  Attributes like <code>fillStyle</code>, <code>strokeStyle</code>, and <code>font</code> are available.</p>

<p>```js
ctx.rect(0, 0, rectWidth, rectHeight)</p>

<p>ctx.save()
ctx.fillStyle = backgroundColor
ctx.strokeStyle = borderColor
ctx.fill()
ctx.stroke()
ctx.restore()</p>

<p>ctx.fillText(text)
```</p>

<h4>Create a new Image Element</h4>

<p>Remember, drag preview requires an image to render when the user is dragging.  Set the <code>src</code> of the image to the data from the canvas.  This will transfer everything you just created in the canvas into an image.</p>

<p><code>js
var img = new Image()
img.src = c.toDataURL()
</code></p>

<p>This image should be ready to use in react-dnd's <a href="http://gaearon.github.io/react-dnd/docs-drag-source-connector.html"><code>connect#dragPreview</code></a>.</p>

<h2>A Library to Help</h2>

<p>When making a React drag and drop app, I usually don't look forward to using the sometimes-arcane API of the <code>canvas</code> element.  So, I wrapped it up so I wouldn't have to look at it as often.</p>

<p>If you think this might help you, take a look at <a href="http://npm.im/react-dnd-text-dragpreview">react-dnd-text-dragpreview</a>.</p>

<p>How do you go about doing text-based drag previews?  Any other good tips?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Change Default NPM License]]></title>
    <link href="http://jaketrent.com/post/change-default-npm-license/"/>
    <updated>2016-03-24T15:45:00-06:00</updated>
    <id>http://jaketrent.com/post/change-default-npm-license</id>
    <content type="html"><![CDATA[<p>Npm has a fantastic init tool for creating the descriptor for your project.  It will gladly provide defaults for you.  These are sometimes helpful.  Wouldn't it be more better to define your own defaults?</p>

<p><img src="http://i.imgur.com/P34k4L5.png" alt="NPM" /></p>

<!--more-->


<h2>Npm Init</h2>

<p>If you're doing any JavaScript development, NPM is likely a helpful tool for your toolbox.  To add a descriptor with meta information, including things like 3rd-party project dependencies, you need a <code>package.json</code> for your project.  To get this file, you can edit it by hand or have one generated for you.  To generate it, run:</p>

<p><code>
npm init
</code></p>

<p>You will then be prompted to answer a series of relevant questions, such as:</p>

<p><code>
name: (hello-riot)
version: (1.0.0)
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
...
</code></p>

<p>The values in parenthesis are the defaults.  Defaults are determined from things like the directory you're in, the git repository you're in, etc.</p>

<h2>Set Npm Init Defaults</h2>

<p>Some defaults are just the NPM-provided conventions.  They don't know much more to provide.  But you can provide your own defaults for your system by editing <code>~/.npmrc</code>.  Or you can use the cli to add to this file from the terminal.  For instance, the two I like to change are my author name and the license:</p>

<p><code>
npm config set init-author-name "jaketrent"
npm config set init-license "MIT"
</code></p>

<p>Now, you can init and just take the defaults without pressing enter to answer the question with:</p>

<p><code>
npm -y
</code></p>

<p>And what you get are the defaults you've already decided you like.</p>

<p>To know what other things you can change as defaults, use <code>npm help 7 config</code> and grep for <code>init-</code>-prefixed values.  Happy npm'ing!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Selecting a Directory in Electron]]></title>
    <link href="http://jaketrent.com/post/select-directory-in-electron/"/>
    <updated>2016-03-21T10:12:00-06:00</updated>
    <id>http://jaketrent.com/post/select-directory-in-electron</id>
    <content type="html"><![CDATA[<p>Electron will help you make some sweet native desktop apps using web tech.  Now that you're on the desktop, one of the cool things you can do is access the filesystem.  There are a couple ways to access the filesystem via the file open dialog using user input events.</p>

<p><img src="http://i.imgur.com/Vp8Zuix.jpg" alt="Electron" /></p>

<!--more-->


<h2>From HTML</h2>

<p>In Electron, you use HTML for your views.  Thus, if you want the user to select a directory from the UI, you can use a <code>&lt;input type="file" /&gt;</code>, just like in a normal web app.</p>

<h4>Select Only Directories</h4>

<p>To select only directories, there is an attribute you can add to the <code>input</code> tag:</p>

<p>```html
&lt;input type="file"</p>

<pre><code>   webkitdirectory /&gt;
</code></pre>

<p>```</p>

<p>This wouldn't be reliable in a cross-browser environment.  But since, on Electron, you're only targeting Chrome, you're golden with whatever Chrome has available to you.</p>

<h4>Bonus: Programmatically click on <code>input[type="file"]</code></h4>

<p>As a bonus, Electron doesn't have the sandbox security restrictions that you would have in a standalone browser like Chrome.  In browsers, sometimes the file open dialog will fail if anything triggers the dialog besides the user clicking with their own mouse on the file input field.  Sometimes getting at the contents of the file will fail.  I'm too lazy to test which browsers do what at this point, but sad past experience has determined that this is unreliable.</p>

<p>But in Electron, you are again liberated.  For instance, <code>input[type="file"]</code> is ugly and sometimes hard to style into exactly what you want.  So, it's often that you'll want to create a custom widget, that when <em>it's</em> clicked, the <code>input[type="file"]</code> is clicked and the file open dialog is popped.</p>

<p>Given:</p>

<p><code>html
&lt;button id="party" class="very-sweet-looking"&gt;Open&lt;/button&gt;
&lt;input id="business" type="file" style="display: none" /&gt;
</code></p>

<p>This totally works:</p>

<p><code>js
document.getElementById('party').addEventListener('click', _ =&gt; {
  document.getElementById('business').click()
})
</code></p>

<h2>From Electron API</h2>

<p>In the main process, you have access to an Electron API, <code>dialog</code>.  <a href="http://electron.atom.io/docs/v0.37.2/api/dialog/#dialogshowopendialogbrowserwindow-options-callback"><code>dialog#showOpenDialog</code></a> is a programmatic API that allows you to open the same open file dialog that you're used to in the browser.  What's even better is that here you can set that only directories should be openable rather easily:</p>

<p>```js
// mainWindow is your instance of BrowserWindow
const electron = require('electron')
const dialog = electrong.dialog
function selectDirectory() {
  dialog.showOpenDialog(mainWindow, {</p>

<pre><code>properties: ['openDirectory']
</code></pre>

<p>  })
}
```</p>

<p>In order to integrate this main process code with user interaction, we need to do a few things.</p>

<p>First, export the code from your main process module:</p>

<p><code>js main.js
exports.selectDirectory = function () {
  // dialog.showOpenDialog as before
}
</code></p>

<p>And then in the renderer process, capture user events as before and call the main process function, <code>selectDirectory</code>:</p>

<p><code>js renderer.js
const electron = require('electron')
const remote = electron.remote
const mainProcess = remote.require('./main')
document.getElementById('party').addEventListener('click', _ =&gt; {
  mainProcess.selectDirectory()
})
</code></p>

<p>Works pretty nicely, but feels weird that you have to go back to the main process to access a view-related API (as of Electron 0.37).</p>

<p>So, if there are two ways to do this, there has to be another, right?  What are you doing to select a directory in Electron?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Console.log Deep Objects]]></title>
    <link href="http://jaketrent.com/post/console-log-deep-objects/"/>
    <updated>2016-03-14T15:13:00-06:00</updated>
    <id>http://jaketrent.com/post/console-log-deep-objects</id>
    <content type="html"><![CDATA[<p>With deep object structures, <code>console.log</code> can leave you wondering what's down in the depths of the objects you're printing out.  Here's a quick help from Node stdlib.</p>

<p><img src="http://i.imgur.com/00WAox4.jpg" alt="console.log deep objects" /></p>

<!--more-->


<p>You can usually see the objects that you're <code>console.log</code>ing, and life is good:</p>

<p>Given:</p>

<p><code>js
const stickers = {
  are: 'fun'
}
console.log('stickers', stickers)
// Outputs: stickers { are: 'fun' }
</code></p>

<p>We can see the whole object, and we're happy.  We can even do objects up to a depth of 3 sub objects, and it works great:</p>

<p>```js
const stickers = {
  are: {</p>

<pre><code>even: {
  more: 'fun'
}
</code></pre>

<p>  }
}
console.log('stickers', stickers)
// Outputs: stickers { are: { even: { more: 'fun' } } }
```</p>

<p>If, however, we have a potentially deeply-nested object, we'll get some of our data truncated:</p>

<p>```js
const stickers = {
  are: {</p>

<pre><code>even: {
  more: {
            than: {
                outrageously: 'fun'
            }
        }
}
</code></pre>

<p>  }
}
console.log('stickers', stickers)
// Outputs: stickers { are: { even: { more: [Object] } } }
```</p>

<p><code>[Object]</code>s are cool and all, but not very informative.</p>

<p>To get at this information, use <a href="https://nodejs.org/api/util.html#util_util_inspect_object_options"><code>util.inspect</code></a> from the <a href="https://nodejs.org/api/util.html#util_util_inspect_object_options">stdlib</a>.  Here, you can set a depth option to be higher, letting you peer into those deep objects in the console:</p>

<p>```js
const util = require('util')
const stickers = {
  are: {</p>

<pre><code>even: {
  more: {
            than: {
                outrageously: 'fun'
            }
        }
}
</code></pre>

<p>  }
}
console.log('stickers', util.inspect(stickers, { depth: 4 }))
// Outputs: stickers { are: { even: { more: { than: { outrageously: 'fun' } } } } }
```</p>

<p>Your data is yours again!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gitignore System Files]]></title>
    <link href="http://jaketrent.com/post/gitignore-system-files/"/>
    <updated>2016-03-14T14:43:00-06:00</updated>
    <id>http://jaketrent.com/post/gitignore-system-files</id>
    <content type="html"><![CDATA[<p>There are many files that you don't want to store in your project's Git repo.  Some of these are even specific to the project.  Some are definitely not.  How do you ignore these that aren't related to the project?</p>

<p><img src="http://i.imgur.com/ZYiky6R.png" alt="Git ignore" /></p>

<!--more-->


<h2>.gitignore For the Project</h2>

<p>In your project directory, you likely have a <code>.gitignore</code> file.  Here, you keep things that might show up in that directory out of the project's version-controlled source tree.  There's not much to it.  On each line of the file, list the file names, directory names, or partial patterns that you don't want Git to track or even know about.</p>

<p>For instance, if you're doing a Node.js project, you probably want to track all your own <code>.js</code> files, found in <code>src/</code>.  But you don't want to track all those 3rd-party modules in <code>node_modules</code>.  You probably don't want to track your code compiled for distribution either.  So, your project's <code>.gitignore</code> file might look like this:</p>

<p><code>text project/.gitignore
node_modules
dist
</code></p>

<h2>.gitignore For Your System</h2>

<p>Everything that goes in the project's <code>.gitignore</code> file should relate to the project.  And it should relate to everyone.</p>

<p>There are many people and systems interacting with your project.  For instance, some developers might be on Mac OSX and get those nasty Finder thumbnail files, <code>.DS_Store</code> that end up popping up all over the place.  Others on the project might use the venerable Jetbrains editors which drop an <code>.idea/</code> directory in every project they edit.  These facts should be transparent to your project.  Every time someone picks up a new editor or switches an OS, the project shouldn't have another commit updating the <code>.gitignore</code> with yet another thing.</p>

<p>You can make Git ignore files that appear on your system but are unrelated to the project.</p>

<p>Edit your top-level <code>~/.gitgnore</code>.  Add all your system-related things there.  It might end up look like:</p>

<p><code>text ~/.gitignore
.DS_Store
.idea
</code></p>
]]></content>
  </entry>
  
</feed>
