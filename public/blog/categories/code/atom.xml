<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-02-17T09:50:02-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Smart and Dumb Components in React]]></title>
    <link href="http://jaketrent.com/post/smart-dumb-components-react/"/>
    <updated>2016-02-17T08:55:00-07:00</updated>
    <id>http://jaketrent.com/post/smart-dumb-components-react</id>
    <content type="html"><![CDATA[<p>Dan Abramov coined the terms <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">Smart and Dumb components</a>.  Later, he called them Container and Presentational components.  I still call them Smart and Dumb.  It's shorter and sits in my mind easier.  How do you identify them?  Why would you want a separation?  What might that separation look like?  Here are a few ideas.</p>

<p><img src="http://i.imgur.com/9VKyXtu.png" alt="Smart and Dumb React components" /></p>

<!--more-->


<h2>Smart vs Dumb Components</h2>

<p>So what sets these components apart?  Smart means "container" or "app-level".  Some have compared it to the "C" in MVC.  Dumb means "presentational" or "ui only", possibly comparable to the "V" in MVC.  Here's a breakdown of a few key characteristics:</p>

<h3>Smart Component Characteristics</h3>

<ul>
<li>Describe <em>how things work</em></li>
<li>Provide no DOM markup or styles</li>
<li>Provide application data, do data fetching</li>
<li>Call Flux actions</li>
<li>Named *Container by convention</li>
</ul>


<h3>Dumb Component Characteristics</h3>

<ul>
<li>Describe <em>how things look</em></li>
<li>Have no app dependencies</li>
<li>Receive only props, providing data and callbacks</li>
<li>Rarely have own state, when they do, it's just UI state</li>
<li>Named anything that's a UI noun</li>
</ul>


<p>Apparently you need each class of components because obviously your app has to smart to be interesting.  But if it's more dumb, it's more simple.  So split it.  You need both.</p>

<p>If you separate concerns, your app will be easier to reason about, complexity will be mostly localized around the Smart components, and you should be left with more simple components.  UI components will be more reusable.</p>

<h2>Where to Split Smart and Dumb Components?</h2>

<p>If you keep all Smart characteristics on one side and the Dumb characteristics on the other, you will have made the separation and be following the guiding principles.</p>

<p>But how should you make that split?  Here are a couple ideas.  These are observations of how I've found myself making the split and what it ends up looking like.</p>

<h3>Deep Split</h3>

<p>"Deep" describes what I usually observe when I split components this way.  There's one Smart component that splits to one Dumb component.  There's a 1:1 relationship.  This seems simple, and it is in a way.  It probably works better if the components are small, because many of the smarts from the Smart component end up getting passed down to the Dumb component.  This makes for a lot of props on the Dumb component.</p>

<p>If the Dumb component does anything interesting, it usually will fan out at that point and start farming <code>props</code> off to the child components that actually need them.  Thus, the hierarchy deepens before it actually ends up doing work.</p>

<p><img src="http://i.imgur.com/scfodt6.png" alt="Deep component split" /></p>

<h3>Broad Split</h3>

<p>"Broad" describes the transition from Smart to Dumb happening sooner.  There is one Smart component that has many Dumb component children.  There aren't necessarily fewer interesting things here or props to pass, but they're scattered out, going straighter to the components that need them instead of going through some Monolith Proxy Dumb component (all the bad words together).</p>

<p><img src="http://i.imgur.com/hxusLJ2.png" alt="Broad component split" /></p>

<p>A highlight advantage here is that there is much readier access to the Smart component's smarts -- store data, event handlers, and actions.  You don't feel like you're passing props <em>through</em> components only to get them to the components that really use them.</p>

<p>A golden quote from Dan Abramov that highlights this is:</p>

<blockquote><p>When you notice that some components don’t use the props they receive but merely forward them down and you have to rewire all those intermediate components any time the children need more data, it’s a good time to introduce some container components.</p></blockquote>

<h2>Nodes as props</h2>

<p>In his quote, Dan recognizes the time to introduce container components.  In my mind, "container" means Smart.  Here, I don't think we necessarily require a Smart Container, because we usually like to get as Dumb as we can as fast as we can.  So, how about a Dumb component that just provides <em>containment</em>?</p>

<p>We can provide DOM markup, component grouping, layout, or other UI abstractions with components that take <code>props.children</code>.  These children are usually components, of type <code>React.PropTypes.node</code>.  Doubtless we've all realized by now that there's just one <code>props.children</code>.  But component can only wrap one thing, right?  Well, this is in the syntax of markup/JSX, but this isn't true <em>inside</em> the Component.  We could have more attributes that pass <code>PropTypes.node</code> arguments.  This allows for <em>containing more</em> nodes and having convenient handles on them within components.</p>

<p>This thought was revelatory at the time it occurred to me.  Looking back, it seems obvious.  But for some reason, probably because I still think of it as HTML sometimes, it feels funny to write something like:</p>

<p><code>js
&lt;Dumb aProp={&lt;AnotherDumb /&gt;} /&gt;
</code></p>

<p>Then inside the Dumb component, we can display those attributes directly:</p>

<p>```js
function Dumb(props) {
  return (</p>

<pre><code>&lt;div className={props.css.awesomeLayout}&gt;
  {props.aProp}
&lt;/div&gt;
</code></pre>

<p>  )
}
```</p>

<h2>What to Pass as Props?</h2>

<p>If we have a split we like, now we have to decide what <code>props</code> to send from the parent to the child components.</p>

<h3>Send Them All</h3>

<p><code>js
&lt;Dumb {...this.props} /&gt;
</code></p>

<p>Yes, you could just send all the parent's props to the child.  I would do this when the parent feels just like a wrapper.  It's a passthrough.  Perhaps it adds something small and targeted.  It's a higher-order component.</p>

<h3>Pass the Reducer/Selector</h3>

<p><code>js
&lt;Dumb reducerName={this.props.reducer} /&gt;
</code></p>

<p>You can pass the whole nested reducer state, sure.  Almost every time I feel myself wanting to do this, I think it's motivated by laziness.  It has a potential downside of tying the reducer format to the view in more places than required.  Of course, if you have custom selectors for everything anyway, you make your break from reducer format coupling there.</p>

<h3>Pass New Variables</h3>

<p><code>js
&lt;Dumb newVar={this.props.var} /&gt;
</code></p>

<p>This is most commonly what passing variables to children components looks like.  These values are usually primitives, but they can you can send down entire new object structures as well.  It has the advantages of being explicit and traceable.  It also avoids the coupling of passing entire nested reducers.</p>

<h2>Rule of Thumb</h2>

<p>In all design decisions, it's good to have some quick guidelines in mind when making decision.  So relative to splitting Smart and Dumb components, here's a rule of thumb.</p>

<p>On many of my projects recently, I use two decorators that help identify Smart and Dumb components:</p>

<p>For Smart, the <a href="https://www.npmjs.com/package/redux-react-connect-by-name">redux-react-connect-by-name</a> component facilitates data fetching from the redux store.  This is equivalent to using redux's vanilla <code>connect</code> with some built-in niceties.</p>

<p>For Dumb, the <a href="http://npmjs.com/react-styleable">react-styleable</a> component allows passing CSS modules into React components.  This is how I like to give my components styling information.</p>

<p>If one is for Smart and the other for Dumb, then I can usually identify a potential split if I ever see them <em>together</em>.  For example, this is what that antipattern might look like:</p>

<p>```js
import connect from 'redux-react-connect-by-name'
import styleable from 'react-styleable'
// ...</p>

<p>@connect([someSelector])
@styleable(someCss)
class MyComponent extends React.Component {
  // ...
}
```</p>

<p>Split that up!</p>

<h2>This Isn't Dogma</h2>

<p>The idea of Smart vs. Dumb components is, itself, just a guideline -- a Pirates' Code-level of guideline.  Keep it and use it where it helps your project.  This is an art form.  No one has the best answer for how to organize your React views.  Do the best you can.  Then, next week, when you find a better way, advance to that.</p>

<p>What are some other observations that you've made when splitting your views into Smart and Dumb components?</p>

<p><em>Adapted from a meetup talk:</em></p>

<script async class="speakerdeck-embed" data-id="26cce4743e5540b48188a35f49de3c4d" data-ratio="1.33333333333333" src="http://jaketrent.com//speakerdeck.com/assets/embed.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Node Skills to Explore]]></title>
    <link href="http://jaketrent.com/post/node-skills-explore/"/>
    <updated>2016-01-26T10:00:00-07:00</updated>
    <id>http://jaketrent.com/post/node-skills-explore</id>
    <content type="html"><![CDATA[<p>We are hiring a bunch of Node.js developers at the moment.  You may be as well.  I'm sure you have a good list of skills that you're looking for in developers that join your posse.  Here are a few <em>technical</em> things I think about when getting the opportunity  to sit down with a Node developer.</p>

<p><img src="http://i.imgur.com/9WglUIw.jpg" alt="Exploring Node Skills" /></p>

<!--more-->


<p>What might you add to the list?</p>

<h2>Async Programming</h2>

<ul>
<li>What are options for async flow control?  Favorites?  Least?  Pros?  Cons?</li>
<li>Node event loop -- How does it work?  What applications does it fit?</li>
</ul>


<h2>Error Handling</h2>

<ul>
<li>Limitations/advantages in handling async errors?</li>
<li>Handle errors in Promises?</li>
<li>Handle errors in callbacks?</li>
<li>What errors should be thrown?</li>
</ul>


<h2>Functional</h2>

<ul>
<li>What is immutability?  Why want it?</li>
<li>Basic Array.prototype methods?</li>
<li>What does shared state give you?</li>
<li>Advantages to pure functions?</li>
<li>Applications of higher-order functions?</li>
</ul>


<h2>API</h2>

<ul>
<li>Specifically, how does CORS work?</li>
<li>Familiar with which request and response formats?  Favorite?  Worst?  Why?</li>
<li>How does middleware work?  When do you like to use it?</li>
</ul>


<h2>Ops</h2>

<ul>
<li>How can you use all CPUs on a server?</li>
<li>How to associate logs together with a single request path?</li>
<li>How to recover from fatal errors?</li>
<li>How do you load per-environment configuration?</li>
<li>How do you handle versioning of your apps and libs?</li>
</ul>


<h2>Modules</h2>

<ul>
<li>Why use modules?</li>
<li>How do you organize your API apps' modules?</li>
<li>Flavors of exports?  When do use each?</li>
</ul>


<h2>ES Next</h2>

<ul>
<li>Which new features have you used?  Like, not like?</li>
<li>async/await - Used instead of what?</li>
<li>Object literal extensions - How used?</li>
<li>Spread operator - Helpful usecases?</li>
<li>Arrow functions - What do they help with?</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test APIs Failing from Client]]></title>
    <link href="http://jaketrent.com/post/test-apis-failing-from-client/"/>
    <updated>2016-01-25T13:54:00-07:00</updated>
    <id>http://jaketrent.com/post/test-apis-failing-from-client</id>
    <content type="html"><![CDATA[<p>In the case where you can't edit a local version of your APIs in order to cause them to fail, you need to be able to edit your client so that it <em>looks</em> like the API request fails.  Here's a quick code change that should make this easy for you.</p>

<p><img src="http://i.imgur.com/8Fm1cn2.jpg" alt="We have a problem" /></p>

<!--more-->


<p>This is one of many possible manual testing techniques.  This allow you to see the change in your running app as you work through it.  For instance, I like to use this as I'm testing through the error alerting features that are common in an app when an API request fails.</p>

<p>Go to the point in your app where your bits touch the network.  This is usually the place where you use your HTTP wrapper or, if you're a free spirit, call some XHR goodness yourself.  These days, I like using the venerable <a href="https://github.com/mzabriskie/axios">axios</a> library.  Axios is promise based, so that means that we can use async/await as well, which is like a fine chocolate next to a warm fire in winter (which is good).</p>

<p>So, all my http code might look in essence like this:</p>

<p>```js api.js
import axios from 'axios'</p>

<p>export const fetch = {
  // deserialize, etc ...
  request(url) {</p>

<pre><code>return axios({
  method: 'get',
  url
})
</code></pre>

<p>  }
}
```</p>

<p>So, this <code>request</code> function returns a Promise.  The logic around the request might look like:</p>

<p>```js actions.js
import * as api from './api'</p>

<p>async function fetchWater() {
  const { request} = api.fetch</p>

<p>  try {</p>

<pre><code>const res = await request('/my/own/home')
// ... handle success response
</code></pre>

<p>  } catch (res) {</p>

<pre><code>// ... handle error response, where failure code should execute (what we want to TEST!)
</code></pre>

<p>  }
}
```</p>

<p>To make this request fail, we need only make the Promise fail, rejecting it like a mouthful of stewed tomatoes.  So, just change <code>api.js</code>:</p>

<p>```js api.js
import axios from 'axios'</p>

<p>export const fetch = {
  // ...
  request(url) {</p>

<pre><code>return Promise((resolve, reject) =&gt; {
  reject({
    status: 500,
    data: {
      errors: [{ detail: 'Shere Khan is back!' }]
    }
  })
})
</code></pre>

<p>  }
}
```</p>

<p>Now note that you must be aware of what your format HTTP library, in this case axios, uses in its responses.  What you <code>reject</code> manually must be exactly the same format that usually is returned in an error situation (eg, <code>status</code> and <code>data</code>).  You must also know what your server is designed to return as an error response (eg, <code>errors</code>).  The above application code is using the <a href="http://jsonapi.org/format/#error-objects">JSON API</a> format.</p>

<p>What other little tricks do you find useful in getting APIs to fail?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What React Stateless Components are Missing]]></title>
    <link href="http://jaketrent.com/post/react-stateless-components-missing/"/>
    <updated>2016-01-04T12:59:00-07:00</updated>
    <id>http://jaketrent.com/post/react-stateless-components-missing</id>
    <content type="html"><![CDATA[<p>Stateless React components got a new syntax in React 0.14.  It's much simpler.  It's just a function call.  Besides it just looking simpler, there are some major differences in what is available in a stateless component written this way.  There are some things missing -- purposefully not included -- that you may be used to.  Let's look at a few things.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="http://i.imgur.com/DXuSNbw.png" /></p>

<!--more-->


<p>Stateless components are now specifically not just components where you don't use <code>this.state</code>.  They're componets that are written in the form of a function:</p>

<p><code>js
function Chips(props) {
  return &lt;div&gt;In the secret {props.place}&lt;/div&gt;
}
</code></p>

<p>The observations made in this article will not apply to components that are created using the <code>class Chips extends React.Component</code> or <code>React.createClass</code> syntax, whether they use state or not.</p>

<h2>No Backing Instance</h2>

<p>A React component's backing instance is the object in memory that represents the node in the view.  This backing instance is the place where state is usually stored (using React's <code>this.state</code>).  Well now there's no <code>this</code> in stateless components.  Thus, there's not going to be a place for <code>this.state</code>.  Stateless, remember?  Data just passes through the pure function and into the resulting view.</p>

<h2>No Lifecycle Methods</h2>

<p>Because there's no backing instance as a place to put hooks for your code in the component lifecycle, you can not use any of the lifecycle methods from <code>React.Component</code>.  Methods such as <code>componentDidMount</code> and <code>componentWillReceiveProps</code> are out.  And since the stateless component is a pure function that just reproduces its view state on <code>props</code> change, why would you need lifecycle methods anyway?</p>

<h2>No Reference to the Component</h2>

<p>Often when testing, it's useful to get a reference to the component itself.  In the case of stateless components, they're just fired and forgotten, rendered into the view without the ability to get a handle on them.  They're just UI at this point, just in the DOM.  You can go to the DOM to do your testing.</p>

<p>Depending on your test environment setup, you may want to wrap your stateless components in a <code>class</code>-based component you <em>can</em> get a reference to.</p>

<p>Note that for stateless components, <code>ReactDOM.render</code> and <code>TestUtils.renderIntoDocument</code> will return <code>null</code>.</p>

<h2>No refs</h2>

<p>Stateless components can't be the target of a <code>ref</code>.  There's no backing instance.  You can't have <code>refs</code> internally to children either.  Remember, <code>this</code> and <code>this.refs</code> aren't around.  If your stateless component has a child that is a <code>class</code>-based component, <em>it</em> may have <code>refs</code>.  <a href="https://facebook.github.io/react/docs/more-about-refs.html">The docs</a> are another good reference on <code>refs</code>.</p>

<h2>No null Returns</h2>

<p>A <code>class</code>-based component may return <code>null</code> as its value in the view.  But a stateless component may not.  To get around this, return <code>&lt;noscript&gt;&lt;/noscript&gt;</code>.  This will be fully invisible in the view.</p>

<p>So what else have you found that is unavailable in stateless functions?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debug Locally in Elm]]></title>
    <link href="http://jaketrent.com/post/debug-locally-elm/"/>
    <updated>2015-11-28T14:39:00-07:00</updated>
    <id>http://jaketrent.com/post/debug-locally-elm</id>
    <content type="html"><![CDATA[<p>Debugging in Elm is easy once you know where to look.  You need an in-browser tool to help you.  It's almost as simple as just calling <code>console.log</code>, but you can't just put your logging statement anywhere.</p>

<p><img src="http://i.imgur.com/1c6FH0f.png" alt="elm debug locally" /></p>

<!--more-->


<h2>The Online Option</h2>

<p>There's a debugger available online as a part of the elm-lang site at <a href="http://debug.elm-lang.org/">debug.elm-lang.org</a>.  This page explains the principles behind why the debugger works and has the properties it does.  The <a href="http://debug.elm-lang.org/try">debugger is found</a> via clicking the "Debug" button in the top-right corner.</p>

<p>But you don't want to paste your code into the Try Elm page in order to walk through your Elm code.  You need a local option.</p>

<h2>Debugging Locally</h2>

<p>Thankfully you already have the tools to debug locally after you've <a href="http://elm-lang.org/install">installed Elm</a> on your machine.   It comes with <code>elm-reactor</code>.</p>

<p>In order to run your Elm code, go to your shell, <code>cd</code> into your project directory, and type:</p>

<p><code>
$ elm reactor
</code></p>

<p>This will serve up your project directory at <code>http://localhost:8000</code> by default.</p>

<p><img src="http://i.imgur.com/yE93W9g.png" alt="screenshot of elm reactor" /></p>

<p>You will be able to see the project files listed.  There are two links for each Elm program.  Unfortunately, the debug mode link is pretty subtle, looked over by me as just a bullet in the UI.</p>

<ol>
<li>Click the file name, get the run mode</li>
<li>Click the wrench to the left of the file name, get the debug mode</li>
</ol>


<p>Alternately, type your own <code>?debug</code> at the end of any Reactor url to enter debug mode for that file.</p>

<p>Once in debug mode, you should see your code in action in the browser as usual, now with a sidebar for the debugger overlayed on your UI.</p>

<h2>Setting up Watches</h2>

<p>Poor man's debugging has traditionally been logging. When variables are in scope, interrogate them and print the value on the screen.  Elm's debugging story feels about like that, with some cool bells and whistles around it -- like <em>time-traveling</em> debugging, oh my.</p>

<p>In time-travel mode, your debug method of choice will probably be <code>Debug.watch</code>.  In the <a href="http://package.elm-lang.org/packages/elm-lang/core/2.0.1/Debug#watch">docs</a>, it is shown to take 2 arguments:</p>

<p><code>
watch : String -&gt; a -&gt; a
</code></p>

<p>The first argument is the label for the watched data in the debugger.  The second argument is the actual data value.  If I wanted to watch a dimensions tuple, I could write:</p>

<p><code>
Debug.watch "myDimensions" (w, h)
</code></p>

<p>Also note that you have to make your debug expression compile wherever you end up writing it.  I find that the easiest place to put a debug statement into my already-working code is in a <code>let</code> expression.  (Well, "already-working" is used loosely here -- we're debugging after all.)</p>

<p><code>
let
  log = Debug.watch "myDimensions" (w, h)
in
  doStuff myDimensions
</code></p>

<p>Now the watched value will show up in the debugger sidebar.</p>

<p><img src="http://i.imgur.com/PlI83Kq.png" alt="screenshot of elm watched code" /></p>

<p>If you pause the debugger and step backward, you can see the value as it has changed over time.  It's pretty neat, and now you're debugging Elm on your own box!</p>

<p>What other Elm debug tips do you have?</p>
]]></content>
  </entry>
  
</feed>
