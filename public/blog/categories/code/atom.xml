<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-02-25T19:40:01-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sinon Spies vs. Stubs]]></title>
    <link href="http://jaketrent.com/post/sinon-spies-vs-stubs/"/>
    <updated>2015-02-25T07:35:00-07:00</updated>
    <id>http://jaketrent.com/post/sinon-spies-vs-stubs</id>
    <content type="html"><![CDATA[<p><a href="http://sinonjs.org/">Sinon</a> provides spies, stubs, and mocks.  They're all useful as fakes in tests.  They come with essential differences for what they're helpful in doing and how they work.</p>

<p><img src="http://i.imgur.com/yuKcrP9.jpg" alt="spies vs stubs" /></p>

<!--more-->


<h2>Why Use Fakes?</h2>

<p>In a unit test, you might want to avoid having to test the unit's dependencies.  This is especially true in <a href="http://en.wikipedia.org/wiki/White-box_testing">white-box testing</a>.  In this case, test fakes are going to be very helpful.  Sinon provides several fakes, notably spies, stubs, and mocks.  Let's compare and contrast the three:</p>

<h2>Sinon Spies</h2>

<p>Spies sound like what they do -- they watch your functions and report back on how they are called.  They generally avoid the violence and mayhem of a Hollywood spy, but depending on your application, this could vary.</p>

<p>They don't change the functionality of your application.  They simply report what they see.  The <a href="http://sinonjs.org/docs/#spies-api">sinon API for spies</a> is fairly large, but it essentially centers around the <code>called</code> attribute (of which there are many variations).</p>

<p>I first setup that I want to spy on something.  Then I call my subject under test (src code).  Then I verify with the spy what was actually called and stop spying.  That might look like this in a test:</p>

<p>```js
describe("#fight", function () {
  it("calls prayForStrength for fight success", function () {</p>

<pre><code>sinon.spy(subject.strengthDep, "prayForStrength");
subject.fight();
subject.strengthDep.called.should.be.true;
subject.strengthDep.restore();
</code></pre>

<p>  });
});
```</p>

<p><em>Note: this example is in <a href="http://mochajs.org/">mocha</a> using a <a href="https://www.npmjs.com/package/should">should.js</a> assertion style</em></p>

<p>The dependency's <code>prayForStrength</code> method is referred to by name in a string to setup the spy.  When <code>fight</code> is called here, <code>strengthDep.prayForStrength</code> will be called as normal -- but there will be someone watching.  Finally, we call <code>restore</code> on the function we spied on so that all spies are called off.  If you want to do more than watch as dependencies work as described, you might want to use a stub.</p>

<h2>Sinon Stubs</h2>

<p>Stubs are more hands-on than spies (though they sound more useless, don't they).  With a stub, you will actually change how functions are called in your test.  You don't want to change the subject under test, thus changing the accuracy of your test.  But you may want to test several ways that dependencies of your unit could be expected to act.</p>

<p>For instance, if you had a function that returned a boolean that your code used to do different things, you might want to use a stub in two different tests to verify conditions when returning different values (ie, guarantee one run of <code>true</code> and one of <code>false</code> return).</p>

<p>To continue the <code>fight</code> example from above, let's assume that if <code>prayForStrength</code> returns true, we are guaranteed to win the fight for the orphans (ie, <code>fight()</code> should return <code>true</code>).  That might look like this:</p>

<p>```js
describe("#fight", function () {
  it("always wins when prayForStrength is true", function () {</p>

<pre><code>sinon.stub(subject.strengthDep, "prayForStrength", function () { return true; });
subject.fight().should.be.true;
subject.strengthDep.restore();
</code></pre>

<p>  });
});
```</p>

<p>Notice that we use a different <code>sinon.stub</code> API.  For the 3rd parameter, we're supplying our own version of <code>prayForStrength</code>.  For our test, all we care about is the return value, so that's all we supply.  We're not testing this dependency.  We're instead testing how our subject <code>fight</code>s in a certain circumstance.  There are many ways you can use <a href="http://sinonjs.org/docs/#stubs">sinon stubs</a> to control how functions are called.  Also note that you can still use the <code>called</code> verifications with stubs.  But if you do verify a stub was called, you may want to use a mock.</p>

<h2>Sinon Mocks</h2>

<p><a href="http://sinonjs.org/docs/#mocks">Mocks</a> take the attributes of spies and stubs, smashes them together and changes the style a bit.  A mock will both observe the calling of functions and verify that they were called in some specific way.  And all this setup happens <em>previous</em> to calling your subject under test.  After the call, mocks are simply asked if all went to plan.</p>

<p>So the previous test could be rewritten to use a mock:</p>

<p>```js
describe("#fight", function () {
  it("always wins when prayForStrength is true", function () {</p>

<pre><code>var mock = sinon.mock(subject.strengthDep)
mock.expects("prayForStrength").returns(true);
subject.fight().should.be.true;
mock.verify();
mock.restore();
</code></pre>

<p>  });
});
```</p>

<p>The <code>expects</code> and <code>returns</code> line is where the combo magic happens.  <code>expects</code> is verifying a call (like <code>spies</code> can), and <code>returns</code> is specifying functionality (like <code>stubs</code> can).  The <code>verify</code> call is the line that will fail (essentially the mock assertion) if things in the subject didn't go exactly according to plan.</p>

<h2>Spies vs. Stubs vs. Mocks</h2>

<p>So when should I use spies or stubs or mocks?  As with most art, there are many ways to accomplish what you want.  Much of your choice will depend on your own style and what you become proficient in.</p>

<p>Some basic rules might be:</p>

<ul>
<li><strong><em>Use Spies</em></strong> - if you simply want to watch and verify somethings happens in your test case.</li>
<li><strong><em>Use Stubs</em></strong> - if you simply want to specify how something will work to help your test case.</li>
<li><strong><em>Use Mocks</em></strong> - if you want to both of the above on a single dependency in your test case.</li>
</ul>


<p>When do you find yourself most often using spies vs. stubs vs. mocks?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby CLI Options Parsing]]></title>
    <link href="http://jaketrent.com/post/ruby-cli-options-parsing/"/>
    <updated>2015-02-24T07:21:00-07:00</updated>
    <id>http://jaketrent.com/post/ruby-cli-options-parsing</id>
    <content type="html"><![CDATA[<p>Ruby's stdlib never ceases to amaze.  If you're making a CLI tool in Ruby, your efforts are made more straightforward by the existence of the <a href="http://ruby-doc.org/stdlib-2.2.0/libdoc/optparse/rdoc/OptionParser.html">OptionParser</a> class.  Use it, and let happiness fill your heart.</p>

<p><img src="http://i.imgur.com/Z7WWtL0.jpg" alt="Ruby" /></p>

<!--more-->


<p>We're used to some nice CLI tools these days -- ones that have many useful options that allow for easier scripting and more powerful, quick usage.  Ruby's <code>OptionParser</code> will help us make our own and not disappoint the masses of fevered CLI users.</p>

<p>All terminal input from initial execution will enter our Ruby program via the <code>ARGV</code> variable.</p>

<p>To have the <code>OptionParser</code> class available to us, we must require the <code>optsparse</code> package.</p>

<p><code>OptionParser</code> options are defined similar to how you'd expect event handlers to be defined: with the <code>on</code> keyword.  You can pass it a string to match a short option, a string to match the verbose option, and finally a block to be executed when the option is detected.  In the block, we generally will want to store the option state.  We'll choose to use an <code>OpenStruct</code> for that (and will need the <code>ostruct</code> package).</p>

<p>For example:</p>

<p>```ruby
require "optsparse"
require "ostruct"</p>

<p>options = OpenStruct.new
opt_parser = OptionParser.new do |opts|</p>

<pre><code>opts.banner = "Usage: luchador [options]"
opts.separator ""
opts.separator "Options:"

opts.on("-t, "--twist", "Apply the nipple twist") do |t|
  options.twist = true
end

opts.on("-a a", "--anaconda-squeeze a", "The degrees of anaconda squeeze pressure") do |a|
  options.anaconda_squeeze = a
end

opt_parser.parse!(ARGV)
options
</code></pre>

<p>end
```</p>

<p>Now we can we might run CLI tool something like this:</p>

<p><code>
luchador -t --anaconda-squeeze 130
</code></p>

<p>And run with both options engaged for ultimate luchador power.  Notice we used both short and verbose-style options (choosing to write out the longest of the options for its added poetic punch on that whopping 130 degrees of pure squeeze pressure!).</p>

<p>A few more points to note:</p>

<ul>
<li><code>opts.banner</code> and <code>opts.separator</code> can be used to format usage information.</li>
<li>Usage information, stored in <code>opts</code> can be <code>put</code> to the screen.  A <code>-h</code>/<code>--help</code> option is automatically built in for this purpose.</li>
<li>Remember to call <code>parse!</code> after configuring the options so the input is actually processed.</li>
<li>Here, the <code>--anaconda-squeeze</code> option is defined differently than the first: there is a trailing <code>a</code>.  For options that require a non-boolean, this is required.  Otherwise, the argument to your handling block will always be a boolean <code>true</code>.</li>
<li>Note that this example code only shows option parsing -- nothing about the <code>luchador</code> binary itself.</li>
</ul>


<p>This gives you the basic tools.  It's very easy, and it's built in!  To do more, you might take required options first through the CLI options and then read them interactively from the console.  What other neat additions do you see that we could add?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test React-Router Previous Params for Component Update]]></title>
    <link href="http://jaketrent.com/post/test-react-router-params-component-update/"/>
    <updated>2015-02-09T15:39:00-07:00</updated>
    <id>http://jaketrent.com/post/test-react-router-params-component-update</id>
    <content type="html"><![CDATA[<p>Once upon a time, react-router transferred params and query params from the url via props into components.  It doesn't happen this way any more.  So, let's say you have a need in your component like overriding <code>shouldComponentUpdate</code> in your component which only has access to <code>this.props</code> and <code>this.state</code>.   How can you use the url data to affect the component re-render or not?</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react" /></p>

<!--more-->


<h2>Why control rendering with the url?</h2>

<p>There are two instances that come to mind when considering the scenarios that it might be needful to control the update of your component based on the url:</p>

<ol>
<li><p><strong>Avoid re-render</strong>: Of course, if the component we're talking about is a page-level component, you'll most likely always be wanting to re-render as the url changes.  But, if you're a little widget component that cares about the url, you might not need to always re-render on url change.</p></li>
<li><p><strong>Trigger re-render when it might not otherwise happen</strong>: For whatever reason, you may have already needed to implement <code>shouldComponentUpdate</code> in your component.  This function returns true or false to flag a "should" or "should not" re-render.  You'll need to access url state and likely previous url state in this method to make re-renders happen that otherwise wouldn't if you had no logic in this function for it.</p></li>
</ol>


<p>Of course, beyond these re-render scenarios, there are many other situations in which knowing previous and current states in the url could come in handy.</p>

<h2>React-Router in shouldComponentUpdate</h2>

<p><code>shouldComponentUpdate</code> determines if component should re-render.  It's called whenever <code>this.props</code> or <code>this.state</code> changes.  It has access to incoming props and state via the function parameters.</p>

<p>React-router gives your component access to params and query params by requiring you to mix in the <code>State</code> param from react-router.  Then you have access to new functions, <code>this.getParams()</code> and <code>this.getQuery()</code>.  If you only need to know current url state, this is enough.  If you want to compare current url state to previous url state, you'll have to save the parts that you care about.  We'll do that in <code>this.state</code>.</p>

<p>Let's say that we want to trigger a redraw on changes to a <code>range</code> query parameter.  The component might, in part, look like this:</p>

<p>```
var { State } = require('react-router')</p>

<p>module.exports = React.createClass({</p>

<p>  mixins: [ State ],</p>

<p>  getInitialState() {</p>

<pre><code>range: nul
</code></pre>

<p>  },</p>

<p>  componentWillReceiveProps() {</p>

<pre><code>this.setState({
  range: this.getQuery().range
})
</code></pre>

<p>  },</p>

<p>  componentWillMount() {</p>

<pre><code>this.setState({
  range: this.getQuery().range
})
</code></pre>

<p>  }</p>

<p>  shouldComponentUpdate() {</p>

<pre><code>return this.state.range !== nextState.range
</code></pre>

<p>  }</p>

<p>  // ...</p>

<p>})
```</p>

<p>When the url params change, <code>componentWillReceiveProps</code> is called.  But this is not called on the first render, thus we implement <code>componentWillMount</code>.  Both these functions save the <code>range</code> from the url to the component state.  Now, as <code>shouldComponentUpdate</code> is called on future <code>this.props</code> and <code>this.state</code> changes, current and next <code>range</code> values can be compared and used in "should re-render" calculation.</p>

<p>What other ways have you found to accomplish this tracking of previous state in the url?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set Cookie on Rack Mock Request]]></title>
    <link href="http://jaketrent.com/post/set-cookie-on-rack-mock-request/"/>
    <updated>2015-01-21T10:58:00-07:00</updated>
    <id>http://jaketrent.com/post/set-cookie-on-rack-mock-request</id>
    <content type="html"><![CDATA[<p>Rack apps are generally straightforward to test because of their very basic public interface.  But where do we put specific things, in this case, a cookie for the request, on that <code>env</code> argument it takes?  Here's one way.</p>

<p><img src="http://i.imgur.com/044x6s6.jpg" alt="rack mock request" /></p>

<!--more-->


<h1>env</h1>

<p>The <code>env</code> argument that is sent to <code>#call</code> in a Rack app is an variable that represents the <a href="http://www.rubydoc.info/github/rack/rack/master/file/SPEC#The_Environment">environment of the request</a>.  It is a hash of CGI-like headers: request method, query params, http headers -- that sort of thing.</p>

<p>The <code>HTTP_*</code> keys on the hash will be <a href="https://tools.ietf.org/html/rfc3875#section-4.1.18">read as request headers from the environment</a>.</p>

<h1>Rack MockRequest Cookies</h1>

<p>Rack provides a great little <code>Rack::MockRequest</code> helper object in its library that will help us test our app.  This object has a class method called <code>env_for</code> which allows for quick construction of an <code>env</code> var that is a request to a specified url.</p>

<p>On the returned <code>env</code> we will continue to make modifications before passing it to our Rack app.  We'll add our cookie header with a key of <code>HTTP_COOKIE</code>.  The value will be of the format <code>cookieName=cookieValue</code>.  We can handle multiple cookies by separating the cookies with <code>;</code>.</p>

<p>Let's say we're testing a token authentication middleware with rspec.  Our spec may look something like this:</p>

<p><code>ruby
it "accepts an cookie token in the request" do
  middleware = # ... instantiate rack middleware
  env = Rack::MockRequest.env_for("/protected")
  env["HTTP_COOKIE"] = "AUTH_COOKIE=123"
  status, _, _ = middleware.call(env)
  expect(status).to eq(200)
end
</code></p>

<p>Then in our Rack app source, we can code for the availability of a cookie on the request.  It might look like:</p>

<p>```ruby</p>

<h1>...</h1>

<p>def call(env)
  request = Rack::Request.new(env)
  token = request.cookies["AUTH_TOKEN"]
  # ...
end
```</p>

<p>Is this the easiest or best way to set cookies on requests when testing Rack apps?  What do you do?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pagination Headers with Kaminari]]></title>
    <link href="http://jaketrent.com/post/pagination-headers-with-kaminari/"/>
    <updated>2015-01-15T14:07:00-07:00</updated>
    <id>http://jaketrent.com/post/pagination-headers-with-kaminari</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/amatsuda/kaminari">Kaminari</a> provides easy pagination in a rails app.  It's great to use.  We'll make it better by adding a little function to your controllers to provide useful pagination headers.</p>

<p><img src="http://i.imgur.com/XOUecnw.jpg" alt="kaminari pagination" /></p>

<!--more-->


<h2>Pagination from Kaminari</h2>

<p>Installation is easy with an addition to your <code>Gemfile</code>:</p>

<p><code>
gem 'kaminari'
</code></p>

<p>and an install:</p>

<p><code>
bundle install
</code></p>

<p>Now, you have a magical <code>page</code> method available on your models.  It works like a charm right out of the box.</p>

<p>Let's say that I have a <code>germs_controller.rb</code> (because it's a great time of year for that), where I have a list of germs that I want to paginate.  I could easily request <code>/api/v1/germs?page=2</code> and get the second page with this code in the controller:</p>

<p>```ruby germs_controller.rb
module Api
  module V1</p>

<pre><code>class GermsController &lt; ApplicationController
  def index
    @germs = Germ.page params[:page]
    render json: @germs
  end
end
</code></pre>

<p>  end
end
```</p>

<p>If you want to control the default page size, you can do that in the initializers:</p>

<p><code>ruby kaminari_config.rb
Kaminari.configure do |config|
  config.default_per_page = 20
end
</code></p>

<h2>Pagination Headers</h2>

<p>There's another feature that we want to add, and that's pagination headers.  These are going to be HTTP headers that come back in the response that indicate to clients where the relative pages are located in our API.  For instance, we asked for page 2, but where might one request the previous and next pages, 1 and 3?</p>

<p>Putting the pagination info into the header follows a pattern used in the <a href="https://developer.github.com/guides/traversing-with-pagination/">github api</a>.</p>

<p>We'll add a function to our <code>ApplicationController</code> to helps us out:</p>

<p>```ruby application_controller.rb
class ApplicationController &lt; ActionController::API</p>

<p>  protected</p>

<p>  def set_pagination_header(name, options = {})</p>

<pre><code>scope = instance_variable_get("@#{name}")
request_params = request.query_parameters
url_without_params = request.original_url.slice(0..(request.original_url.index("?")-1)) unless request_params.empty?
url_without_params ||= request.original_url

page = {}
page[:first] = 1 if scope.total_pages &gt; 1 &amp;&amp; !scope.first_page?
page[:last] = scope.total_pages  if scope.total_pages &gt; 1 &amp;&amp; !scope.last_page?
page[:next] = scope.current_page + 1 unless scope.last_page?
page[:prev] = scope.current_page - 1 unless scope.first_page?

pagination_links = []
page.each do |k, v|
  new_request_hash= request_params.merge({:page =&gt; v})
  pagination_links &lt;&lt; "&lt;#{url_without_params}?#{new_request_hash.to_param}&gt;; rel=\"#{k}\""
end
headers["Link"] = pagination_links.join(", ")
</code></pre>

<p>  end
end
```</p>

<p>This code will provide a <code>Link</code> header in the HTTP response.  Its value might look something like this:</p>

<p><code>text Link
&lt;http://myapi.com/api/v1/germs?page=1&gt;; rel="prev", &lt;http://myapi.com/api/v1/germs?page=3&gt;; rel="next"
</code></p>

<p>The values of <code>first</code>, <code>last</code>, <code>next</code>, etc are populated from calls to <a href="http://www.rubydoc.info/github/amatsuda/kaminari/Kaminari/PageScopeMethods">Kaminari methods</a> such as <code>first_page?</code>.</p>

<p>In order to have this header set on a response, we need to add it to a callback in our controller:</p>

<p>```ruby germs_controller.rb
module Api
  module V1</p>

<pre><code>class GermsController &lt; ApplicationController

  after_filter only: [:index] { set_pagination_header(:germs) }

  def index
    @germs = Germ.page params[:page]
    render json: @germs
  end

end
</code></pre>

<p>  end
end
```</p>

<p>Now, a fresh request to <code>/api/v1/germs</code> with or without the <code>page</code> query parameter should return back the <code>Link</code> header in the HTTP response which your client can use to traverse the other pages of data available in your API.</p>

<p>So, there's one way to get pagination info from Kaminari into your HTTP headers.  What would you improve?</p>
]]></content>
  </entry>
  
</feed>
