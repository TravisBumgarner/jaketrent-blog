<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-01-25T14:37:00-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Test APIs Failing from Client]]></title>
    <link href="http://jaketrent.com/post/test-apis-failing-from-client/"/>
    <updated>2016-01-25T13:54:00-07:00</updated>
    <id>http://jaketrent.com/post/test-apis-failing-from-client</id>
    <content type="html"><![CDATA[<p>In the case where you can't edit a local version of your APIs in order to cause them to fail, you need to be able to edit your client so that it <em>looks</em> like the API request fails.  Here's a quick code change that should make this easy for you.</p>

<p><img src="http://i.imgur.com/8Fm1cn2.jpg" alt="We have a problem" /></p>

<!--more-->


<p>This is one of many possible manual testing techniques.  This allow you to see the change in your running app as you work through it.  For instance, I like to use this as I'm testing through the error alerting features that are common in an app when an API request fails.</p>

<p>Go to the point in your app where your bits touch the network.  This is usually the place where you use your HTTP wrapper or, if you're a free spirit, call some XHR goodness yourself.  These days, I like using the venerable <a href="https://github.com/mzabriskie/axios">axios</a> library.  Axios is promise based, so that means that we can use async/await as well, which is like a fine chocolate next to a warm fire in winter (which is good).</p>

<p>So, all my http code might look in essence like this:</p>

<p>```js api.js
import axios from 'axios'</p>

<p>export const fetch = {
  // deserialize, etc ...
  request(url) {</p>

<pre><code>return axios({
  method: 'get',
  url
})
</code></pre>

<p>  }
}
```</p>

<p>So, this <code>request</code> function returns a Promise.  The logic around the request might look like:</p>

<p>```js actions.js
import * as api from './api'</p>

<p>async function fetchWater() {
  const { request} = api.fetch</p>

<p>  try {</p>

<pre><code>const res = await request('/my/own/home')
// ... handle success response
</code></pre>

<p>  } catch (res) {</p>

<pre><code>// ... handle error response, where failure code should execute (what we want to TEST!)
</code></pre>

<p>  }
}
```</p>

<p>To make this request fail, we need only make the Promise fail, rejecting it like a mouthful of stewed tomatoes.  So, just change <code>api.js</code>:</p>

<p>```js api.js
import axios from 'axios'</p>

<p>export const fetch = {
  // ...
  request(url) {</p>

<pre><code>return Promise((resolve, reject) =&gt; {
  reject({
    status: 500,
    data: {
      errors: [{ detail: 'Shere Khan is back!' }]
    }
  })
})
</code></pre>

<p>  }
}
```</p>

<p>Now note that you must be aware of what your format HTTP library, in this case axios, uses in its responses.  What you <code>reject</code> manually must be exactly the same format that usually is returned in an error situation (eg, <code>status</code> and <code>data</code>).  You must also know what your server is designed to return as an error response (eg, <code>errors</code>).  The above application code is using the <a href="http://jsonapi.org/format/#error-objects">JSON API</a> format.</p>

<p>What other little tricks do you find useful in getting APIs to fail?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What React Stateless Components are Missing]]></title>
    <link href="http://jaketrent.com/post/react-stateless-components-missing/"/>
    <updated>2016-01-04T12:59:00-07:00</updated>
    <id>http://jaketrent.com/post/react-stateless-components-missing</id>
    <content type="html"><![CDATA[<p>Stateless React components got a new syntax in React 0.14.  It's much simpler.  It's just a function call.  Besides it just looking simpler, there are some major differences in what is available in a stateless component written this way.  There are some things missing -- purposefully not included -- that you may be used to.  Let's look at a few things.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="http://i.imgur.com/DXuSNbw.png" /></p>

<!--more-->


<p>Stateless components are now specifically not just components where you don't use <code>this.state</code>.  They're componets that are written in the form of a function:</p>

<p><code>js
function Chips(props) {
  return &lt;div&gt;In the secret {props.place}&lt;/div&gt;
}
</code></p>

<p>The observations made in this article will not apply to components that are created using the <code>class Chips extends React.Component</code> or <code>React.createClass</code> syntax, whether they use state or not.</p>

<h2>No Backing Instance</h2>

<p>A React component's backing instance is the object in memory that represents the node in the view.  This backing instance is the place where state is usually stored (using React's <code>this.state</code>).  Well now there's no <code>this</code> in stateless components.  Thus, there's not going to be a place for <code>this.state</code>.  Stateless, remember?  Data just passes through the pure function and into the resulting view.</p>

<h2>No Lifecycle Methods</h2>

<p>Because there's no backing instance as a place to put hooks for your code in the component lifecycle, you can not use any of the lifecycle methods from <code>React.Component</code>.  Methods such as <code>componentDidMount</code> and <code>componentWillReceiveProps</code> are out.  And since the stateless component is a pure function that just reproduces its view state on <code>props</code> change, why would you need lifecycle methods anyway?</p>

<h2>No Reference to the Component</h2>

<p>Often when testing, it's useful to get a reference to the component itself.  In the case of stateless components, they're just fired and forgotten, rendered into the view without the ability to get a handle on them.  They're just UI at this point, just in the DOM.  You can go to the DOM to do your testing.</p>

<p>Depending on your test environment setup, you may want to wrap your stateless components in a <code>class</code>-based component you <em>can</em> get a reference to.</p>

<p>Note that for stateless components, <code>ReactDOM.render</code> and <code>TestUtils.renderIntoDocument</code> will return <code>null</code>.</p>

<h2>No refs</h2>

<p>Stateless components can't be the target of a <code>ref</code>.  There's no backing instance.  You can't have <code>refs</code> internally to children either.  Remember, <code>this</code> and <code>this.refs</code> aren't around.  If your stateless component has a child that is a <code>class</code>-based component, <em>it</em> may have <code>refs</code>.  <a href="https://facebook.github.io/react/docs/more-about-refs.html">The docs</a> are another good reference on <code>refs</code>.</p>

<h2>No null Returns</h2>

<p>A <code>class</code>-based component may return <code>null</code> as its value in the view.  But a stateless component may not.  To get around this, return <code>&lt;noscript&gt;&lt;/noscript&gt;</code>.  This will be fully invisible in the view.</p>

<p>So what else have you found that is unavailable in stateless functions?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debug Locally in Elm]]></title>
    <link href="http://jaketrent.com/post/debug-locally-elm/"/>
    <updated>2015-11-28T14:39:00-07:00</updated>
    <id>http://jaketrent.com/post/debug-locally-elm</id>
    <content type="html"><![CDATA[<p>Debugging in Elm is easy once you know where to look.  You need an in-browser tool to help you.  It's almost as simple as just calling <code>console.log</code>, but you can't just put your logging statement anywhere.</p>

<p><img src="http://i.imgur.com/1c6FH0f.png" alt="elm debug locally" /></p>

<!--more-->


<h2>The Online Option</h2>

<p>There's a debugger available online as a part of the elm-lang site at <a href="http://debug.elm-lang.org/">debug.elm-lang.org</a>.  This page explains the principles behind why the debugger works and has the properties it does.  The <a href="http://debug.elm-lang.org/try">debugger is found</a> via clicking the "Debug" button in the top-right corner.</p>

<p>But you don't want to paste your code into the Try Elm page in order to walk through your Elm code.  You need a local option.</p>

<h2>Debugging Locally</h2>

<p>Thankfully you already have the tools to debug locally after you've <a href="http://elm-lang.org/install">installed Elm</a> on your machine.   It comes with <code>elm-reactor</code>.</p>

<p>In order to run your Elm code, go to your shell, <code>cd</code> into your project directory, and type:</p>

<p><code>
$ elm reactor
</code></p>

<p>This will serve up your project directory at <code>http://localhost:8000</code> by default.</p>

<p><img src="http://i.imgur.com/yE93W9g.png" alt="screenshot of elm reactor" /></p>

<p>You will be able to see the project files listed.  There are two links for each Elm program.  Unfortunately, the debug mode link is pretty subtle, looked over by me as just a bullet in the UI.</p>

<ol>
<li>Click the file name, get the run mode</li>
<li>Click the wrench to the left of the file name, get the debug mode</li>
</ol>


<p>Alternately, type your own <code>?debug</code> at the end of any Reactor url to enter debug mode for that file.</p>

<p>Once in debug mode, you should see your code in action in the browser as usual, now with a sidebar for the debugger overlayed on your UI.</p>

<h2>Setting up Watches</h2>

<p>Poor man's debugging has traditionally been logging. When variables are in scope, interrogate them and print the value on the screen.  Elm's debugging story feels about like that, with some cool bells and whistles around it -- like <em>time-traveling</em> debugging, oh my.</p>

<p>In time-travel mode, your debug method of choice will probably be <code>Debug.watch</code>.  In the <a href="http://package.elm-lang.org/packages/elm-lang/core/2.0.1/Debug#watch">docs</a>, it is shown to take 2 arguments:</p>

<p><code>
watch : String -&gt; a -&gt; a
</code></p>

<p>The first argument is the label for the watched data in the debugger.  The second argument is the actual data value.  If I wanted to watch a dimensions tuple, I could write:</p>

<p><code>
Debug.watch "myDimensions" (w, h)
</code></p>

<p>Also note that you have to make your debug expression compile wherever you end up writing it.  I find that the easiest place to put a debug statement into my already-working code is in a <code>let</code> expression.  (Well, "already-working" is used loosely here -- we're debugging after all.)</p>

<p><code>
let
  log = Debug.watch "myDimensions" (w, h)
in
  doStuff myDimensions
</code></p>

<p>Now the watched value will show up in the debugger sidebar.</p>

<p><img src="http://i.imgur.com/PlI83Kq.png" alt="screenshot of elm watched code" /></p>

<p>If you pause the debugger and step backward, you can see the value as it has changed over time.  It's pretty neat, and now you're debugging Elm on your own box!</p>

<p>What other Elm debug tips do you have?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Update Body Class in React]]></title>
    <link href="http://jaketrent.com/post/update-body-class-react/"/>
    <updated>2015-09-23T15:31:00-06:00</updated>
    <id>http://jaketrent.com/post/update-body-class-react</id>
    <content type="html"><![CDATA[<p>React gives us a great component abstraction.  Each of these components represents a node in the DOM.  Each component is self contained, doesn't talk up the component hierarchy directly and passes explicit data and code down the hierarchy.  But what about when you have a React app that wants to reach out and modify something it doesn't control?</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react modify body tag" /></p>

<!--more-->


<h2>A Couple Use Cases</h2>

<p>There are potentially a few use cases for this.  For instance, modals that need to render outside your application's potentially <code>position: relative</code> containers.  Or, as we'll see below, your app wants to modify the <code>body</code> tag in your html document.</p>

<p>The most common reason I've found for messing with the body tag is to provide some style attribute.  It's not uncommon to have full-page style differences between pages in our apps.  If you have a "single page" js app in the browser, you need to be able to modify the body tag in code.</p>

<p>Let's use an example where on some pages in your app, the theme is "dark", where the body background color should be black.  On other pages, the entire body background color should be the default white.  We'll make a component that lives high in the hierarchy and takes an <code>isDark</code> property to determine if the rendered page is dark or light.</p>

<h2>Body is Outside Your React App</h2>

<p>You can't mount your React app directly on <code>document.body</code>, at least without warnings.  This is considered bad practice, because other scripts or browser plugins often modify the document body directly.  So you'll have to reach <em>out</em> of your React app and modify the body directly.</p>

<h2>Tie Into the React Lifecycle</h2>

<p>First, you just need a point in time in your app's lifecycle where you know you want to modify the <code>body</code> class.  React has a bunch of <a href="https://facebook.github.io/react/docs/component-specs.html">lifecycle hooks</a> that will come in handy.  A great early-lifecycle hook for modifying the DOM is <code>componentDidMount</code>.  Usually, we would be accessing DOM nodes that are children of our Component.  Again, in this case, we're reaching out beyond where a React component usually should.  The usual <code>React.findDOMNode</code> functions will not be needed, because React isn't managing the body node.  Instead, we'll just use the <code>document.body</code> api directly.</p>

<h2>Use JavaScript to Modify the Class</h2>

<p>If you have some utility for modifying class names, use it.  If not, it's small and simple enough in <a href="http://jaketrent.com/post/addremove-classes-raw-javascript/">plain old JavaScript</a>.</p>

<p>With these two bits in hand, you have the pieces necessary for your body-modifying component:</p>

<p>```js
import React from 'react'</p>

<p>class BodyColor extends React.Component {
  static propTypes = {</p>

<pre><code>isDark: React.PropTypes.bool
</code></pre>

<p>  }
  static defaultProps = {</p>

<pre><code>isDark: false
</code></pre>

<p>  }
  componentDidMount() {</p>

<pre><code>document.body.toggle('darkClass', this.props.isDark)
</code></pre>

<p>  }
  componentWillReceiveProps(nextProps) {</p>

<pre><code>document.body.toggle('darkClass', nextProps.isDark)
</code></pre>

<p>  }
  componentWillUnmount() {</p>

<pre><code>document.body.remove('darkClass')
</code></pre>

<p>  }
  render() {</p>

<pre><code>return this.props.children
</code></pre>

<p>  }
}
```</p>

<p>To use, pass an <code>isDark</code> attribute to activate the <code>darkClass</code> class on the body tag:</p>

<p><code>html
&lt;BodyColor isDark={true}&gt;
  &lt;h1&gt;A Very Dark App&lt;/h1&gt;
&lt;/BodyColor&gt;
</code></p>

<p>Are there any other ways you've found to reach out of React and modify the DOM directly.  What have been your use cases?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I Love CSS Modules]]></title>
    <link href="http://jaketrent.com/post/i-love-css-modules/"/>
    <updated>2015-08-25T11:03:00-06:00</updated>
    <id>http://jaketrent.com/post/i-love-css-modules</id>
    <content type="html"><![CDATA[<p>I heard a fantastic yesterday by <a href="https://twitter.com/glenmaddern">Glen Maddern</a> where Interoperable CSS was well-illustrated as the fantastic CSS language advancement that it is.  I was happy to hear hushed ooo's and ahh's from the audience as they realized the power of what they were seeing.  I have been enjoying the benefits of CSS modules myself and my team and would share some of my favorite features in hopes that others will be inclined to use this feature as well.  Cleanse the world of global stylesheets!</p>

<p><img src="http://i.imgur.com/MtjAduk.jpg" alt="i love css modules" /></p>

<!--more-->


<h2>Local Variables</h2>

<p>With CSS modules, your selector names are truly local.  They are FRD local variables!  They won't clash with any var names outside your module.  For You don't have to invent a giant namespace.  There's no BEM-style naming to describe a hierarchy.  There's no repetition in those names.  You can name it something much more simple, just related to what the component is.</p>

<p>For instance, if you're creating <code>Link</code> component, you'd previously have something like <code>.nav__item__link</code> selectors to apply style.  Knowledge of global markup structure would seep into your component through this selector and its name.  Now with a combination of encapsulated components and css modules,  you don't have to worry about the outside world.</p>

<p>Now, what would you call your <code>Link</code> component's outer-most <code>a</code> tag?  Well, maybe <code>.link</code> or <code>.root</code>...  Nothing fancy.  Just what it is.  You aren't required to think about the global stylesheet.  You can focus your mind on just the component stylesheet at hand.  The naming game, which can already be challenging, is made much easier.</p>

<h2>Explicit Dependencies</h2>

<p>Now that all the CSS you write is, by default, local to the module you write it in, you have to explicitly pull in dependencies.  You have to explicitly import the stylesheet you are writing where you'll eventually want to use it.  You can write styles without fear that it might influence something else -- until you explicitly ask it to!</p>

<h2>Still CSS</h2>

<p>I've tried some of the inlining styling techniques and libraries that are being made popular in the React community.  <a href="https://github.com/FormidableLabs/radium">Radium</a> is my favorite there.  What makes me happy about CSS modules is that they're still CSS.  It's a language that was invented in order to create declarative styles.  It's not wonderful in many ways, but it's still the best tool available for this.</p>

<p>You can use all the selectors, strategies, and css abilities you're used to.  Pseudo selectors are all available.  Media queries work as expected.  Keyframe animations are easy to declare.  There is also a great ecosystem of CSS enhancements and transforms available from the PostCSS community.  No one should ever write a vendor prefix again with <a href="https://github.com/postcss/autoprefixer">autoprefixer</a>.</p>

<h2>Consistency for Components</h2>

<p>Another thing I'd like to see in the web component community, specifically React for now, is a pattern around how to override CSS in reusable components.  This pattern would be well-used by component developers and well-known by component consumers.  This would help components be more immediately useful -- default styles could be included with components and custom styles would be easily applied.</p>

<p>My favorite solution to this so far is <a href="https://github.com/pluralsight/react-styleable">react-styleable</a> -- full disclosure, I helped write it.  (Anything like this that gains steam, has broad appeal, and is used by many will make me happy.)  I love that CSS modules enable this and provide a foundation for this consistency.  I'll likely write more about this in the future.</p>

<p>CSS modules have changed the styling game for me.  It makes it so, so much better.  Who knows, maybe it'll change the world.</p>

<p>So, how have CSS modules changed your life?  What do you love?  What could still be better?</p>
]]></content>
  </entry>
  
</feed>
