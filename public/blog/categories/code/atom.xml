<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-12-15T09:53:49-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Debug.log in Elm Pipes]]></title>
    <link href="http://jaketrent.com/post/debug-log-in-elm-pipes/"/>
    <updated>2016-12-15T09:32:00-07:00</updated>
    <id>http://jaketrent.com/post/debug-log-in-elm-pipes</id>
    <content type="html"><![CDATA[<p>There aren't many functions in the standard lib for elm that create side effects.  Elm's <code>Debug.log</code> is one of those exceptions.  It logs to the console.  Here's how it's setup to make console logging whilst piping easier that patting your head whilst rubbing your tummy.</p>

<p><img src="http://i.imgur.com/1c6FH0f.png" alt="elm debug.log" /></p>

<!--more-->


<h2>The signature of Debug.log</h2>

<p>The coolest thing about <code>Debug.log</code> is its type signature:</p>

<p><code>
String -&gt; a -&gt; a
</code></p>

<p>The first parameter is <code>String</code> and traditionally takes some label to identify what you're printing in the log.</p>

<p>The 2nd parameter is <code>a</code>, meaning it can be generically anything.   It's worth noticing that <code>a</code> as the 2nd parameter is required.  This means you'll have to print a value there whether you want to or not.  Otherwise, you won't be fully applying the <code>Debug.log</code> function.</p>

<p>The <em>coolest</em> part is that <code>a</code> is also returned.  This helps with piping because you can just insert <code>Debug.log</code> in your pipe chain.</p>

<h2>Logging in Elm</h2>

<p>Here's a little example.  In this <code>encode</code> function there are several pipes.  There are two helper functions, <code>keyIndex</code> and <code>keyValue</code> that return values that I'd like to investigate.  After each of those values are returned in the pipe chain, a <code>Debug.log</code> is inserted next in the chain with the associated "indexes" or "values" label for log clarity.</p>

<p>```haskell
encode : String -> String
encode phrase =</p>

<pre><code>phrase
    |&gt; String.toLower
    |&gt; String.split ""
    |&gt; List.map (\l -&gt; l |&gt; keyIndex)
    |&gt; Debug.log "indexes"
    |&gt; List.map (\i -&gt; -1 * i)
    |&gt; List.map keyValue
    |&gt; Debug.log "values"
    |&gt; String.join ""
</code></pre>

<p>```</p>

<p>The resulting log for a test run of this code is:</p>

<p><code>
indexes: [24,4,18]
values: ["b","v","h"]
</code></p>

<p>This can be super nice when you're not in a live debug-ready environment.  What are some other ways to gain insight into your code for debugging that you use?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stub Dependencies in Node Without Proxyquire]]></title>
    <link href="http://jaketrent.com/post/stub-dependencies-node-without-proxyquire/"/>
    <updated>2016-09-29T06:30:00-06:00</updated>
    <id>http://jaketrent.com/post/stub-dependencies-node-without-proxyquire</id>
    <content type="html"><![CDATA[<p>When testing a unit, often you'll want to stub out that unit's dependencies.  Some libraries will help you do this.  But you can do it with plain JavaScript, and it works quite well.</p>

<p><img src="http://i.imgur.com/1arT8Ho.jpg" alt="nodejs testing" /></p>

<!--more-->


<h2>Stubbing Dependencies</h2>

<p>We're unit testing a module in Node.  That unit has dependencies on some other sub-unit.  For our example, these units are modules. The subject under test is <code>prep-for-fight.js</code>.  It has a dependency on <code>eat-corn.js</code>.  We want to eventually stub out <code>eat-corn.js</code> within our unit test for <code>prep-for-fight.js</code>.</p>

<p>```js prep-for-fight.js
const eatCorn = require('./eat-corn')
module.exports = function prepForFight() {
  const nutrients = eatCorn()
  if (nutrients > NUTRIENT_LEVELS.EAGLE_EMPOWERMENT)</p>

<pre><code>return { hasCape: donHomemadeCape() }
</code></pre>

<p>  // ...
}
```</p>

<p>A <a href="/post/sinon-spies-vs-stubs/">stub</a> is a testing fake that you create in place of the real thing.  While testing our module <code>prepForFight</code>, we'll stub out the sub-unit module <code>eatCorn</code>.  That module is tested elsewhere in another unit test.  We don't want to conflate the two tests, coupling them strongly together.  This is because if the sub-unit's implementation changes, we don't want to have to change our current unit's test.</p>

<p>The tradeoff is that we are going to couple our <code>prepForFight</code> unit test to the implementation of that module.  This is generally known as white box testing, where we care about the internal implementation of our source code within our tests.  If we did the opposite, and treated <code>prepForFight</code> as a black box and just tested its final output, there really is no need to stub anything or ever care about implementation as long as <code>prepForFight</code> continues to do its job.  For today's example, we'll choose to stub so that we can have a more isolated unit and focused test, drawing our unit boundaries strictly around code that exists in <code>prepForFight</code> proper.</p>

<h2>Stubbing Libraries</h2>

<p>There are libraries that help us stub.  Since we have a <code>require</code>d module for <code>eat-corn.js</code>, there is one in particular that would do well for us called <a href="https://github.com/thlorenz/proxyquire">proxyquire</a>.  It allows targeting the <code>./eat-corn.js</code> import path and replacing it with your own module at test runtime.  With a couple caveats, it usually works quite well.  We're going to <em>not</em> use it and see how we fare.</p>

<h2>Stub by Passing the Dependency</h2>

<p>An easy way to get a dependency into <code>prepForFight</code> is to pass it as a function argument.  The rewrite might look like this:</p>

<p>```js prep-for-fight.js
module.exports = function prepForFight(eatCorn) {
  const nutrients = eatCorn()
  if (nutrients > NUTRIENT_LEVELS.EAGLE_EMPOWERMENT)</p>

<pre><code>return { hasCape: donHomemadeCape() }
</code></pre>

<p>  // ...
}
```</p>

<p>Now we have no <code>require</code> statement, and <code>prepForFight</code> gets the dependency it needs.  Given this implementation, we can exercise our two code paths in our test:</p>

<p>```js prep-for-fight.spec.js
const test = require('ava') // or whatevs</p>

<p>const subject = require('./prep-for-fight')</p>

<p>test('many nutrients dons cape', t => {
  function eatCornStub() {</p>

<pre><code>return NUTRIENT_LEVELS.EAGLE_EMPOWERMENT + 1
</code></pre>

<p>  }
  t.truthy(subject(eatCornStub).hasCape)
})</p>

<p>test('fewer nutrients remains cape-less', t => {
  function eatCornStub() {</p>

<pre><code>return NUTRIENT_LEVELS.EAGLE_EMPOWERMENT - 1
</code></pre>

<p>  }
  t.falsy(subject(eatCornStub).hasCape)
})
```</p>

<p>By passing in our stub directly, we control the branching inside the function.</p>

<h2>Leaking Dependencies</h2>

<p>By exposing <code>eatCorn</code> as a function parameter, we're telling all consumers that we rely on <code>eatCorn</code>.  We've leaked our dependency, lessening our encapsulation.  For the function to work as written, it always needs the consumer to send it the <code>eatCorn</code> argument when <code>prepForFight</code> is called.  Let's give it a default, and make the consumer code care about our dependencies a bit less.  The default will be our original <code>require</code>d module.</p>

<p>```js prep-for-fight.js
const defaultEatCorn = require('./eat-corn')
module.exports = function prepForFight(eatCorn = defaultEatCorn) {
  const nutrients = eatCorn()
  if (nutrients > NUTRIENT_LEVELS.EAGLE_EMPOWERMENT)</p>

<pre><code>return { hasCape: donHomemadeCape() }
</code></pre>

<p>  // ...
}
```</p>

<p>Now if <code>eatCorn</code> is <em>passed</em> as an argument, it will be used.  Otherwise, <code>defaultEatCorn</code>, which is the normal imported dependency, will be used.  This is great because now consumers don't necessarily have to care about the dependency, except to override, which for now is just a thing our test wants to be able to do.</p>

<h2>Stub Without Changing Your Signature</h2>

<p>If putting <code>eatCorn</code> in your function parameter list bothers you, here's another potential solution.</p>

<p>```js prep-for-fight.js
const eatCorn = require('./eat-corn')
exports.prepForFight = function prepForFight() {
  const nutrients = eatCorn()
  if (nutrients > NUTRIENT_LEVELS.EAGLE_EMPOWERMENT)</p>

<pre><code>return { hasCape: donHomemadeCape() }
</code></pre>

<p>  // ...
}</p>

<p>exports.withEatCornForTest = function withEatCornForTest(eatCornOverride) {
  eatCorn = eatCornOverride
}
```</p>

<p>Now you can call <code>withEatCornForTest</code> before you exercise your subject under test:</p>

<p>```js prep-for-fight.spec.js
const test = require('ava')</p>

<p>const subject = require('./prep-for-fight')</p>

<p>test('many nutrients dons cape', t => {
  function eatCornStub() {</p>

<pre><code>return NUTRIENT_LEVELS.EAGLE_EMPOWERMENT + 1
</code></pre>

<p>  }
  subject.withEatCornForTest(eatCornStub)
  t.truthy(subject.prepForFight().hasCape)
})
```</p>

<p>This overrides the imported <code>eatCorn</code> module much like proxyquire does.  This is nice because your <code>prepForFight</code> function remains untouched, but I think there are a few drawbacks.</p>

<ul>
<li>We had to change our single export module to a multiple named export module in order to add the extra API for setting the dependency.</li>
<li>We have code in our src that is there specifically for testing.  The <code>*ForTest</code> suffix is a particularly clear flag of that.  But if we remove the <code>*ForTest</code> suffix, we simply cloud that fact and make something still test-specific look like it's for general use.</li>
<li>We have made our <code>prepForFight</code> function impure, because now its output can change depending on when or if we call the <code>withEatCornForTest</code>, creating a module-global side effect.</li>
<li><code>withEatCornForTest</code> is further away from the <code>eatCorn</code> usage inside of <code>prepForFight</code>.  Thus, we could read <code>prepForFight</code> and never know that it's possible for the <code>eatCorn</code> implementation to be switched out from under us without examination of more code outside that function.</li>
</ul>


<h2>Decouple Function Parameter Order</h2>

<p>Previous to reading Sandi Metz' <a href="http://www.poodr.com/">POODR</a> book, I hadn't considered this, but she posits that a parameter list has coupling because of the order of the parameters.  To lessen the coupling, she proposes changing the function signature to take an argument hash instead.  This has the benefits of not requiring a specific order, letting consumers name the arguments, creating clarity on the consuming side, and having the consistency of a single argument for most/if not all functions that take input.</p>

<p>We can take advantage of these attributes and realize one of our own in our <code>prepForFight</code> function.  If we have multiple dependencies, we can put these dependencies and their defaults inside the argument hash, and no consumer has to know anything about it.  There's no ordering problem.  There's no null arugment passing.  We just specify the keys that we care to specify and have defaults for the rest.  A minor refactor might yield some destructuring of a single object sent to the function:</p>

<p>```js prep-for-fight.js
const defaultEatCorn = require('./eat-corn')
module.exports = function prepForFight({ eatCorn = defaultEatCorn /<em>, more... </em>/ }) {
  const nutrients = eatCorn()
  if (nutrients > NUTRIENT_LEVELS.EAGLE_EMPOWERMENT)</p>

<pre><code>return { hasCape: donHomemadeCape() }
</code></pre>

<p>  // ...
}
```</p>

<p>I think that's probably our final refactor for now.  What could we do to make this better?  What are other stubbing methods that you've gotten a lot of mileage out of?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notify NewRelic of Error on UncaughtException]]></title>
    <link href="http://jaketrent.com/post/notify-error-to-newrelic-on-uncaughtexception/"/>
    <updated>2016-09-27T09:50:00-06:00</updated>
    <id>http://jaketrent.com/post/notify-error-to-newrelic-on-uncaughtexception</id>
    <content type="html"><![CDATA[<p>NewRelic is a monitoring vendor that has good support for Node.js apps.  When your Node app goes down, you'll want to tell NewRelic about it.  It's surprisingly easy.</p>

<p><img src="http://i.imgur.com/ApNvY7f.jpg" alt="newrelic" /></p>

<!--more-->


<h2><code>newrelic</code> npm Package</h2>

<p>The <code>newrelic</code> npm package is super easy to integrate with.  First install:</p>

<p><code>
npm install newrelic
</code></p>

<p>Call it from early in your program (before errors can start to occur).  NewRelic docs say on the first line of your program.  I load config first.  Everything is fine.</p>

<p><code>js
require('newrelic')
</code></p>

<p>Then in order to let NewRelic have the data that it needs to run, you'll need to setup the config file.  The lib gives you a seed file to start from.</p>

<p><code>
cd &lt;proj_root&gt;
cp node_modules/newrelic/newrelic.js .
</code></p>

<p>Make sure to edit it with your changes.  With that file, you'll want to set your app name, your license key, and any other <a href="https://github.com/newrelic/node-newrelic/blob/master/lib/config.default.js">options you desire</a>.</p>

<h2>Calling NewRelic on <code>uncaughtException</code></h2>

<p>When your Node app goes down, you have <a href="post/handle-errors-node-app/">one final moment</a> to send out your SOS signal -- this is in the <code>uncaughtException</code> handler.</p>

<p>Usually NewRelic will detect errors automatically, such as those that you return as HTTP responses to your clients of status 500 with some error json.  But in this case, we'll need to send the error manually.  The <code>newrelic</code> lib gives us a way to do this with the <code>notifyError</code> function.  It takes the error object and optionally some custom parameters.</p>

<p>So, at first glace, we'd do this:</p>

<p>```js
const newrelic = require('newrelic')</p>

<p>process.on('uncaughtException', err => {
  log.fatal({ err }, 'unhandled error')</p>

<p>  newrelic.noticeError(err)
  process.exit(1)
})
```</p>

<p>But this doesn't deterministically give NewRelic time enough to send the error off to their server.  The lib apparently sends errors on some sort of "harvest" cadence.  <code>process.nextTick</code> doesn't seem to provide enough time either.  But NewRelic does give another API that should help.  The <code>shutdown</code> function cleans up the agent.  It also allows to flush all the pending notifications via <code>collectPendingData</code> option previous to shutdown, which is what we want.</p>

<p>So to make this reliable, we change to:</p>

<p>```js
process.on('uncaughtException', err => {
  log.fatal({ err }, 'unhandled error')</p>

<p>  newrelic.noticeError(err)
  newrelic.shutdown({ collectPendingData: true }, err => {</p>

<pre><code>if (err) log.error({ err }, 'error shutting down newrelic agent')
proc.exit(1)
</code></pre>

<p>  })
})
```</p>

<p>And it works like a charm.  Any additional data that you send to monitoring when your app crashes?  Any ways that you know to make this more reliable?  Have fun logging those crashes!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handle Errors in a Node App]]></title>
    <link href="http://jaketrent.com/post/handle-errors-node-app/"/>
    <updated>2016-08-23T16:34:00-06:00</updated>
    <id>http://jaketrent.com/post/handle-errors-node-app</id>
    <content type="html"><![CDATA[<p>As with any software, here you can expect the unexpected.  Node apps experience errors as well.  Let's say that an error crops in our Node API -- what should we do about it?</p>

<p><img src="http://i.imgur.com/1arT8Ho.jpg" alt="nodejs" /></p>

<!--more-->


<p>Errors can be handled in a lot of different ways.  "Handling" in this article will essentially mean error response messaging.</p>

<h4>Specific Messages are Best</h4>

<p>When handling errors, we should do so as specifically and quickly as possible.  As an example, if we can respond to a request that causes an error with a more specific error message, this would be better than responding with a generic, catch-all message.  This first message:</p>

<p><code>
{ errors: [{ title: 'Title field missing', source: '/data/attributes/title' }] }
</code></p>

<p>is better than this:</p>

<p><code>
{ errors: [{ title: 'Bad request' }] }
</code></p>

<p>But <em>some</em> error messaging is better than nothing.</p>

<p>So, starting with the most specific handling cases and going to the most generic.</p>

<h2>Handle Specific Business Errors</h2>

<p>Let's say that we have an endpoint that creates a new book in our books database, requested at <code>POST /books</code>.  It validates the request body data shape to ensure sufficient and correct data is entered for new books.  Let's say that a user submits a new book without the required title field.  It would be great to have specific response that tells the client what exactly is wrong.  The controller code, in part, might look like this in <a href="https://expressjs.com/">Express</a>:</p>

<p>```js
router.post('/books', (req, res, next) => {
  const errors = validate(req.body.data)
  if (errors) {</p>

<pre><code>saveBook(req.body.data, (_, newBook) =&gt; {
  res.status(201).json({ data: newBook })
})
</code></pre>

<p>  } else {</p>

<pre><code>res.status(400).json({ errors })
</code></pre>

<p>  }
})
```</p>

<p>That last line is the error response with specific error messages.  These messages are presumeably generated by the <code>validate</code> function.  We can provide a specific <code>bad request</code> response status code with a <code>400</code>.  We can provide the specific error response body, which would look like:</p>

<p><code>
{ errors: [{ title: 'Title field missing', source: '/data/attributes/title' }] }
</code></p>

<h2>Catch All Other Errors*</h2>

<p>Now there are other errors that might occur that we either haven't, don't want, or will never be able to anticipate enough to provide specific handling for.  In these cases, we still want to handle the error, but we'll only be able to provide minimal value and insight into the nature of the error to clients in the responses.</p>

<p>Let's adjust our controller code to handle potentially errors that might happen in the book saving process.  What could happen?  Anything... like database issues with connections, constraints, locks or just something bad in our code.  In our callback, let's do something with that potential error:</p>

<p>```js
router.post('/books', (req, res, next) => {
  const errors = validate(req.body)
  if (errors) {</p>

<pre><code>saveBook(req.body, (err, newBook) =&gt; {
  if err return next(err) // new line

  res.status(201).json({ data: newBook })
})
</code></pre>

<p>  } else {</p>

<pre><code>res.status(400).json({ errors })
</code></pre>

<p>  }
})
```</p>

<h4>Required Error Contract</h4>

<p>The <code>err</code> that comes back should be an <code>Error</code> or a subtype that at least follows the error contract and has the 3 required fields of <code>name</code> to identify the type of error, <code>message</code> for the human readable main issue of the error, and <code>stack</code> a string of the accurate location and stack trace of the error.</p>

<h4>Express' <code>next</code> for Errors</h4>

<p>The <code>next</code> function in <a href="https://expressjs.com/">Express</a> will advance to the next middleware.  In the case of passing a non-null value to <code>next</code>, remaining normal middleware will be skipped and the first error middleware will be executed.  Error middleware functions have an arity of 4 parameters instead of the usual 3, where <code>err</code> is the first parameter.  Here's a basic catch-all error handler:</p>

<p><code>js
app.use((err, req, res, next) =&gt; {
  res.status(500).json(serializeError(err))
})
</code></p>

<p><code>serializeError</code> is just going to take that and transform it into something to push across the network in the response.</p>

<p><code>
function serializeError(err) {
  return { errors: [{ status: 500, title: err.message, stack: err.stack }] }
}
</code></p>

<h4>Don't Leak Stacktraces</h4>

<p>Let's add a little something else here.  We probably don't want to leak the stack trace to our users in production, so let's protect it by detecting <code>NODE_ENV</code> and update it to be something like:</p>

<p>```
function serializeError(err) {
  const body = { status: 500, title: err.message }
  if (process.env.NODE_ENV !== 'production')</p>

<pre><code>body.stack = err.stack
</code></pre>

<p>  return { errors: [payload] }
}
```</p>

<p>Even better.  Generic errors handled.</p>

<h2>Crash On the Rest</h2>

<p>Now note the asterisk on the previous section.  We aren't actually able to catch <em>all</em> errors in that generic "catch-all" error handler.  To illustrate, let's create two new routes.  The first is a route that does nothing but throw a new <code>Error</code>:</p>

<p><code>js
router.get('/debug/error', (req, res, next) =&gt; {
  throw new Error('Test explosion')
})
</code></p>

<p>The above route, if requested at <code>GET /debug/error</code>, would throw a new Error and it would be caught by the generic error handler of the previous section.  This is because <code>throw</code> delivers that new <code>Error</code> synchronously.  It stays in the context of the current call stack of the request through Express middleware.  And Express can catch the <code>Error</code> and call your first error-handling middleware.</p>

<h4>Out-of-Context Errors</h4>

<p>But we can easily break out of this context and bypass the catch-all handler entirely.  All we have to do is use a <code>setTimeout</code>.  Calling <code>setTimeout</code> will queue a new message for the event loop to, at some later tick of the clock, run the enclosed function.  Within that function, we'll throw another <code>Error</code>:</p>

<p>```js
router.get('/debug/crash', (req, res, next) => {
  setTimeout(_ => {</p>

<pre><code>throw new Error('Error outside request context')
</code></pre>

<p>  }, 1000)
})
```</p>

<h4>Let the Process Die</h4>

<p>And now there's really nothing that Express can do to help us.  The <code>Error</code> will instead bubble up to the Node process running our app.  That process gives us one final opportunity to know about the occurrence of such a fatal error.  Once we know about it, we can log it.  Perhaps we can get off a call to our monitoring service.  After that, we should assume our process is compromised, potentially unstable, and just crash.  Then use a tool like <a href="https://github.com/foreverjs/forever">forever</a> to detect the downed process and restart it.  Such a crash handler might look like:</p>

<p>```js
  process.on('uncaughtException', err => {</p>

<pre><code>log.fatal({ err }, 'uncaught exception')

process.nextTick(_ =&gt; process.exit(1))
</code></pre>

<p>  })
```</p>

<p>The call to <code>process.nextTick</code> is meant to give some leeway for just enough processing time to finish those last ditch logging/monitoring efforts.</p>

<p>Now we have caught all the errors, in hopefully the best and most helpful way possible.</p>

<p>What other things have you done in your app to make Node error handling better?</p>

<h5>Great Resources</h5>

<ul>
<li><a href="https://www.joyent.com/node-js/production/design/errors">Joyent Production Practices</a> for all-around design practices</li>
<li><a href="https://expressjs.com/en/guide/error-handling.html">Express Error Handling</a> for framework-specific understanding</li>
<li><a href="http://jsonapi.org/format/#error-objects">JSON-API Error Objects</a> for sensible info to include in an error response</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">MDN Event Loop</a> for basics on the message queue in the event loop</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Return an Array in GraphQL]]></title>
    <link href="http://jaketrent.com/post/return-array-graphql/"/>
    <updated>2016-08-16T10:15:00-06:00</updated>
    <id>http://jaketrent.com/post/return-array-graphql</id>
    <content type="html"><![CDATA[<p><a href="http://graphql.org/">GraphQL</a> provides a query language to define the shape of data you'd like returned from an HTTP API on a server and a library to help make it happen.  It's easy to return a single item or multiple items.</p>

<p><img src="http://i.imgur.com/RitF21I.jpg" alt="graphql" /></p>

<!--more-->


<h1>Query Many Items</h1>

<p>To <a href="http://graphql.org/docs/queries/">query in graphql</a>, you setup what looks like a json payload without the values.  For example, to get the <code>id</code> and <code>title</code> fields of <em>all</em> books in your API, you might write:</p>

<p>```
{
  books {</p>

<pre><code>id,
title
</code></pre>

<p>  }
}
```</p>

<h1>Query a Single Item</h1>

<p>To query a single item, filtered by a unique id, you'd add a predicate to the books query:</p>

<p>```
{
  books(id: 123) {</p>

<pre><code>id,
title
</code></pre>

<p>  }
}
```</p>

<p>Otherwise, everything remains the same.</p>

<p>The sameness or similarity with the single item query feels good from someone coming from a REST API, where resources similar to the above would be queried from URIs something like:</p>

<p><code>
/books          # single
/books/123      # multiple
</code></p>

<p>But keeping the same query field, <code>books</code>, for both queries will provide a challenge because we will have to support both the single and multiple query from the same place.</p>

<h1>Define a Schema</h1>

<p>On the server, you need to define a schema for possible supported shapes of data you can query.  We currently have one field that we can query -- <code>books</code>.  In the case where we provide no filter (known as args in a schema), we want to return all books.  If there is a filter, we want to use it, and return a single book.  The schema might look like:</p>

<p>```js
const { GraphQLID, GraphQLList, GraphQLObjectType, GraphQLSchema, GraphQLString } = require('graphql')</p>

<p>const bookType = new GraphQLObjectType({
  name: 'book',
  fields: {</p>

<pre><code>id: { type: GraphQLID },
title: { type: GraphQLString }
</code></pre>

<p>  }
})</p>

<p>const schema = new GraphQLSchema({
  name: 'root',
  fields: {</p>

<pre><code>books: {
  type: new GraphQLList(bookType), // &lt;-- note type
  args: {
    id: { type: GraphQLID }
  },
  resolve(_, args) { // &lt;-- the interesting part
    return args.id
      ? repo.find(args.id)
      : repo.findAll()
  }
}
</code></pre>

<p>  }
})
```</p>

<p>The decision to return a single item or multiple items happens in the <code>resolve</code> function for <code>books</code>.  And the <code>books</code> field config shows that the return type will always be a <code>GraphQLList</code> of <code>bookType</code>.  This means that whether a single item or multiple items, an array will always be returned.  This doesn't feel to terrible -- even familiar when comparing to things like JSON-API.  More importantly, it's <em>required</em> for this return type to work.</p>

<p>At one point, I attempted to use <a href="http://graphql.org/docs/api-reference-type-system/#graphqluniontype"><code>GraphQLUnionType</code></a> to have two potential return types, but I got an error like:</p>

<p><code>
books may only contain Object types, it cannot contain [the array type]
</code></p>

<p>...meaning that I couldn't mix a single object type with an array type in the unioned return type.</p>

<p>So in our chosen, working solution above where we always return an array, any consuming client will query with the<code>books</code> field.  An array of one or many items will be returned.  In the case of returning an array of a single item, the deserialization code will probably want to unwrap the item from the array and expose it as a single object, but obviously this is up to your preference.</p>

<p>There it is.  Have you learned how to do this in a better or more elegant way?</p>
]]></content>
  </entry>
  
</feed>
