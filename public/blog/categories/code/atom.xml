<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-05-20T09:33:33-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[pushState with webpack-dev-server]]></title>
    <link href="http://jaketrent.com/post/pushstate-webpack-dev-server/"/>
    <updated>2015-05-20T07:17:00-06:00</updated>
    <id>http://jaketrent.com/post/pushstate-webpack-dev-server</id>
    <content type="html"><![CDATA[<p>Webpack has a jolly little server for your development environment called <a href="http://webpack.github.io/docs/webpack-dev-server.html"><code>webpack-dev-server</code></a>.  With a touch of configuration, it can be convinced to handle JavaScript history API pushState.</p>

<p><img src="http://i.imgur.com/x0m2sTq.jpg" alt="webpack" /></p>

<!--more-->


<h2>webpack-dev-server</h2>

<p>Webpack is fast.  But once you have a growing number of static assets to process and a increasily-complex asset pipeline, you may wish for a faster build lifecycle in development mode.  <a href="http://webpack.github.io/docs/webpack-dev-server.html"><code>webpack-dev-server</code></a> was created for such a purpose.</p>

<p>It is a small <code>express</code> app that handles building your assets according to your webpack configuration, keeping them in memory, and doing so automatically as you change your source files.</p>

<h2>html-webpack-plugin</h2>

<p>In addition to webpack taking care of static assets like css and js for me, in dev mode I'll often include the <a href="https://www.npmjs.com/package/html-webpack-plugin"><code>html-webpack-plugin</code></a>.</p>

<p>This plugin generates an <code>index.html</code> file for you that will keep up to date with the correct references to your assets built inside of <code>webpack-dev-server</code>.  Use of this plugin is perfect in situations where you're building a client-side app that just needs a single html file to bootstrap on top of.</p>

<h2>History API</h2>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history#Adding_and_modifying_history_entries">history API</a> allows the browser to locally handle url changes that would usually signal a need to go back to the server for resources.  This allows client-side apps to include routers that can navigate from urls like <code>http://localhost:3000/one-place</code> to <code>http://localhost:3000/another</code> instead of having to use the url hash (eg, <code>http://localhost:3000#/one-place</code>).</p>

<h2>All routes to <code>index.html</code></h2>

<p>By default, <code>webpack-dev-server</code> is setup to serve assets directly from the http requests received.  For instance, if my <code>webpack-dev-server</code> was running on port <code>3000</code>, and my <code>webpack.config.js</code> was setup so that I was building a <code>main.js</code> for my application, I could make a request to get that build asset via <code>http://localhost:3000/main.js</code>.</p>

<p>Likewise, if I'm using the <code>html-webpack-plugin</code>, I can make a request to <code>http://localhost:3000/</code> to get my <code>index.html</code> file, which contains the <code>script</code> tag to bootstrap my app -- again, likely something like <code>main.js</code>.</p>

<p>But if my app has a client-side router that is using the history API, how do I get <code>webpack-dev-server</code> to differentiate a client-side route from an asset request to <code>http://localhost:3000</code>?</p>

<h2><code>historyApiFallback</code> Option</h2>

<p>It turns out that we're in luck.  <code>webpack-dev-server</code> includes a useful option named <code>historyApiFallback</code>.  If this boolean flag is set to true, all requests to the <code>webpack-dev-server</code> that do not map to an existing asset will instead by routed straight to <code>/</code>, that is, the <code>index.html</code> file.</p>

<p>This is exactly what we want.  If we want more customization in the fallback routes, we can specify that as well.  Internally, <code>webpack-dev-server</code> uses <a href="https://github.com/bripkens/connect-history-api-fallback"><code>connect-history-api-fallback</code></a> which takes several options.</p>

<p>These options include overriding the name of the index file or rerouting certain request url patterns to different html files in the case you have multiples.  These options can be set by passing an object to <code>historyApiFallback</code> instead of a boolean flag.</p>

<p>Finally, in order to not have to type this every time you want to run the <code>webpack-dev-server</code> cli, you can specify all of these options in the <code>webpack-config.js</code> under the <code>devServer</code> attribute.</p>

<p>The simple example looks like:</p>

<p>```js webpack-config.js
{
  //...
  devServer: {</p>

<pre><code>port: 3000,
historyApiFallback: true
</code></pre>

<p>  }
}
```</p>

<p>A more complex example might look something like:</p>

<p>```js webpack-config.js
{
  //...
  devServer: {</p>

<pre><code>port: 3000,
historyApiFallback: {
  index: 'default.html',
  rewrites: [
    { from: /\/soccer/, to: '/soccer.html'}
  ]
}
</code></pre>

<p>  }
}
```</p>

<p>Given the above configuration, routes like <code>/one-place</code> and <code>/another</code> would go to <code>/</code>, which is backed by the <code>default.html</code> markup.  Routes like <code>/soccer/schedule</code> or <code>/soccer/games/123</code> would go to <code>soccer.html</code>.</p>

<p>So, you don't need to write your own proxy.  The option is built in for you.  webpack excites again!</p>

<p>What other things have you been surprised that webpack already does for you?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[List Npm Scripts]]></title>
    <link href="http://jaketrent.com/post/list-npm-scripts/"/>
    <updated>2015-03-02T07:44:00-07:00</updated>
    <id>http://jaketrent.com/post/list-npm-scripts</id>
    <content type="html"><![CDATA[<p>Tools for storing and then later easily running scripts alias names are awesome.  Npm is one of those tools.  Rake is another.  Rake has a cool feature of allowing you to list the scripts available to you.  Npm has not -- until now.</p>

<p><img src="http://i.imgur.com/ZDCd9u1.png" alt="npm" /></p>

<!--more-->


<h2>Npm Scripts</h2>

<p>You can specify scripts in your <code>package.json</code> for later use.  They go in the <code>scripts</code> attribute:</p>

<p>```json package.json
{
  "scripts": {</p>

<pre><code>"start": "node server.js",
"dist": "webpack -p"
</code></pre>

<p>  }
}
```</p>

<p>To run these scripts, you use the <a href="https://docs.npmjs.com/cli/run-script"><code>npm run</code></a> command.  For example, type <code>npm run build</code> to actually execute the <code>webpack -p</code> command in your terminal.  <code>start</code> and <code>test</code> are specially commands to npm and do not require <code>run</code>.  Instead, you can use <code>npm start</code>.</p>

<h2>Npm List Scripts</h2>

<p>In Rake, you run <code>rake -T</code> in your terminal and all the available scripts for your project are displayed.  This allows you to see the what's potentially helpful.  You can't be expected to remember all of them, especially months later, right?</p>

<p>I certainly was having a hard time remembering all of my scripts and getting tired of typing <code>cat package.json</code>.  It didn't feel as cool as the <code>rake -T</code> experience.  I wrote a library called <a href="https://www.npmjs.com/package/npm-ls-scripts"><code>npm-ls-scripts</code></a>.  To install, run:</p>

<p><code>bash
npm install npm-ls-scripts -g
</code></p>

<p>I like installing this package globally because then the CLI binary is available globally -- it does seem applicable to all projects.  You could instead include it under project <code>devDependencies</code> if you'd like.</p>

<p>If installed globally, you can then run it with:</p>

<p><code>bash
ls-scripts
</code></p>

<p>If I was to run this in the above project, it would print:</p>

<p>```bash</p>

<h2>NPM - ls scripts</h2>

<p>start - node server.js</p>

<h2>dist - webpack -p</h2>

<p>```</p>

<p>This prints the exact code that can be executed for each script.  If I would like to add some prose around any or all of the available scripts, I can do so by adding more config data to my <code>package.json</code> that will print when I run <code>ls-scripts</code>:</p>

<p>```json package.json
{
  "config": {</p>

<pre><code>"scripts: {
   "dist": "Builds project for distribution"
}
</code></pre>

<p>  }
}
```</p>

<p>Now if I were to run the <code>ls-scripts</code> command, I would see:</p>

<p>```bash</p>

<h2>NPM - ls scripts</h2>

<p>start - node server.js</p>

<h2>dist - Builds project for distribution</h2>

<p>```</p>

<p>Cool, right?  Complete with Shakespearean prose.</p>

<h2>New: Npm Run</h2>

<p>After I had developed the above <code>npm-ls-scripts</code> tool, Npm built this feature natively into the core tool -- finally!  Now, to list available scripts, the command is intuitively to leave off the target script and instead simply type:</p>

<p><code>bash
npm run
</code></p>

<p>On the above example, this would yield:</p>

<p>```bash
Available scripts in the package:
  start</p>

<pre><code>node server.js
</code></pre>

<p>  dist</p>

<pre><code>webpack -p
</code></pre>

<p>```</p>

<p>So, they work about the same, and now it's built in!  What other cool features could you imagine this having?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test React componentWillReceiveProps]]></title>
    <link href="http://jaketrent.com/post/test-react-componentwillreceiveprops/"/>
    <updated>2015-02-26T08:34:00-07:00</updated>
    <id>http://jaketrent.com/post/test-react-componentwillreceiveprops</id>
    <content type="html"><![CDATA[<p>Testing React Components has been easier and more enjoyable than any previous UI unit testing I've done in the past.  Components that have interesting things happen in lifecycle methods have a little more setup to get tested.  Components that use the <code>componentWillReceiveProps</code> method are in this category.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react" /></p>

<!--more-->


<h2>React Test Setup</h2>

<p>Not all lifecycle methods require as much setup in a test as <code>componentWillReceiveProps</code>.  This is because:</p>

<ul>
<li>This method is concerned with <strong><em>changing</em></strong> props.</li>
<li>Changing props directly on a React Component (even under test) is against the React code of conduct</li>
</ul>


<p>So, we need something that is legal to change... <code>state</code>!  We need to not modify our subject under test and simply pass it new <code>props</code>.</p>

<p>My solution is to create a React Component specifically for the test.  This Component will be a parent to the subject under test, on which we can set <code>state</code>.  We'll design it so that this state is transferred to the child Component under test.</p>

<h2>React Component using <code>componentWillReceiveProps</code></h2>

<p>You might have a React Component to test that looks like this:</p>

<p>```js
var ComponentToTest = React.createClass({
  getInitialProps() {</p>

<pre><code>return {
  myProp: "blank"
};
</code></pre>

<p>  },
  getInitialState() {</p>

<pre><code>return {
  modified: "still blank"
};
</code></pre>

<p>  },
  componentWillReceiveProps(nextProps) {</p>

<pre><code>this.setState({
  modified: nextProps.myProp + "IsSoModified"
});
</code></pre>

<p>  },
  render() {</p>

<pre><code>return &lt;div class="displayed"&gt;{this.state.modified}&lt;/div&gt;
</code></pre>

<p>  }
});
```</p>

<p>There is nothing particularly interesting about this subject beyond the fact that it uses <code>componentWillReceiveProps</code>.  When new props are received, internal state is modified.  In real life, more interesting things like data fetching or complex calculations might be done here and then stored in state.  We simply are matching the scenario of needing to verify something when <code>componentWillReceiveProps</code> is called.</p>

<h2>A Parent Test Component</h2>

<p>The test to exercise <code>componentWillReceiveProps</code> on the above Component might look like this:</p>

<p>```js
var React = require("react/addons");
var TestUtils = React.addons.TestUtils;</p>

<p>it("displays a modified state upon changing props", function () {
  var TestParent = React.createFactory(React.createClass({</p>

<pre><code>getInitialState() {
  return { testState: "init" };
},
render() {
  return &lt;ComponentToTest ref="sot" myProp={this.state.testState} /&gt;
}
</code></pre>

<p>  }));</p>

<p>  var parent = TestUtils.renderIntoDocument(TestParent());
  parent.refs.sot.props.myProp.should.eql("init");</p>

<p>  parent.setState({</p>

<pre><code>testState: "somethingElse"
</code></pre>

<p>  });</p>

<p>  parent.refs.sot.props.myProp.should.eql("somethingElse");
  parent.refs.sot.state.modified.should.eql("somethingElseIsSoModified"); // assert #1
  var child = TestUtils.scryRenderedDOMComponentsWithClass(parent, "displayed")[0];
  child.getDOMNode().innerText.should.eql("somethingElseIsSoModified");  // assert #2
});
```</p>

<p>The <code>TestParent</code> component is created specifically for this test.  It renders the Component under test.  It sets a <code>ref</code> attribute to it for easy access.  Once we render the parent, the initial state was sent as the prop to the child Component.  As soon as we <code>setState</code> on the parent, a new prop is sent to the child, triggering <code>componentWillReceiveProps</code>.</p>

<p>Finally, I've included two assertion styles.  Again, there are going to be more interesting things that you're asserting here in real life.  In this case I'm verifying that state that renders directly to the UI is set in our lifecycle method.  I can interrogate the state directly.  Here, we reach into the child Component state for assertion method #1.  That may sound bad, but remember that <code>TestParent</code> was created only in the context of this test anyway, so the level we're reaching through to grab child state is just test code.  Assertion method #2 is to go to the DOM to verify final output from the state change.</p>

<p>There is definitely more setup here to make this happen.  I feel like usually testing a React Component doesn't require this much test code.</p>

<h2><code>componentWillReceiveProps</code> in Action</h2>

<p>Here is a Component that uses <code>componentWillReceiveProps</code> to make a simple display change:</p>

<p><a class="jsbin-embed" href="http://jsbin.com/munaxuguta/12/embed?js,output">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>You can also check out this <a href="http://jsbin.com/buwoqod/22/edit?js,output">slightly modified jsbin</a> which does the test assertion.</p>

<p>What methods have you used to test Components that use either <code>componentWillReceiveProps</code> or other interesting lifecycle methods?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sinon Spies vs. Stubs]]></title>
    <link href="http://jaketrent.com/post/sinon-spies-vs-stubs/"/>
    <updated>2015-02-25T07:35:00-07:00</updated>
    <id>http://jaketrent.com/post/sinon-spies-vs-stubs</id>
    <content type="html"><![CDATA[<p><a href="http://sinonjs.org/">Sinon</a> provides spies, stubs, and mocks.  They're all useful as fakes in tests.  They come with essential differences for what they're helpful in doing and how they work.</p>

<p><img src="http://i.imgur.com/yuKcrP9.jpg" alt="spies vs stubs" /></p>

<!--more-->


<h2>Why Use Fakes?</h2>

<p>In a unit test, you might want to avoid having to test the unit's dependencies.  This is especially true in <a href="http://en.wikipedia.org/wiki/White-box_testing">white-box testing</a>.  In this case, test fakes are going to be very helpful.  Sinon provides several fakes, notably spies, stubs, and mocks.  Let's compare and contrast the three:</p>

<h2>Sinon Spies</h2>

<p>Spies sound like what they do -- they watch your functions and report back on how they are called.  They generally avoid the violence and mayhem of a Hollywood spy, but depending on your application, this could vary.</p>

<p>They don't change the functionality of your application.  They simply report what they see.  The <a href="http://sinonjs.org/docs/#spies-api">sinon API for spies</a> is fairly large, but it essentially centers around the <code>called</code> attribute (of which there are many variations).</p>

<p>I first setup that I want to spy on something.  Then I call my subject under test (src code).  Then I verify with the spy what was actually called and stop spying.  That might look like this in a test:</p>

<p>```js
describe("#fight", function () {
  it("calls prayForStrength for fight success", function () {</p>

<pre><code>sinon.spy(subject.strengthDep, "prayForStrength");
subject.fight();
subject.strengthDep.called.should.be.true;
subject.strengthDep.restore();
</code></pre>

<p>  });
});
```</p>

<p><em>Note: this example is in <a href="http://mochajs.org/">mocha</a> using a <a href="https://www.npmjs.com/package/should">should.js</a> assertion style</em></p>

<p>The dependency's <code>prayForStrength</code> method is referred to by name in a string to setup the spy.  When <code>fight</code> is called here, <code>strengthDep.prayForStrength</code> will be called as normal -- but there will be someone watching.  Finally, we call <code>restore</code> on the function we spied on so that all spies are called off.  If you want to do more than watch as dependencies work as described, you might want to use a stub.</p>

<h2>Sinon Stubs</h2>

<p>Stubs are more hands-on than spies (though they sound more useless, don't they).  With a stub, you will actually change how functions are called in your test.  You don't want to change the subject under test, thus changing the accuracy of your test.  But you may want to test several ways that dependencies of your unit could be expected to act.</p>

<p>For instance, if you had a function that returned a boolean that your code used to do different things, you might want to use a stub in two different tests to verify conditions when returning different values (ie, guarantee one run of <code>true</code> and one of <code>false</code> return).</p>

<p>To continue the <code>fight</code> example from above, let's assume that if <code>prayForStrength</code> returns true, we are guaranteed to win the fight for the orphans (ie, <code>fight()</code> should return <code>true</code>).  That might look like this:</p>

<p>```js
describe("#fight", function () {
  it("always wins when prayForStrength is true", function () {</p>

<pre><code>sinon.stub(subject.strengthDep, "prayForStrength", function () { return true; });
subject.fight().should.be.true;
subject.strengthDep.restore();
</code></pre>

<p>  });
});
```</p>

<p>Notice that we use a different <code>sinon.stub</code> API.  For the 3rd parameter, we're supplying our own version of <code>prayForStrength</code>.  For our test, all we care about is the return value, so that's all we supply.  We're not testing this dependency.  We're instead testing how our subject <code>fight</code>s in a certain circumstance.  There are many ways you can use <a href="http://sinonjs.org/docs/#stubs">sinon stubs</a> to control how functions are called.  Also note that you can still use the <code>called</code> verifications with stubs.  But if you do verify a stub was called, you may want to use a mock.</p>

<h2>Sinon Mocks</h2>

<p><a href="http://sinonjs.org/docs/#mocks">Mocks</a> take the attributes of spies and stubs, smashes them together and changes the style a bit.  A mock will both observe the calling of functions and verify that they were called in some specific way.  And all this setup happens <em>previous</em> to calling your subject under test.  After the call, mocks are simply asked if all went to plan.</p>

<p>So the previous test could be rewritten to use a mock:</p>

<p>```js
describe("#fight", function () {
  it("always wins when prayForStrength is true", function () {</p>

<pre><code>var mock = sinon.mock(subject.strengthDep)
mock.expects("prayForStrength").returns(true);
subject.fight().should.be.true;
mock.verify();
mock.restore();
</code></pre>

<p>  });
});
```</p>

<p>The <code>expects</code> and <code>returns</code> line is where the combo magic happens.  <code>expects</code> is verifying a call (like <code>spies</code> can), and <code>returns</code> is specifying functionality (like <code>stubs</code> can).  The <code>verify</code> call is the line that will fail (essentially the mock assertion) if things in the subject didn't go exactly according to plan.</p>

<h2>Spies vs. Stubs vs. Mocks</h2>

<p>So when should I use spies or stubs or mocks?  As with most art, there are many ways to accomplish what you want.  Much of your choice will depend on your own style and what you become proficient in.</p>

<p>Some basic rules might be:</p>

<ul>
<li><strong><em>Use Spies</em></strong> - if you simply want to watch and verify somethings happens in your test case.</li>
<li><strong><em>Use Stubs</em></strong> - if you simply want to specify how something will work to help your test case.</li>
<li><strong><em>Use Mocks</em></strong> - if you want to both of the above on a single dependency in your test case.</li>
</ul>


<p>When do you find yourself most often using spies vs. stubs vs. mocks?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby CLI Options Parsing]]></title>
    <link href="http://jaketrent.com/post/ruby-cli-options-parsing/"/>
    <updated>2015-02-24T07:21:00-07:00</updated>
    <id>http://jaketrent.com/post/ruby-cli-options-parsing</id>
    <content type="html"><![CDATA[<p>Ruby's stdlib never ceases to amaze.  If you're making a CLI tool in Ruby, your efforts are made more straightforward by the existence of the <a href="http://ruby-doc.org/stdlib-2.2.0/libdoc/optparse/rdoc/OptionParser.html">OptionParser</a> class.  Use it, and let happiness fill your heart.</p>

<p><img src="http://i.imgur.com/Z7WWtL0.jpg" alt="Ruby" /></p>

<!--more-->


<p>We're used to some nice CLI tools these days -- ones that have many useful options that allow for easier scripting and more powerful, quick usage.  Ruby's <code>OptionParser</code> will help us make our own and not disappoint the masses of fevered CLI users.</p>

<p>All terminal input from initial execution will enter our Ruby program via the <code>ARGV</code> variable.</p>

<p>To have the <code>OptionParser</code> class available to us, we must require the <code>optsparse</code> package.</p>

<p><code>OptionParser</code> options are defined similar to how you'd expect event handlers to be defined: with the <code>on</code> keyword.  You can pass it a string to match a short option, a string to match the verbose option, and finally a block to be executed when the option is detected.  In the block, we generally will want to store the option state.  We'll choose to use an <code>OpenStruct</code> for that (and will need the <code>ostruct</code> package).</p>

<p>For example:</p>

<p>```ruby
require "optsparse"
require "ostruct"</p>

<p>options = OpenStruct.new
opt_parser = OptionParser.new do |opts|</p>

<pre><code>opts.banner = "Usage: luchador [options]"
opts.separator ""
opts.separator "Options:"

opts.on("-t, "--twist", "Apply the nipple twist") do |t|
  options.twist = true
end

opts.on("-a a", "--anaconda-squeeze a", "The degrees of anaconda squeeze pressure") do |a|
  options.anaconda_squeeze = a
end

opt_parser.parse!(ARGV)
options
</code></pre>

<p>end
```</p>

<p>Now we can we might run CLI tool something like this:</p>

<p><code>
luchador -t --anaconda-squeeze 130
</code></p>

<p>And run with both options engaged for ultimate luchador power.  Notice we used both short and verbose-style options (choosing to write out the longest of the options for its added poetic punch on that whopping 130 degrees of pure squeeze pressure!).</p>

<p>A few more points to note:</p>

<ul>
<li><code>opts.banner</code> and <code>opts.separator</code> can be used to format usage information.</li>
<li>Usage information, stored in <code>opts</code> can be <code>put</code> to the screen.  A <code>-h</code>/<code>--help</code> option is automatically built in for this purpose.</li>
<li>Remember to call <code>parse!</code> after configuring the options so the input is actually processed.</li>
<li>Here, the <code>--anaconda-squeeze</code> option is defined differently than the first: there is a trailing <code>a</code>.  For options that require a non-boolean, this is required.  Otherwise, the argument to your handling block will always be a boolean <code>true</code>.</li>
<li>Note that this example code only shows option parsing -- nothing about the <code>luchador</code> binary itself.</li>
</ul>


<p>This gives you the basic tools.  It's very easy, and it's built in!  To do more, you might take required options first through the CLI options and then read them interactively from the console.  What other neat additions do you see that we could add?</p>
]]></content>
  </entry>
  
</feed>
