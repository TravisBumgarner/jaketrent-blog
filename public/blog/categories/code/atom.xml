<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2013-02-26T07:14:08-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pass Values From the Page to AngularJs]]></title>
    <link href="http://jaketrent.com/post/pass-values-from-page-to-angular/"/>
    <updated>2013-02-22T07:10:00-07:00</updated>
    <id>http://jaketrent.com/post/pass-values-from-page-to-angular</id>
    <content type="html"><![CDATA[<p>There are simple mechanisms for passing data from your web page to AngularJs.  One directive is called <code>ngInit</code>.  You may well need it.</p>

<p><img src="http://i.imgur.com/wVBKD.png" alt="Angular data passing" /></p>

<!--more-->


<h2>The Use Cases</h2>

<p>The use cases don't make a ton of sense without a concrete example.  There are several ways to implement even the most simple example.  If the solution doesn't seem to fit the problem, try another way.</p>

<p>For our purposes, let's say that we're displaying a list of comments on the screen.</p>

<h4>Angular Requests Data</h4>

<p>It's easy to put data into scope for AngularJs to use if Angular is the one to request the data initially.  This often will look something like this:</p>

<p>```coffeescript
$http.get('/comments')
  .success((comments) -></p>

<pre><code>$scope.comments = comments
</code></pre>

<p>  )
```</p>

<p>Then your template will automatically have the data in scope.  And the template (<a href="http://slim-lang.org">Slim</a> syntax used below) can look like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">h1</span> <span class="no">Comments</span>
</span><span class='line'><span class="n">ul</span>
</span><span class='line'>  <span class="n">li</span> <span class="n">ng</span><span class="o">-</span><span class="n">repeat</span><span class="o">=</span><span class="s2">&quot;comment in comments&quot;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;| {{ comment }}</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now when we add a new comment via Ajax, we can push it right into the comment collection, and the page is updated by Angular with the appropriate data.  Or if we want to perform an operation on a pre-existing comment, it's easy to do via an AJAX operation and display the result.</p>

<h4>Server Renders Data Initially</h4>

<p>Sometimes it'll make sense for the server to render the data.  Often this kind of data will be the main content on the page.  When the client receives the page, we want the data display to be immediate.  We don't want them to load a page with a spinner for the main content, then wait and watch it spin while the real content is requested secondarily.</p>

<p>If the server was to initially print the comments, like so:</p>

<p>```ruby
h1 Comments
ul
  - comments.each do |comment|</p>

<pre><code>li 
  = comment
</code></pre>

<p>```</p>

<p>We still might want to do AJAX'y things with a comment, such as like it.  When I like it, I don't want the browser to have to refresh, so I want to make Angular do this for me.</p>

<h2>ngInit Passes Angular Server Data</h2>

<p>Angular provides a nice directive, <code>ngInit</code> for passing Angular data.  It's a mechanism by which you can bootstrap your scripts with the data they need to function.  A mixture of server rendering and client-side AJAX requests on the same data will probably mean that you're going to use this directive.</p>

<p>From the <code>ngInit</code> docs:</p>

<blockquote><p> The ngInit directive specifies initialization tasks to be executed before the template enters execution mode during bootstrap.</p></blockquote>

<p>Our server/client mixture code might look something like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">h1</span> <span class="no">Comments</span>
</span><span class='line'><span class="n">ul</span>
</span><span class='line'>  <span class="o">-</span> <span class="n">comments</span><span class="o">.</span><span class="n">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">comment</span><span class="p">,</span> <span class="n">i</span><span class="o">|&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;li ng-init=&quot;commentLikeCount[i]=</span><span class="si">#{</span><span class="n">comment</span><span class="o">.</span><span class="n">likeCount</span><span class="si">}</span><span class="sr">&quot;</span>
</span><span class='line'><span class="sr">  = comment</span>
</span><span class='line'><span class="sr">  | Likes for this comment: {{commentLikeCount[i]}}</span>
</span><span class='line'><span class="sr">  a ng-click=&quot;like(commentLikeCount[i])&quot;</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It's important to realize where data is coming from in this example.  The syntax <code>=</code> as in <code>= comment</code> and <code>#{}</code> as in <code>#{comment.likeCount}</code> are server-rendered bits.  As you know, the curlies and the ng attribute syntax is for Angular's client side rendering.</p>

<p>So how has this mixture bought us anything?</p>

<ol>
<li>The server renders the comments initially.  This makes the display immediate when the browser loads the page.</li>
<li>We init the value of <code>commentLikeCount</code>, making it available for Angular to display once the client compiles the template.</li>
<li>Since Angular has a count of the likes, it can easily update it and redisplay without a page reload after calling <code>like()</code> to increment the count.</li>
</ol>


<p>Frankly, the mixture feels a little bit odd to me.  I've seen it work.  I know there are different ways to get this done.  I think there are probably better ways.  What has worked well for you in similar use cases?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJs Find Element in Context]]></title>
    <link href="http://jaketrent.com/post/angularjs-find-element-in-context/"/>
    <updated>2013-02-21T17:35:00-07:00</updated>
    <id>http://jaketrent.com/post/angularjs-find-element-in-context</id>
    <content type="html"><![CDATA[<p>Finding an element in context means that I can select a node from the dom within a certain range -- specifically either a node or any of its children nodes.  Is there an "Angular way" to do this?</p>

<p><img src="http://i.imgur.com/wVBKD.png" alt="AngularJs find in context" /></p>

<!--more-->


<h2>Angular's Element() API</h2>

<p>Angular provides jqLite for doing basic CSS selections.  As far as I can tell, it does not give you the ability to specify a context node.  Sure, you can specify a more specific selector, but you can't pass a context programmatically.  The best you could do would look something like:</p>

<p><code>js
angular.element('.my-preknown-context .element-to-find')
</code></p>

<p>If that's sufficient for your use case, this would be the most "Angular way" to make an element selection.</p>

<h2>jQuery's API</h2>

<p>If you need to make CSS selections within a given context, you'll need to use jQuery.  jQuery's selector will be used in place of jqLite if it is loaded previous to the <code>DOMContentLoaded</code> event firing.  In other words, import jQuery in the <code>head</code> tag.</p>

<p>With jQuery, you can do things like this:</p>

<p><code>js
$('.element-to-find', $('.my-preknown-context'))
</code></p>

<p>But we could already do that with the above <code>angular.element</code> function.  If a constraint of our use case is that we don't yet know the selector of the context, then we need to  use this same jQuery API to do what we couldn't before.  For instance, if we want to find a child element of an element that was clicked, the inside of the click handler might look like this:</p>

<p><code>js
$('.element-to-find', $(event.currentTarget))
</code></p>

<p>We could also write it like this:</p>

<p><code>js
$(event.currentTarget).find('.element-to-find')
</code></p>

<p>Well, why not use <code>angular.element().find()</code>?  Because it is limited to querying children by tagName only.  Oh boy.  That's not all that useful.  Interesting/weird constraint.  Oh well, maybe someday.</p>

<h2>jQuery, Meet Angular</h2>

<p>So, using full jQuery is probably not the most "Angular way".  So, what's the best you can do?  Use Angular to get the context reference.  In a click handler, use the <code>$event</code> service which references the event object:</p>

<p><code>js
$('.element-to-find', $event.currentTarget)
</code></p>

<p>In a controller, use the <code>$element</code> service which references the dom node the controller is attached to:</p>

<p><code>js
$('.element-to-find', $element)
</code></p>

<p>This method uses jQuery to fill in for something it seems Angular can't do yet.  And it uses Angular where possible, since it has access to these dom references already.</p>

<p>What do you think?  Is there a more "Angular way" to do this?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serve CoffeeScript from Sinatra]]></title>
    <link href="http://jaketrent.com/post/serve-coffeescript-with-sinatra/"/>
    <updated>2013-02-20T16:39:00-07:00</updated>
    <id>http://jaketrent.com/post/serve-coffeescript-with-sinatra</id>
    <content type="html"><![CDATA[<p>Sinatra is nice because it's super lightweight.  This will allow you to make it do exactly what you want, nothing more.  This is the opposite of Ruby on Rail's convention.  Likewise, it takes just a bit more configuration to make Sinatra serve CoffeeScript as compared to Rails.</p>

<p><img src="http://i.imgur.com/Ta27Zd4.jpg" alt="Sintra and CoffeeScripting" /></p>

<!--more-->


<h2>Sinatra and CoffeeScript</h2>

<p>Surprisingly, there are no fantastic gems, at least that I could churn up in a few Google searches, that make serving CoffeeScript bone head easy.  I found a few, such as the Sinatra Assetpack.  It looked like serious overkill, and my Sinatra app is very small, so I wanted a quick and easy way to serve the static goods.</p>

<h4>CoffeeScript Gem</h4>

<p>Sinatra needs a Gem to compile the CoffeeScript.  Put this line in your <code>Gemfile</code>:</p>

<p><code>
gem "coffee-script"
</code></p>

<p>And run a:</p>

<p><code>
$ bundle install
</code></p>

<h4>Public Directory</h4>

<p>In my app, <code>web.rb</code> is the main controller file.  Next to that file, I have a directory structure like this:</p>

<p><code>
public/
  js/
  coffee/
web.rb
</code></p>

<p>By default, Sinatra will serve static assets out of this <code>public</code> directory.</p>

<h4>CoffeeScript Handler</h4>

<p>I created the <code>coffee</code> directory separate from the <code>js</code> directory so that I could write this little handler in <code>web.rb</code>:</p>

<p><code>ruby
get "/coffee/*.js" do
  filename = params[:splat].first
  coffee "../public/coffee/#{filename}".to_sym
end
</code></p>

<p>This handler will pick up requests that match "/coffee/*.js", find the associated <code>.coffee</code> file, compile it to JavaScript and serve it.  I kept the file extension as <code>.js</code> to help avoid handling any potential mime-type setting requirements.  Obviously, this handler is simple and won't handle complicated cases.  But that is also a plus.</p>

<h4>CoffeeScript in Templates</h4>

<p>In my <a href="http://">Slim</a> template, if I wanted to get the compiled contents of the file named <code>myscripts.coffee</code>, I would write a script tag like this:</p>

<p><code>ruby
script src="http://jaketrent.com/coffee/myscripts.js"
</code></p>

<p>Sinatra.  Coffee.  Bam.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Slim on Sinatra]]></title>
    <link href="http://jaketrent.com/post/setup-slim-on-sinatra/"/>
    <updated>2013-02-19T07:34:00-07:00</updated>
    <id>http://jaketrent.com/post/setup-slim-on-sinatra</id>
    <content type="html"><![CDATA[<p><a href="http://www.sinatrarb.com/">Sintra</a> is a light web server that's easy to start writing Ruby on.  Coming from Node/Express, I feel quite at home there.  Slim also feels like another JavaScript-world templating language, Jade, that I've had good experiences with.  <a href="http://slim-lang.com/">Slim</a> makes for quick templating and feels quite nice compared to ERB if you can handle the Haml style.  It's likewise quick and easy to get working on Sinatra.</p>

<p><img src="http://i.imgur.com/Dsnu3jA.png" alt="Slim templates" /></p>

<!--more-->


<h2>Quick Sinatra Setup</h2>

<h4>Require Sinatra</h4>

<p>Sinatra is super easy to setup.  Create a <code>Gemfile</code> with the dependencies as follows:</p>

<p>```ruby
source "http://rubygems.org"</p>

<p>gem "sinatra"
gem "thin"
```</p>

<p>Then create a default <code>web.rb</code> webserver with contents that look something like:</p>

<p>```ruby
require "sinatra"</p>

<p>get "/" do
  "Hello, world!"
end
```</p>

<p>Then if you run the command:</p>

<p><code>
$ ruby web.rb
</code></p>

<p>You should get a startup message like:</p>

<p>```
== Sinatra/1.3.4 has taken the stage on 4567 for development with backup from Thin</p>

<blockquote><blockquote><p>Thin web server (v1.5.0 codename Knife)
Maximum connections set to 1024
Listening on 0.0.0.0:4567, CTRL+C to stop
```</p></blockquote></blockquote>

<p>Go to <code>localhost:4567</code> in your browser to try out your server.</p>

<h4>Require Slim</h4>

<p>Returning a string is all well and good, but let's include Slim to be able to create more sophisticated templates. Include your Slim dependency in your <code>Gemfile</code> with the line:</p>

<p><code>ruby
gem "slim"
</code></p>

<p>Then from the Terminal, run:</p>

<p><code>
$ bundle install
</code></p>

<h4>Setup your Views</h4>

<p>Then create a directory next to your <code>web.rb</code> file called <code>views</code>.  Inside <code>views</code>, you can create your templates.  You can create a layout template aptly named <code>layout.slim</code>.  By default, your templates will extend from this layout.  Most simply, these files might look like this:</p>

<p>layout.slim:</p>

<p>```haml
doctype html
html
  head</p>

<pre><code>title My Slim Templates App
</code></pre>

<p>  body</p>

<pre><code>= yield
</code></pre>

<p>```</p>

<p>And, index.slim:</p>

<p><code>haml
h1 Loving Slim
</code></p>

<h4>Serve a Slim File</h4>

<p>And now to adjust our <code>web.rb</code> file to serve the new <code>index.slim</code> file:</p>

<p>```ruby
require "sinatra"
require "slim"</p>

<p>get "/" do
  slim :index
end
```</p>

<p>Finally restart your server, and you should see your new template shown in all it's glory.  Pretty easy cheesy.</p>

<h2>Setup Slim on Rails</h2>

<p>Want something even easier?  Well, if you know <a href="http://rubyonrails.org/">Rails</a> already, this will be a cinch.  The hardest part of getting Slim running on Rails is Rails itself.  Slim integration is even easier than on Sinatra.  Simply add this line to your Gemfile:</p>

<p><code>
gem "slim-rails"
</code></p>

<p>And then in order to activate the Slim handler, merely add the <code>.slim</code> extension onto the end of any of your template file names.  Your file names probably end in <a href="http://guides.rubyonrails.org/layouts_and_rendering.html"><code>.erb</code> by default</a>.  Change the ones that you want to convert to Slim templates to look like:</p>

<p><code>
index.html.slim
</code></p>

<p>Now the Rails are even slicker.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multiple Yields in an ERB Template]]></title>
    <link href="http://jaketrent.com/post/multiple-yields-in-erb-template/"/>
    <updated>2013-02-08T07:13:00-07:00</updated>
    <id>http://jaketrent.com/post/multiple-yields-in-erb-template</id>
    <content type="html"><![CDATA[<p>When you setup a new Rails project, you'll have a single layout file which has a single default <code>yield</code> block.  This will soon be inadequate, and you'll want another.  Here's how to setup multiple <code>yield</code> blocks per ERB template.</p>

<p><img src="http://i.imgur.com/YqUKEfw.png" alt="Multiple ERB yields" /></p>

<!--more-->


<h2>Layout File</h2>

<p>By default, Rails will create a file at:</p>

<p><code>
app/views/layouts/application.html.erb
</code></p>

<p>In this file, there will be a default <code>yield</code> block similar to this:</p>

<p><code>ruby
&lt;%= yield %&gt;
</code></p>

<p>It has no name.  It's just the default place for templates that use this layout file to put their content.</p>

<p>We can create new <code>yield</code> blocks.  We'll have to give them a distinguishing name.  They look about the same.  If I wanted to create a new <code>yield</code> block where, for instance, alerts could be displayed if the child template had them, I could put this in my layout file:</p>

<p><code>ruby
&lt;%= yield(:alert) %&gt;
</code></p>

<p>Now I would just need something to go in it.</p>

<h2>Child Templates</h2>

<p>A child template that uses the <code>application.html.erb</code> layout file can just start blasting out markup that will go into the default <code>yield</code> block.  This will usually be the main content.  But in our example, there might be more focused content such as alerts that we want to display in a separate area.  Thus, our template could potentially look like this:</p>

<p>```erb</p>

<h1>My main content</h1>


<p>Bacon ipsum…<p>

<% content_for :alert do %>
  <div class="alert alert-success">
    You created multiple yield blocks!
  </div>
<% end %>
```

Throw down a `content_for` block, matching the name of the `yield` block in your layout file, and you're set.  Order does not matter.  Your specific `content_for` blocks can come before, after, or in the middle of your main content.  Easy as Ruby pie.

]]></content>
  </entry>
  
</feed>
