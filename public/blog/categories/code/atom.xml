<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-08-24T10:37:40-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Handle Errors in a Node App]]></title>
    <link href="http://jaketrent.com/post/handle-errors-node-app/"/>
    <updated>2016-08-23T16:34:00-06:00</updated>
    <id>http://jaketrent.com/post/handle-errors-node-app</id>
    <content type="html"><![CDATA[<p>As with any software, here you can expect the unexpected.  Node apps experience errors as well.  Let's say that an error crops in our Node API -- what should we do about it?</p>

<p><img src="http://i.imgur.com/1arT8Ho.jpg" alt="nodejs" /></p>

<!--more-->


<p>Errors can be handled in a lot of different ways.  "Handling" in this article will essentially mean error response messaging.</p>

<h4>Specific Messages are Best</h4>

<p>When handling errors, we should do so as specifically and quickly as possible.  As an example, if we can respond to a request that causes an error with a more specific error message, this would be better than responding with a generic, catch-all message.  This first message:</p>

<p><code>
{ errors: [{ title: 'Title field missing', source: '/data/attributes/title' }] }
</code></p>

<p>is better than this:</p>

<p><code>
{ errors: [{ title: 'Bad request' }] }
</code></p>

<p>But <em>some</em> error messaging is better than nothing.</p>

<p>So, starting with the most specific handling cases and going to the most generic.</p>

<h2>Handle Specific Business Errors</h2>

<p>Let's say that we have an endpoint that creates a new book in our books database, requested at <code>POST /books</code>.  It validates the request body data shape to ensure sufficient and correct data is entered for new books.  Let's say that a user submits a new book without the required title field.  It would be great to have specific response that tells the client what exactly is wrong.  The controller code, in part, might look like this in <a href="https://expressjs.com/">Express</a>:</p>

<p>```js
router.post('/books', (req, res, next) => {
  const errors = validate(req.body.data)
  if (errors) {</p>

<pre><code>saveBook(req.body.data, (_, newBook) =&gt; {
  res.status(201).json({ data: newBook })
})
</code></pre>

<p>  } else {</p>

<pre><code>res.status(400).json({ errors })
</code></pre>

<p>  }
})
```</p>

<p>That last line is the error response with specific error messages.  These messages are presumeably generated by the <code>validate</code> function.  We can provide a specific <code>bad request</code> response status code with a <code>400</code>.  We can provide the specific error response body, which would look like:</p>

<p><code>
{ errors: [{ title: 'Title field missing', source: '/data/attributes/title' }] }
</code></p>

<h2>Catch All Other Errors*</h2>

<p>Now there are other errors that might occur that we either haven't, don't want, or will never be able to anticipate enough to provide specific handling for.  In these cases, we still want to handle the error, but we'll only be able to provide minimal value and insight into the nature of the error to clients in the responses.</p>

<p>Let's adjust our controller code to handle potentially errors that might happen in the book saving process.  What could happen?  Anything... like database issues with connections, constraints, locks or just something bad in our code.  In our callback, let's do something with that potential error:</p>

<p>```js
router.post('/books', (req, res, next) => {
  const errors = validate(req.body)
  if (errors) {</p>

<pre><code>saveBook(req.body, (err, newBook) =&gt; {
  if err return next(err) // new line

  res.status(201).json({ data: newBook })
})
</code></pre>

<p>  } else {</p>

<pre><code>res.status(400).json({ errors })
</code></pre>

<p>  }
})
```</p>

<h4>Required Error Contract</h4>

<p>The <code>err</code> that comes back should be an <code>Error</code> or a subtype that at least follows the error contract and has the 3 required fields of <code>name</code> to identify the type of error, <code>message</code> for the human readable main issue of the error, and <code>stack</code> a string of the accurate location and stack trace of the error.</p>

<h4>Express' <code>next</code> for Errors</h4>

<p>The <code>next</code> function in <a href="https://expressjs.com/">Express</a> will advance to the next middleware.  In the case of passing a non-null value to <code>next</code>, remaining normal middleware will be skipped and the first error middleware will be executed.  Error middleware functions have an arity of 4 parameters instead of the usual 3, where <code>err</code> is the first parameter.  Here's a basic catch-all error handler:</p>

<p><code>js
app.use((err, req, res, next) =&gt; {
  res.status(500).json(serializeError(err))
})
</code></p>

<p><code>serializeError</code> is just going to take that and transform it into something to push across the network in the response.</p>

<p><code>
function serializeError(err) {
  return { errors: [{ status: 500, title: err.message, stack: err.stack }] }
}
</code></p>

<h4>Don't Leak Stacktraces</h4>

<p>Let's add a little something else here.  We probably don't want to leak the stack trace to our users in production, so let's protect it by detecting <code>NODE_ENV</code> and update it to be something like:</p>

<p>```
function serializeError(err) {
  const body = { status: 500, title: err.message }
  if (process.env.NODE_ENV !== 'production')</p>

<pre><code>body.stack = err.stack
</code></pre>

<p>  return { errors: [payload] }
}
```</p>

<p>Even better.  Generic errors handled.</p>

<h2>Crash On the Rest</h2>

<p>Now note the asterisk on the previous section.  We aren't actually able to catch <em>all</em> errors in that generic "catch-all" error handler.  To illustrate, let's create two new routes.  The first is a route that does nothing but throw a new <code>Error</code>:</p>

<p><code>js
router.get('/debug/error', (req, res, next) =&gt; {
  throw new Error('Test explosion')
})
</code></p>

<p>The above route, if requested at <code>GET /debug/error</code>, would throw a new Error and it would be caught by the generic error handler of the previous section.  This is because <code>throw</code> delivers that new <code>Error</code> synchronously.  It stays in the context of the current call stack of the request through Express middleware.  And Express can catch the <code>Error</code> and call your first error-handling middleware.</p>

<h4>Out-of-Context Errors</h4>

<p>But we can easily break out of this context and bypass the catch-all handler entirely.  All we have to do is use a <code>setTimeout</code>.  Calling <code>setTimeout</code> will queue a new message for the event loop to, at some later tick of the clock, run the enclosed function.  Within that function, we'll throw another <code>Error</code>:</p>

<p>```js
router.get('/debug/crash', (req, res, next) => {
  setTimeout(_ => {</p>

<pre><code>throw new Error('Error outside request context')
</code></pre>

<p>  }, 1000)
})
```</p>

<h4>Let the Process Die</h4>

<p>And now there's really nothing that Express can do to help us.  The <code>Error</code> will instead bubble up to the Node process running our app.  That process gives us one final opportunity to know about the occurrence of such a fatal error.  Once we know about it, we can log it.  Perhaps we can get off a call to our monitoring service.  After that, we should assume our process is compromised, potentially unstable, and just crash.  Then use a tool like <a href="https://github.com/foreverjs/forever">forever</a> to detect the downed process and restart it.  Such a crash handler might look like:</p>

<p>```js
  process.on('uncaughtException', err => {</p>

<pre><code>log.fatal({ err }, 'uncaught exception')

process.nextTick(_ =&gt; process.exit(1))
</code></pre>

<p>  })
```</p>

<p>The call to <code>process.nextTick</code> is meant to give some leeway for just enough processing time to finish those last ditch logging/monitoring efforts.</p>

<p>Now we have caught all the errors, in hopefully the best and most helpful way possible.</p>

<p>What other things have you done in your app to make Node error handling better?</p>

<h5>Great Resources</h5>

<ul>
<li><a href="https://www.joyent.com/node-js/production/design/errors">Joyent Production Practices</a> for all-around design practices</li>
<li><a href="https://expressjs.com/en/guide/error-handling.html">Express Error Handling</a> for framework-specific understanding</li>
<li><a href="http://jsonapi.org/format/#error-objects">JSON-API Error Objects</a> for sensible info to include in an error response</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">MDN Event Loop</a> for basics on the message queue in the event loop</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Return an Array in GraphQL]]></title>
    <link href="http://jaketrent.com/post/return-array-graphql/"/>
    <updated>2016-08-16T10:15:00-06:00</updated>
    <id>http://jaketrent.com/post/return-array-graphql</id>
    <content type="html"><![CDATA[<p><a href="http://graphql.org/">GraphQL</a> provides a query language to define the shape of data you'd like returned from an HTTP API on a server and a library to help make it happen.  It's easy to return a single item or multiple items.</p>

<p><img src="http://i.imgur.com/RitF21I.jpg" alt="graphql" /></p>

<!--more-->


<h1>Query Many Items</h1>

<p>To <a href="http://graphql.org/docs/queries/">query in graphql</a>, you setup what looks like a json payload without the values.  For example, to get the <code>id</code> and <code>title</code> fields of <em>all</em> books in your API, you might write:</p>

<p>```
{
  books {</p>

<pre><code>id,
title
</code></pre>

<p>  }
}
```</p>

<h1>Query a Single Item</h1>

<p>To query a single item, filtered by a unique id, you'd add a predicate to the books query:</p>

<p>```
{
  books(id: 123) {</p>

<pre><code>id,
title
</code></pre>

<p>  }
}
```</p>

<p>Otherwise, everything remains the same.</p>

<p>The sameness or similarity with the single item query feels good from someone coming from a REST API, where resources similar to the above would be queried from URIs something like:</p>

<p><code>
/books          # single
/books/123      # multiple
</code></p>

<p>But keeping the same query field, <code>books</code>, for both queries will provide a challenge because we will have to support both the single and multiple query from the same place.</p>

<h1>Define a Schema</h1>

<p>On the server, you need to define a schema for possible supported shapes of data you can query.  We currently have one field that we can query -- <code>books</code>.  In the case where we provide no filter (known as args in a schema), we want to return all books.  If there is a filter, we want to use it, and return a single book.  The schema might look like:</p>

<p>```js
const { GraphQLID, GraphQLList, GraphQLObjectType, GraphQLSchema, GraphQLString } = require('graphql')</p>

<p>const bookType = new GraphQLObjectType({
  name: 'book',
  fields: {</p>

<pre><code>id: { type: GraphQLID },
title: { type: GraphQLString }
</code></pre>

<p>  }
})</p>

<p>const schema = new GraphQLSchema({
  name: 'root',
  fields: {</p>

<pre><code>books: {
  type: new GraphQLList(bookType), // &lt;-- note type
  args: {
    id: { type: GraphQLID }
  },
  resolve(_, args) { // &lt;-- the interesting part
    return args.id
      ? repo.find(args.id)
      : repo.findAll()
  }
}
</code></pre>

<p>  }
})
```</p>

<p>The decision to return a single item or multiple items happens in the <code>resolve</code> function for <code>books</code>.  And the <code>books</code> field config shows that the return type will always be a <code>GraphQLList</code> of <code>bookType</code>.  This means that whether a single item or multiple items, an array will always be returned.  This doesn't feel to terrible -- even familiar when comparing to things like JSON-API.  More importantly, it's <em>required</em> for this return type to work.</p>

<p>At one point, I attempted to use <a href="http://graphql.org/docs/api-reference-type-system/#graphqluniontype"><code>GraphQLUnionType</code></a> to have two potential return types, but I got an error like:</p>

<p><code>
books may only contain Object types, it cannot contain [the array type]
</code></p>

<p>...meaning that I couldn't mix a single object type with an array type in the unioned return type.</p>

<p>So in our chosen, working solution above where we always return an array, any consuming client will query with the<code>books</code> field.  An array of one or many items will be returned.  In the case of returning an array of a single item, the deserialization code will probably want to unwrap the item from the array and expose it as a single object, but obviously this is up to your preference.</p>

<p>There it is.  Have you learned how to do this in a better or more elegant way?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing es2015 Riot Tags]]></title>
    <link href="http://jaketrent.com/post/testing-es2015-riot-tags/"/>
    <updated>2016-07-28T09:45:00-06:00</updated>
    <id>http://jaketrent.com/post/testing-es2015-riot-tags</id>
    <content type="html"><![CDATA[<p>Getting riot.js setup for development isn't too bad.  But the combo of language features, testing tools, and riot templates made setting up the test environment a bit trickier than I expected.  Here are some of the details.</p>

<p><img src="http://i.imgur.com/EF2IK3G.png" alt="riot tag testing" /></p>

<!--more-->


<h2>Es2015 in Src</h2>

<p>For this project, I am using <a href="http://riotjs.com/">riotjs</a>, which is a React-like library for writing UI components.  The library is designed to look for Riot components in <code>.tag</code> files.  These files look like HTML fragments, like:</p>

<p>```</p>

<div>
  <!-- my component markup... -->
</div>




<script>
  // my component scripts...
</script>


<p>```</p>

<p>I am using <a href="https://babeljs.io/">Babel</a> to transpile the es2015 code in my project.  I also want es2015 available in the tags.  So, instead of just using the <code>babel-preset-es2015</code> preset, I'm using <a href="https://github.com/riot/babel-preset-es2015-riot"><code>babel-preset-es2015-riot</code></a>.  I also want default module export support, so I'm using <code>babel-plugin-add-module-exports</code>.  The <code>.babelrc</code> file looks like:</p>

<p>```js .babelrc
{
  "presets": [</p>

<pre><code>"es2015-riot",
"stage-1"
</code></pre>

<p>  ],
  "plugins": [</p>

<pre><code>"add-module-exports"
</code></pre>

<p>  ]
}
```</p>

<p>For in-browser module support, I'm using webpack.  So, for <code>.js</code>, I'm using <code>babel-loader</code>.  For <code>.tag</code> riot files, I'm using <code>babel-loader</code> <em>plus</em> <code>riotjs-loader</code>.  The useful snippet for the loaders is here:</p>

<p>```js webpack.config.js
{
  // ...
  module: {</p>

<pre><code>loaders: [{
  test: /\.js$/,
  loaders: ['babel'],
  excludes: /node_modules/
}, {
  test: /\.tag$/,
  loaders: ['babel', 'riotjs?type=babel'],
  exclude: /node_modules/
}]
</code></pre>

<p>  }
}
```</p>

<p>Note that the riotjs plugin takes a query parameter for determining what type of code lives in the <code>&lt;script/&gt;</code> section of the <code>.tag</code> files.</p>

<p>Now a simple app might look like this:</p>

<p>```js app.js
import riot from 'riot'</p>

<p>import './app.tag'</p>

<p>export default {
  render() {</p>

<pre><code>riot.mount('app')
</code></pre>

<p>  }
}
```</p>

<p>It's importing the top-most riot component for the app, called <code>app.tag</code>:</p>

<p>```html app.tag
import './header.tag'</p>

<p><app>
  <header></header>
  <!-- more app stuff -->
</app>
```</p>

<p><code>html header.tag
&lt;header&gt;
  &lt;h1&gt;Wow&lt;/h1&gt;
&lt;/header&gt;
</code></p>

<p>Note that the tag file imports other tag files.  To me, this seems to be the right place to do this, since the parent tag has dependencies on children tags.  But it presents a problem that requires extra configuration in the test environment.</p>

<h2>Es2015 in Test</h2>

<p>In test land, we are using <a href="https://github.com/avajs/ava">ava</a> as our test runner.  We configure it in the <code>package.json</code> file:</p>

<p>```json package.json
{
  "ava": {</p>

<pre><code>"babel": "inherit",
"files": [
  "src/**/*.spec.js"
],
"require": [
  "babel-register",
  "./test/utils/node-extensions",
  "./test/utils/dom"
]
</code></pre>

<p>  }
}
```</p>

<p>A few explanations about the test setup above...</p>

<p>Ava supports es2015 out of the box.  But it also allows you to specify your own <code>.babelrc</code> configuration using the 'inherit' value.</p>

<p>With <code>files</code>, we are telling ava to find all the specs in the <code>src/</code> subdir that have the <code>.spec.js</code> filename suffix.</p>

<p>The <code>require</code> section is used to specify what code needs loaded before the specs run:</p>

<ul>
<li><code>babel-register</code> - so we can use es2015 in test setup code.</li>
<li><code>./test/utils/node-extensions</code> - so we can tell node (running ava) how to load the <code>.tag</code> files that it encounters (remember, we don't have webpack in this test environment).</li>
<li><code>./test/utils/dom</code> - sets up a jsdom for doing our UI test</li>
</ul>


<p>The <code>node-extensions.js</code> file is pretty interesting.  It is providing node a new function for how to handle the <code>.tag</code> files.  For these files, we'll compile using the riot compiler and then compile that output using babel.  In the end, we should have ready code.  You'll also notice that this custom file loader requires that we load up our <code>.babelrc</code> file manually because we're acting outside of ava at this point.</p>

<p>```js test/utils/node-extensions.js
const babel = require('babel-core')
const fs = require('fs')
const path = require('path')
const riot = require('riot')</p>

<p>// Add riot to node env so compilation works - per https://github.com/riot/riot/issues/895
global.riot = riot</p>

<p>function getBabelRc() {
  try {</p>

<pre><code>const contents = fs.readFileSync(path.join('..', '..', '.babelrc'), 'utf8')
return JSON.parse(contents)
</code></pre>

<p>  } catch (e) {</p>

<pre><code>console.log('Error loading .babelrc', e)
return {}
</code></pre>

<p>  }
}</p>

<p>// override behavior for riot tag import - per https://github.com/mochajs/mocha/issues/1458
require.extensions['.tag'] = function (module, filename) {
  const content = fs.readFileSync(filename, 'utf8')
  const riotCompiled = riot.compile(content, { type: 'babel' })</p>

<p>  const babelCompiled = babel.transform(riotCompiled, getBabelRc())</p>

<p>  return module._compile(babelCompiled.code, filename)
}
```</p>

<p>Next, we have our dom setup, which is pretty straightforward jsdom:</p>

<p>```js test/utils/dom.js
import jsdom from 'jsdom'</p>

<p>const doc = jsdom.jsdom('&lt;!doctype html><html><body></body></html>')
const win = doc.defaultView
global.document = doc
global.window = win
global.navigator = win.navigator
global.history = win.history
```</p>

<p>Now we have a dom with a body tag we can render into, so let's try to test out our <code>app.js</code> render code -- finally, the test:</p>

<p>```js app.spec.js
import test from 'ava'</p>

<p>import subject from '../app'</p>

<p>test.before(t => {
  document.querySelector('body').appendChild(document.createElement('app'))
})</p>

<p>test.after.always(t => {
  const body = document.querySelector('body')
  while (body.firstChild) {</p>

<pre><code>body.removeChild(body.firstChild)
</code></pre>

<p>  }
})</p>

<p>test('#render displays a header', t => {
  subject.render()
  t.truthy(document.querySelector('h1').innerHTML === 'Wow')
})
```</p>

<p>So much work for such a benign test. :)</p>

<p>It's a cool combo of technologies.  But it takes a fair bit of wrangling and that interesting bit of <code>node-extensions.js</code> code to get it working.</p>

<p>Have you used this combo of tech before or something similar?  Any better setups that you've found?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[react-dnd With Text Drag Preview]]></title>
    <link href="http://jaketrent.com/post/react-dnd-text-drag-preview/"/>
    <updated>2016-04-21T08:04:00-06:00</updated>
    <id>http://jaketrent.com/post/react-dnd-text-drag-preview</id>
    <content type="html"><![CDATA[<p><a href="http://gaearon.github.io/react-dnd/">react-dnd</a> is a fantastic library for implementing drag and drop features in a React application.  In browsers, you have the ability to specify a drag preview for the thing your dragging.  Images are easy.  Text takes more work -- because you need to generate an image.</p>

<p><img src="http://i.imgur.com/E5NwBek.png" alt="react-dnd text drag previews" /></p>

<!--more-->


<p>I love the abstractions in react-dnd.  They seem very elegant.  We're going to need another abstraction here, because there's a short list of things that we need to do in order to get a text-based drag preview showing up in our app.  These things are required because drag previews in browsers only support images.  Thus we will need to take source text from our app code and convert it into an image in order to hand it off to the drag and drop api.</p>

<h2>Drag Text from a Canvas</h2>

<p>To convert text to an image, we must:</p>

<ol>
<li>Create a canvas element</li>
<li>Fit the canvas to our text</li>
<li>Style the canvas</li>
<li>Create a new image element with the canvas data as src</li>
</ol>


<h4>Create a Canvas Element</h4>

<p>We choose a canvas element because we can write text onto it and eventually export its bytes.</p>

<p><code>js
var c = document.createElement('canvas')
var ctx = c.getContext('2d')
</code></p>

<h4>Fit Canvas to the Text</h4>

<p>We want the drag preview to be dynamically sized.  This is because the text can change in length.   The key to our success is available on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/measureText">Canvas 2D context as <code>measureText</code></a>.  This function is available in IE9+.  In case you don't have access to this function, you can attempt a crude fallback.</p>

<p>```js
function getTextWidth(ctx, fontSize, text) {
  if (typeof ctx.measureText === 'function') {</p>

<pre><code>return ctx.measureText(text).width
</code></pre>

<p>  } else {</p>

<pre><code>var perCharWidth = fontSize / 1.7
return text.length * perCharWidth
</code></pre>

<p>  }
}
```</p>

<h4>Style the Canvas</h4>

<p>Once you know how big to make your drag preview, draw a rectangle upon which you can then draw your text.</p>

<p>In addition to drawing the main content, there are also other stylistic adjustments that you can make via <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D">attributes on <code>CanvasRenderingContext2D</code></a>.  Attributes like <code>fillStyle</code>, <code>strokeStyle</code>, and <code>font</code> are available.</p>

<p>```js
ctx.rect(0, 0, rectWidth, rectHeight)</p>

<p>ctx.save()
ctx.fillStyle = backgroundColor
ctx.strokeStyle = borderColor
ctx.fill()
ctx.stroke()
ctx.restore()</p>

<p>ctx.fillText(text)
```</p>

<h4>Create a new Image Element</h4>

<p>Remember, drag preview requires an image to render when the user is dragging.  Set the <code>src</code> of the image to the data from the canvas.  This will transfer everything you just created in the canvas into an image.</p>

<p><code>js
var img = new Image()
img.src = c.toDataURL()
</code></p>

<p>This image should be ready to use in react-dnd's <a href="http://gaearon.github.io/react-dnd/docs-drag-source-connector.html"><code>connect#dragPreview</code></a>.</p>

<h2>A Library to Help</h2>

<p>When making a React drag and drop app, I usually don't look forward to using the sometimes-arcane API of the <code>canvas</code> element.  So, I wrapped it up so I wouldn't have to look at it as often.</p>

<p>If you think this might help you, take a look at <a href="http://npm.im/react-dnd-text-dragpreview">react-dnd-text-dragpreview</a>.</p>

<p><a href="http://npm.im/react-dnd-text-dragpreview"><img src="http://i.imgur.com/glegZVc.gif" /></a></p>

<p>How do you go about doing text-based drag previews?  Any other good tips?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Change Default NPM License]]></title>
    <link href="http://jaketrent.com/post/change-default-npm-license/"/>
    <updated>2016-03-24T15:45:00-06:00</updated>
    <id>http://jaketrent.com/post/change-default-npm-license</id>
    <content type="html"><![CDATA[<p>Npm has a fantastic init tool for creating the descriptor for your project.  It will gladly provide defaults for you.  These are sometimes helpful.  Wouldn't it be more better to define your own defaults?</p>

<p><img src="http://i.imgur.com/P34k4L5.png" alt="NPM" /></p>

<!--more-->


<h2>Npm Init</h2>

<p>If you're doing any JavaScript development, NPM is likely a helpful tool for your toolbox.  To add a descriptor with meta information, including things like 3rd-party project dependencies, you need a <code>package.json</code> for your project.  To get this file, you can edit it by hand or have one generated for you.  To generate it, run:</p>

<p><code>
npm init
</code></p>

<p>You will then be prompted to answer a series of relevant questions, such as:</p>

<p><code>
name: (hello-riot)
version: (1.0.0)
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
...
</code></p>

<p>The values in parenthesis are the defaults.  Defaults are determined from things like the directory you're in, the git repository you're in, etc.</p>

<h2>Set Npm Init Defaults</h2>

<p>Some defaults are just the NPM-provided conventions.  They don't know much more to provide.  But you can provide your own defaults for your system by editing <code>~/.npmrc</code>.  Or you can use the cli to add to this file from the terminal.  For instance, the two I like to change are my author name and the license:</p>

<p><code>
npm config set init-author-name "jaketrent"
npm config set init-license "MIT"
</code></p>

<p>Now, you can init and just take the defaults without pressing enter to answer the question with:</p>

<p><code>
npm -y
</code></p>

<p>And what you get are the defaults you've already decided you like.</p>

<p>To know what other things you can change as defaults, use <code>npm help 7 config</code> and grep for <code>init-</code>-prefixed values.  Happy npm'ing!</p>
]]></content>
  </entry>
  
</feed>
