<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: heroku | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/heroku/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2013-09-05T07:34:27-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Deploy Yeoman App on Heroku]]></title>
    <link href="http://jaketrent.com/post/yeoman-app-on-heroku/"/>
    <updated>2013-04-23T07:12:00-06:00</updated>
    <id>http://jaketrent.com/post/yeoman-app-on-heroku</id>
    <content type="html"><![CDATA[<p>Yeoman is great developer tool that will help you generate a project format that is easy to get up and running quickly.  Out of the box, Yeoman only generates static sites.  But, with a few small tweaks, you can get it running on an app server, Nodejs, and up on Heroku.</p>

<p><img src="http://i.imgur.com/1Mc2kXh.jpg" alt="Yeoman" /></p>

<!--more-->


<h2>New Project With Yeoman</h2>

<p>To install Yeoman, run:</p>

<p><code>
npm install -g yo
</code></p>

<p>Now navigate to your new project directory and generate the scaffolding by running:</p>

<p><code>
yo webapp
</code></p>

<p>There are other generators, specifically for angularjs or a handful of other frameworks.  To see more options, run:</p>

<p><code>
yo --help
</code></p>

<h2>Add Node for Heroku</h2>

<p>Since Yeoman creates a static site, it should be read to serve out of any old web server.  But Heroku specifically wants an app server.  Node is one of the options, and it's a great option for a lightweight app server.</p>

<p>To get the node dependencies you need, create a <code>package.json</code> via:</p>

<p><code>
npm init
</code></p>

<p>Then pull down the dependencies you'll need:</p>

<p><code>
npm install gzippo express coffee-script --save
</code></p>

<p>Now create your app server, <code>web.coffee</code>.  It's about as light as they come:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">gzippo = </span><span class="nx">require</span> <span class="s">&#39;gzippo&#39;</span>
</span><span class='line'><span class="nv">express = </span><span class="nx">require</span> <span class="s">&#39;express&#39;</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nv">app = </span><span class="nx">express</span><span class="p">()</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">use</span> <span class="nx">express</span><span class="p">.</span><span class="nx">logger</span> <span class="s">&#39;dev&#39;</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">use</span> <span class="nx">gzippo</span><span class="p">.</span><span class="nx">staticGzip</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">__dirname</span><span class="si">}</span><span class="s">/dist&quot;</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">listen</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">PORT</span> <span class="o">||</span> <span class="mi">5000</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It's going to be serving the static resources that you build w/ Yeoman/Grunt that end up in the <code>dist</code> directory.  In order for code to get to Heroku, it needs to be commited to your git repo.  Thus, you need to remove the "dist" line from your <code>.gitignore</code> file, and don't forget to add and commit the files to git as you build them.  You may also have to add more tasks to the <code>Gruntfile.js</code> to copy over any other assets to <code>dist</code> that your app needs to run.</p>

<p>Finally create a <code>Procfile</code> file for Heroku in the root of your project that points to the <code>web.coffee</code> server:</p>

<p><code>
web: coffee web.coffee
</code></p>

<p>Now it's time to push to Heroku.  You should have the Heroku Toolbelt installed and create a heroku url by running:</p>

<p><code>
heroku create &lt;my_project&gt;
</code></p>

<p>To test your yeoman app as it will be run in production, first build it:</p>

<p><code>
grunt build
</code></p>

<p>Then run the grunt server:</p>

<p><code>
grunt server:dist
</code></p>

<p>Or if you have foreman and want to run the app using your <code>Procfile</code>, run:</p>

<p><code>
foreman start
</code></p>

<p>It's time.  Commit your code, especially that <code>dist</code> directory, and... deploy!</p>

<p><code>
git push heroku master
</code></p>

<p>There are quite a few steps there.  What did we miss?  Or what needs more explanation?  Perhaps we just need a <code>yo heroku</code> target.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Https Redirect for Node on Heroku]]></title>
    <link href="http://jaketrent.com/post/https-redirect-node-heroku/"/>
    <updated>2013-02-26T07:33:00-07:00</updated>
    <id>http://jaketrent.com/post/https-redirect-node-heroku</id>
    <content type="html"><![CDATA[<p>When your app requires users to be using the <code>https</code> protocol to make requests and get responses, it's helpful to have an automatic redirect so the user is always in the right place.  Here's how to do that for a Node Express app on Heroku.</p>

<p><img src="http://i.imgur.com/5rZ8H.png" alt="NodeJs Https Redirect" /></p>

<!--more-->


<h2>Secure Express Requests</h2>

<p>The <a href="http://expressjs.com">Express</a> request object has a bunch of great information.  One of its attributes is <code>secure</code>.  It's a boolean.  Usually, <code>secure == true</code> will mean that you're on <code>https</code>.  When that is not true, you're ready for a redirect.</p>

<p>Unfortunately for apps hosted on Heroku, <code>request.secure</code> will always be false.  The way that Heroku routing works, it will just never be set.</p>

<h2>Heroku Https Header</h2>

<p>Instead, Heroku forwards an http header that allows us to do the same "is secure" test.  On Heroku, <code>request.header('x-forwarded-proto')</code> will contain the actual protocol string (eg, 'http' or 'https').</p>

<h2>Express Middleware SSL Redirect</h2>

<p>If you're using the Express framework on Node, then you have it easy.  There's already a great middleware mechanism for you to send any or all requests through.  If you set your Express app (v3) up like this:</p>

<p><code>coffeescript
app = express()
</code></p>

<p>Then you can use the <code>app.use</code> functionality to specify a middleware.  Since I only have certificates and want the redirect to happen in the production environment, I will likewise wrap this middleware inside <code>app.configure</code> for prod (it inspects <code>NODE_ENV</code> for you).  This redirect will be pretty rudimentary, but it's just that simple, so here it goes:</p>

<p>```coffeescript
app.configure 'production', ->
  app.use forceSsl(req, res, next) -></p>

<pre><code>if req.header 'x-forwarded-proto' != 'https'
  res.redirect "https://#{req.header 'host'}#{req.url}"
else
  next()
</code></pre>

<p>```</p>

<p>If it's not <code>https</code> already, redirect the same url on <code>https</code>.  If it is, that's what I want, and you can pass on through my middleware function.  Note that this middleware will protect <em>all</em> urls on the site with an <code>https</code> redirect.  Your middleware could be more selective.  You could even create this as a stacked middleware per route if you wanted.  We could even enhance our middleware to use inspect both the http header <em>and</em> the <code>secure</code> flag.</p>

<p>Heroku threw us a for a minor, unexpected loop, but it was nothing that we couldn't easily code for.</p>
]]></content>
  </entry>
  
</feed>
