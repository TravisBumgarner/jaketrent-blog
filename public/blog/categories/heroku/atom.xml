<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: heroku | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/heroku/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-01-04T13:35:22-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Add Zerigo DNS to Heroku]]></title>
    <link href="http://jaketrent.com/post/add-zerigo-dns-to-heroku/"/>
    <updated>2013-12-31T07:03:00-07:00</updated>
    <id>http://jaketrent.com/post/add-zerigo-dns-to-heroku</id>
    <content type="html"><![CDATA[<p>Once upon a time, I could setup DNS super easily on Heroku using their Zerigo DNS addon.  Lately, I tried again using the same pattern and failed.  Here's an updated step-by-step guide.</p>

<p><img src="http://i.imgur.com/6DUwRKt.png" alt="Heroku and Zerigo" /></p>

<!--more-->


<h2>Back in the Day</h2>

<p>It used to be that all you had to do was setup the nameservers on your domain registrar, add the Zerigo addon on Heroku's end with a few commands, and you were rocking in minutes.  The latest DNS setup on Heroku caused me a bit more grief.  Something has changed.  But there is hope.  The new steps are almost just as brief.  You'll just have to take care to get it just right.</p>

<h2>Cedar, not Bamboo</h2>

<p>These days new deployments on Heroku are going to favor using the Cedar stack as the new option.  The Bamboo stack was the original and older Ruby stack.  And so it troubled me after setting up my DNS as I used to that I got an error message (<a href="https://devcenter.heroku.com/articles/error-codes#h70-access-to-bamboo-http-endpoint-denied">h70</a>) similar to this in my logs:</p>

<p><code>bash
2010-10-06T21:51:07-07:00 heroku[router]: at=error code=H70 desc="Access to bamboo HTTP endpoint denied" method=GET path=/ host=foo.myapp.com fwd=17.17.17.17 dyno= connect= service= status=503 bytes=
</code></p>

<p>Lame, lame, lame, lame, lame.  Now, who did you contact?</p>

<p>Running <code>heroku info</code> reveals that I'm indeed using the Cedar stack on this project, so what gives?  It turns out my DNS was messed up.</p>

<h2>The New Zerigo/Heroku Setup</h2>

<p>The <a href="https://devcenter.heroku.com/articles/zerigo_dns">Heroku devcenter docs for Zerigo</a> are pretty good, but as of this writing, they're a little inaccurate.  Here is the step-by-step that worked for me:</p>

<h4>1. Nameservers</h4>

<p>Setup your domain via your registrar's site to point to these nameservers:</p>

<p><code>
a.ns.zerigo.net
b.ns.zerigo.net
c.ns.zerigo.net
d.ns.zerigo.net
e.ns.zerigo.net
</code></p>

<h4>2. Zerigo Addon</h4>

<p>Add the Zerigo addon via the Heroku cli:</p>

<p><code>bash
heroku addons:add zerigo_dns
</code></p>

<h4>3. Zerigo Config</h4>

<p>Open Zerigo addon for configuration:</p>

<p><code>bash
heroku addons:open zerigo_dns
</code></p>

<p>Navigate to the Zerigo site for your app and press the "Add Snippet" button.  From the snippets available, select "Heroku".  This snippet contains a CNAME entry and a URL redirect entry.  Add the snippet.  Now, you'll need to adjust the CNAME entry.  The <code>data</code> field probably reads <code>proxy.heroku.com</code>.  This has been deprecated.  Instead, change the CNAME entry to point to <code>yourapp.herokuapp.com</code>.</p>

<p>Note also that the URL redirect entry is moving all traffic from yourapp.com to http://www.yourapp.com.  Apparently now the "www." subdomain is required and you can't setup a naked domain on Heroku.  If someone knows otherwise, I'd love to here about it, because I used to do this all the time.</p>

<h4>4. Add Domains on Heroku</h4>

<p>Via the Heroku cli, type:</p>

<p><code>bash
heroku domains:add www.yourapp.com
</code></p>

<p>Note that we do <em>not</em> want to add <code>yourapp.com</code> (no "www") to in this manner.  If you do that, the tool adds multiple A records to Zerigo, which the Zerigo docs clearly state you don't want.  These A records are what will activate routing through the Bamboo stack, which you want to avoid.</p>

<p>This should be the point at which you can refresh your browser at "yourapp.com".  You should see the redirect happen, moving you to "www.yourapp.com".  The routing should be happy on Heroku's end.  It sometimes takes more time for this to propagate, so if you don't see results immediately, be a bit patient before your start changing your configuration, thinking it's not working.</p>

<p>Has anyone else run into this?  Is there a better way to set this up?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploy Yeoman App on Heroku]]></title>
    <link href="http://jaketrent.com/post/yeoman-app-on-heroku/"/>
    <updated>2013-04-23T07:12:00-06:00</updated>
    <id>http://jaketrent.com/post/yeoman-app-on-heroku</id>
    <content type="html"><![CDATA[<p>Yeoman is great developer tool that will help you generate a project format that is easy to get up and running quickly.  Out of the box, Yeoman only generates static sites.  But, with a few small tweaks, you can get it running on an app server, Nodejs, and up on Heroku.</p>

<p><img src="http://i.imgur.com/1Mc2kXh.jpg" alt="Yeoman" /></p>

<!--more-->


<h2>New Project With Yeoman</h2>

<p>To install Yeoman, run:</p>

<p><code>
npm install -g yo
</code></p>

<p>Now navigate to your new project directory and generate the scaffolding by running:</p>

<p><code>
yo webapp
</code></p>

<p>There are other generators, specifically for angularjs or a handful of other frameworks.  To see more options, run:</p>

<p><code>
yo --help
</code></p>

<h2>Add Node for Heroku</h2>

<p>Since Yeoman creates a static site, it should be read to serve out of any old web server.  But Heroku specifically wants an app server.  Node is one of the options, and it's a great option for a lightweight app server.</p>

<p>To get the node dependencies you need, create a <code>package.json</code> via:</p>

<p><code>
npm init
</code></p>

<p>Then pull down the dependencies you'll need:</p>

<p><code>
npm install gzippo express coffee-script --save
</code></p>

<p>Now create your app server, <code>web.coffee</code>.  It's about as light as they come:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">gzippo = </span><span class="nx">require</span> <span class="s">&#39;gzippo&#39;</span>
</span><span class='line'><span class="nv">express = </span><span class="nx">require</span> <span class="s">&#39;express&#39;</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nv">app = </span><span class="nx">express</span><span class="p">()</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">use</span> <span class="nx">express</span><span class="p">.</span><span class="nx">logger</span> <span class="s">&#39;dev&#39;</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">use</span> <span class="nx">gzippo</span><span class="p">.</span><span class="nx">staticGzip</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">__dirname</span><span class="si">}</span><span class="s">/dist&quot;</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">listen</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">PORT</span> <span class="o">||</span> <span class="mi">5000</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It's going to be serving the static resources that you build w/ Yeoman/Grunt that end up in the <code>dist</code> directory.  In order for code to get to Heroku, it needs to be commited to your git repo.  Thus, you need to remove the "dist" line from your <code>.gitignore</code> file, and don't forget to add and commit the files to git as you build them.  You may also have to add more tasks to the <code>Gruntfile.js</code> to copy over any other assets to <code>dist</code> that your app needs to run.</p>

<p>Finally create a <code>Procfile</code> file for Heroku in the root of your project that points to the <code>web.coffee</code> server:</p>

<p><code>
web: coffee web.coffee
</code></p>

<p>Now it's time to push to Heroku.  You should have the Heroku Toolbelt installed and create a heroku url by running:</p>

<p><code>
heroku create &lt;my_project&gt;
</code></p>

<p>To test your yeoman app as it will be run in production, first build it:</p>

<p><code>
grunt build
</code></p>

<p>Then run the grunt server:</p>

<p><code>
grunt server:dist
</code></p>

<p>Or if you have foreman and want to run the app using your <code>Procfile</code>, run:</p>

<p><code>
foreman start
</code></p>

<p>It's time.  Commit your code, especially that <code>dist</code> directory, and... deploy!</p>

<p><code>
git push heroku master
</code></p>

<p>There are quite a few steps there.  What did we miss?  Or what needs more explanation?  Perhaps we just need a <code>yo heroku</code> target.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Https Redirect for Node on Heroku]]></title>
    <link href="http://jaketrent.com/post/https-redirect-node-heroku/"/>
    <updated>2013-02-26T07:33:00-07:00</updated>
    <id>http://jaketrent.com/post/https-redirect-node-heroku</id>
    <content type="html"><![CDATA[<p>When your app requires users to be using the <code>https</code> protocol to make requests and get responses, it's helpful to have an automatic redirect so the user is always in the right place.  Here's how to do that for a Node Express app on Heroku.</p>

<p><img src="http://i.imgur.com/5rZ8H.png" alt="NodeJs Https Redirect" /></p>

<!--more-->


<h2>Secure Express Requests</h2>

<p>The <a href="http://expressjs.com">Express</a> request object has a bunch of great information.  One of its attributes is <code>secure</code>.  It's a boolean.  Usually, <code>secure == true</code> will mean that you're on <code>https</code>.  When that is not true, you're ready for a redirect.</p>

<p>Unfortunately for apps hosted on Heroku, <code>request.secure</code> will always be false.  The way that Heroku routing works, it will just never be set.</p>

<h2>Heroku Https Header</h2>

<p>Instead, Heroku forwards an http header that allows us to do the same "is secure" test.  On Heroku, <code>request.header('x-forwarded-proto')</code> will contain the actual protocol string (eg, 'http' or 'https').</p>

<h2>Express Middleware SSL Redirect</h2>

<p>If you're using the Express framework on Node, then you have it easy.  There's already a great middleware mechanism for you to send any or all requests through.  If you set your Express app (v3) up like this:</p>

<p><code>coffeescript
app = express()
</code></p>

<p>Then you can use the <code>app.use</code> functionality to specify a middleware.  Since I only have certificates and want the redirect to happen in the production environment, I will likewise wrap this middleware inside <code>app.configure</code> for prod (it inspects <code>NODE_ENV</code> for you).  This redirect will be pretty rudimentary, but it's just that simple, so here it goes:</p>

<p>```coffeescript
app.configure 'production', ->
  app.use forceSsl(req, res, next) -></p>

<pre><code>if req.header 'x-forwarded-proto' != 'https'
  res.redirect "https://#{req.header 'host'}#{req.url}"
else
  next()
</code></pre>

<p>```</p>

<p>If it's not <code>https</code> already, redirect the same url on <code>https</code>.  If it is, that's what I want, and you can pass on through my middleware function.  Note that this middleware will protect <em>all</em> urls on the site with an <code>https</code> redirect.  Your middleware could be more selective.  You could even create this as a stacked middleware per route if you wanted.  We could even enhance our middleware to use inspect both the http header <em>and</em> the <code>secure</code> flag.</p>

<p>Heroku threw us a for a minor, unexpected loop, but it was nothing that we couldn't easily code for.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[django_content_type_app_label_key Constraint on Heroku]]></title>
    <link href="http://jaketrent.com/post/django_content_type_app_label_key-constraint-herok/"/>
    <updated>2011-12-30T13:30:00-07:00</updated>
    <id>http://jaketrent.com/post/django_content_type_app_label_key-constraint-herok</id>
    <content type="html"><![CDATA[<p>Django comes with some awesome CLI tools.  Manage.py is a beast of magic and lore.  And it loves the fantastical kingdom of Heroku, where is romps with merry measure twixt the ether.  But, when I've tried to go through a dumpdata of a previous site, syncdb on a migration to Heroku, and loaddata for moving the data, I've run into a snag on django_content_type_app_label_key more than once.  Here are some resolutions.</p>

<!--more-->


<h2>The Error Stack</h2>

<p>Specifically, when I do a sync of the database:</p>

<p><code>bash
heroku run python manage.py syncdb
</code></p>

<p>It works like a charm.  And then a loading of the data:</p>

<p><code>bash
heroku run python manage.py loaddata data.json
</code></p>

<p>It runs for a bit then spews this small hiccup:</p>

<p>```bash
Running python manage.py loaddata data.json attached to terminal... up, run.2
Problem installing fixture 'data.json': Traceback (most recent call last):
  File "/app/lib/python2.7/site-packages/django/core/management/commands/loaddata.py", line 174, in handle</p>

<pre><code>obj.save(using=using)
</code></pre>

<p>  # ...more stack trace...
  File "/app/lib/python2.7/site-packages/django/db/backends/postgresql_psycopg2/base.py", line 44, in execute</p>

<pre><code>return self.cursor.execute(query, args)
</code></pre>

<p>IntegrityError: duplicate key value violates unique constraint "django_content_type_app_label_key"
```
Lovely.</p>

<p>It turns out that <code>syncdb</code>, in addition to running the DDLs for your table creation also populates the <code>django_content_type</code> table.  And then when you loaddata it tries to repopulate the table, violating the unique constraint on the content type name.</p>

<h2>Make the Magic Live Again</h2>

<p>There are a couple ways around this:</p>

<h3>Dump Something Specific</h3>

<p>When you dumpdata, only <a href="https://docs.djangoproject.com/en/dev/ref/django-admin/#dumpdata-appname-appname-appname-model">dump specific apps</a> instead of the whole project.  For example:</p>

<p><code>bash
python manage.py dumpdata myApp
</code></p>

<h3>Django 1.3 Exclude</h3>

<p>If you're on Django 1.3 or above, you get a nice new option with dumpdata to <a href="https://docs.djangoproject.com/en/dev/ref/django-admin/#django-admin-option---exclude">exclude certain apps</a>.  So you could run:</p>

<p><code>bash
python manage.py dumpdata --exclude contenttypes
</code></p>

<h3>Try in Vain to Reset</h3>

<p>Another one I tried (but didn't work) was:</p>

<p><code>bash
heroku run python aprilandjake/manage.py reset contenttypes
</code></p>

<h3>Sql Truncate</h3>

<p>Or, if you're still trying to dumpdata on your whole project, you could <code>syncdb</code> on Heroku and then truncate the data out of <code>django_content_type</code> like this:</p>

<p><code>bash
heroku run python aprilandjake/manage.py dbshell
</code></p>

<p>And then <a href="http://swik.net/django/Django+Community+Aggregator?page=2">truncate</a> (inside the dbshell):</p>

<p><code>bash
truncate django_content_type cascade;    
</code></p>

<p>Problem for me is that didn't work either.  I am on the super cheap in Heroku, so I get this lovely denial:</p>

<p><code>bash
Running python manage.py dbshell attached to terminal... up, run.5
Error: You appear not to have the 'psql' program installed or on your path.
</code></p>

<p>(It's not available in a <a href="http://devcenter.heroku.com/articles/heroku-postgresql">shared database</a>):</p>

<p><code>bash
heroku pg:psql
!  Cannot ingress to a shared database
</code></p>

<h3>Delete via Admin UI</h3>

<p>And finally, if you want to get rid of the data via the admin UI, set it up to appear as editable.  In an <a href="https://docs.djangoproject.com/en/dev/ref/contrib/admin/#modeladmin-objects"><code>admin.py</code></a> in your project, try something like this:</p>

<p>```python
from django.contrib.contenttypes.models import ContentType</p>

<p>class ContentTypeAdmin(admin.ModelAdmin):
  list_display = ['name', 'app_label']
  fieldsets = (</p>

<pre><code>('', {
  'classes': ('',),
  'fields': ('name', 'app_label')
}),
</code></pre>

<p>  )</p>

<p>  admin.site.register(ContentType, ContentTypeAdmin)
```</p>

<p>Now you should be able to loaddata and feel the Django wind in your hair and the Heroku grass beneath your feet again.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django loaddata on Heroku]]></title>
    <link href="http://jaketrent.com/post/django-loaddata-heroku/"/>
    <updated>2011-11-20T09:45:00-07:00</updated>
    <id>http://jaketrent.com/post/django-loaddata-heroku</id>
    <content type="html"><![CDATA[<p>Django's manage.py script comes with some great utilitarian commands.  Two of my favorites are dumpdata and loaddata.  I've used these commands recently to migrate a Django app's data to the same Django app now running on Heroku.  Here's a little taste of the glory.</p>

<!--more-->


<p><a href="https://www.djangoproject.com/">Django</a> is awesome.  <a href="http://www.heroku.com/">Heroku</a> is awesome.  <a href="http://devcenter.heroku.com/articles/django>">Combined</a> they are awesomeerest.</p>

<p>First, get your data out of your existing Django app with manage.py's <a href="https://docs.djangoproject.com/en/dev/ref/django-admin/#dumpdata-appname-appname-appname-model">dumpdata</a>:</p>

<p><code>bash
python manage.py dumpddata --natural --indent 2 &gt; data.json
</code></p>

<p>By default it comes out as json, but you can <a href="https://docs.djangoproject.com/en/dev/ref/django-admin/#django-admin-option---format>">change that</a>.  The two options used above have now become common-place for me, providing:</p>

<ul>
<li>"--natural" - use this baby for when you dump contrib.contenttypes ContentType.  Since we're taking the whole db, odds are that you're using it, since most interesting django apps do.</li>
<li>"--indent" - make it human-readable instead of a single-liner.</li>
</ul>


<p>The "> data.json" is just some Unix'y redirect goodness to stash the output of your dumpdata command in the data.json file.</p>

<p>Now you want to get your data.json into the db of your Heroku-based Django app.  Heroku allows you the ability to run <a href="http://devcenter.heroku.com/articles/oneoff-admin-ps">one-off processes</a> such as the loaddata command.  But the next hurdle will be getting your data.json onto the Heroku server.  This is always handled in a git push.  And to make it a little bit more interesting, let's say that the code you have isn't particularly sensitive, but the data is.  So, we're going to commit the data.json, push it, remove the latest git commit, be able to push our code to the origin server, and still run loaddata on Heroku.  Sheesh.</p>

<p>Ok, so commit your file:</p>

<p><code>bash
git add data.json
git commit -m "Added data"
</code></p>

<p>Push it to Heroku:</p>

<p><code>bash
git push heroku master
</code></p>

<p><a href="http://stackoverflow.com/questions/927358/git-undo-last-commit/927386#927386">Remove commit</a>:</p>

<p><code>bash
git reset --soft HEAD^
</code></p>

<p><a href="http://stackoverflow.com/questions/1505948/how-do-i-remove-a-single-file-from-the-staging-area-of-git-but-not-remove-it-fro/1505968#1505968">Remove file</a> from staging area:</p>

<p><code>bash
git reset HEAD data.json
</code></p>

<p>Save your code w/o data included:</p>

<p><code>bash
git push origin master
</code></p>

<p>And now you should still have data.json on your Heroku server and be able to run loaddata:</p>

<p><code>bash
heroku run python manage.py loaddata data.json
</code></p>

<p>If it all works, your data fixtures should be found and you should see a confirmation message that they were loaded into the db.  Just like a dream.  The only thing that would make it better is if you never had to commit data.json at all.  Too bad Heroku couldn't pick up local file input like it can pick up STDIN in a 'heroku run' command!</p>

<h2>Update: Force Next Push</h2>

<p>Also note that if you continue to commit to git locally on future enhancements to your app and then want to push again to Heroku, you'll likely get an error message:</p>

<p><code>bash
git push heroku master
To git@heroku.com:myProject.git
 ! [rejected]        master -&gt; master (non-fast-forward)
error: failed to push some refs to 'git@heroku.com:myProject.git'
To prevent you from losing history, non-fast-forward updates were rejected
Merge the remote changes (e.g. 'git pull') before pushing again.  See the
'Note about fast-forwards' section of 'git push --help' for details.
</code></p>

<p>To get around this, next time you push to Heroku, try:</p>

<p><code>bash
git push heroku master -f
</code></p>

<p>And force it to do your bidding.</p>
]]></content>
  </entry>
  
</feed>
