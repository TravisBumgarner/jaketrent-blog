<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: marklogic | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/marklogic/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2014-11-28T10:47:31-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How MarkLogic Made Me a Better Programmer]]></title>
    <link href="http://jaketrent.com/post/how-marklogic-made-me-better-programmer/"/>
    <updated>2013-08-08T09:01:00-06:00</updated>
    <id>http://jaketrent.com/post/how-marklogic-made-me-better-programmer</id>
    <content type="html"><![CDATA[<p>I started programming on the <a href="http://www.marklogic.com/">MarkLogic</a> platform in 2010.  It was a very new experience for me.  I don't program in it these days, but I still think back on the experiences I had with MarkLogic and in general believe that they made me a better programmer.  Here's how.</p>

<p><img src="http://i.imgur.com/32OKIUH.png" alt="MarkLogic" /></p>

<!--more-->


<h2>First Functional Language</h2>

<p>MarkLogic is a proprietary platform that uses the XQuery language.  This is MarkLogic-flavor XQuery, augmenting the vanilla.  There are first-level functions.  There are sequences.  There are no side effects.  There is no state outside of function scope.</p>

<p>This language proved to require a new way of thinking.  I came from coding Java at the time.  I was without my <code>StringBuilder</code> class.  I remember the first time I tried to build up a string dynamically in code.  There is no such thing as throwing substrings in a builder or a buffer and building it up (no side effects).  Of course, there is a way to build a dynamic string; it is just different.  I became a lot more comfortable with recursive methods for solving problems.</p>

<p>As a side note, the language isn't 100% functional.  For instance, there actually are side effects.  For example, the <a href="https://docs.marklogic.com/map"><code>map</code></a> api sets values on preexisting maps and returns the same map.  And the terrible <a href="https://docs.marklogic.com/xdmp:set"><code>xmdp:set</code></a> will bypass all of the functional sauce and set whatever whenever and is to be avoided.</p>

<h2>First NoSql Store</h2>

<p>MarkLogic has its own database built in.  It's a document store.  It was the first place I implemented real NoSQL work and pushed it to production.  Here, I learned document design.  I practiced optimizing for reads or writes depending on the use case.  The experience helped me think beyond well-formed tables and embrace the messier data that is more true to life.  I was thinking more in terms of search engines and less in terms of spreadsheets.</p>

<p>Coding in MarkLogic utilizes XQuery which encompasses XPath.  Given that much X technology, the data format was almost assuredly going to be XML.  And so it is.  Every document stored in MarkLogic is XML.  I became a lot better at tree traversal as a result.</p>

<h2>Lack of Libraries</h2>

<p>The MarkLogic ecosystem at the time was really lacking.  I don't follow its current state, but it's probably safe to say that there is less going on here than in the world of Node or Ruby.  You won't find a MarkLogic package manager a la <code>npm</code> or <code>gem</code>.  You probably won't even find a library to reuse.  There are literally just a handful of libraries that are shared widely in my experience, and these are lower-level utility libraries of the flavor of UnderscoreJs.</p>

<p>This meant that if I needed code, I was going to write it.  So, I wrote a lot of code.  I learned to produce everything I needed and not rely on any 3rd party code.</p>

<p>This was the same when it came to utilities on the platform.  For instance, there was not a unit test library at the time I started into XQuery.  There was a framework that was written in Java that would exercise XQuery code, but that didn't fit my environment needs very well and felt odd, so we wrote our own unit testing framework a la Junit or Jasmine, called <a href="https://github.com/irinc/xqtest">XqTest</a>.  We finally open sourced it (also rare for the MarkLogic ecosystem), but by then several similar frameworks had been created.</p>

<h2>Lack of Help</h2>

<p>MarkLogic is a proprietary system.  There aren't many people using it, but those that do license it from the MarkLogic company.  They also pay for support.  Most of the expertise I encountered in MarkLogic was either a visiting consultant from MarkLogic, an engineer I met at the one MarkLogic conference, MarkLogic world, or a fellow in-house engineer.</p>

<p>This means that when you go to StackOverflow, there is a woeful lack of good solutions for common problems.  So, I learned to do a lot of debugging by myself and just keep on keeping on until I figured out the problem.  We had to write almost all of our code, so I was mostly reading my own code, which is easier.  Google wasn't a lot of help, and that's pretty odd in this age of programming.  Upside was that once I wrote the web article about the subject, I was the first-page <a href="http://rockycode.com/blog/tech/marklogic/">result</a>.</p>

<h2>Playing Ops</h2>

<p>MarkLogic has its own web server as well, built into the monolith MarkLogic server product.  It was a new beast for the ops guys I worked with.  I was as new to it as them, thus I got to play ops a lot more than I would have on our older, more traditional systems.  I got to help keep the thing running.</p>

<p>I also got to help keep the apps tuned.  It turns out that MarkLogic can be either really performant or really <em>not</em> performant.  Often, I wrote the "not" way, and I had to help optimize (of course, via our in-house performance monitoring tools).</p>

<h2>The Experience</h2>

<p>I was excited to learn MarkLogic at the time.  It was something new.  I enjoy that.  New code, new team, new thinking.  It was a high-profile product.  It was really a good experience.</p>

<p>I felt like I became very productive on the platform and was able to produce quality and quantity code.  In the end, I chose to not do more more MarkLogic.  I was doing more heavy client-side apps.  The XML just became a stumbling block where Json is king.  The functional paradigm is cool.  I really like it.  But I really don't like the XQuery language.  Its api is not very expressive, and its syntax requires a ton of typing.  MarkLogic is growing in its acceptance and use, but not at a huge pace.  It still seems like a niche product, used mostly in the publishing and defense industries.  It didn't seem like a great investment to keep spending my golden dev years on the platform.</p>

<p> But for all the pros and cons of the platform and all the ups and downs of the experience, I feel like one of the net effects was that I became a better programmer in new, interesting ways.  For that, I'm grateful.  I'm glad I did it, and I'm glad to move on.  There are, after all, soooo many cool things to try in this age of software development.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XQuery Dynamic Order By]]></title>
    <link href="http://jaketrent.com/post/xquery-dynamic-order/"/>
    <updated>2012-05-19T11:45:00-06:00</updated>
    <id>http://jaketrent.com/post/xquery-dynamic-order</id>
    <content type="html"><![CDATA[<p>When ordering a sequence of items in XQuery, sometimes it's desirable to be able to decide the order based on a parameter value (something dynamic).  XQuery doesn't look extremely elegant when it comes to this feature, but depending on exactly what you want, you should be able to get the job done.</p>

<!--more-->


<h2>Static sort</h2>

<p>In XQuery, an a FLWOR statement can be ordered (the "O" in FLWOR).  Here are some taffy f</p>

<p>```
let $items :=
  <taffies></p>

<pre><code>&lt;taffy&gt;&lt;quantity&gt;13&lt;/quantity&gt;&lt;flavor&gt;Root Beer&lt;/flavor&gt;&lt;/taffy&gt;
&lt;taffy&gt;&lt;quantity&gt;5&lt;/quantity&gt;&lt;flavor&gt;Black Licorice&lt;/flavor&gt;&lt;/taffy&gt;
&lt;taffy&gt;&lt;quantity&gt;133&lt;/quantity&gt;&lt;flavor&gt;Cotton Candy&lt;/flavor&gt;&lt;/taffy&gt;
</code></pre>

<p>  </taffies>
for $i in $items/taffy
order by xs:integer($i/quantity)
return $i
```</p>

<p>Note that if you want to sort by something besides the natural order of string values (in this case, an <code>xs:integer</code>), you need to cast the value.</p>

<h2>Dynamic ascending or descending</h2>

<p>Ascending order means lowest values will be listed first, and the higher values will be listed later.  Descending means just the opposite.  By default, XQuery order by clauses are sorted in ascending order.</p>

<p>Let's say that you have just <em>one</em> sort commparator (in this case, quantity) that you care to sort by.  But there's some toggle in your logic or UI or somewhere that determines whether things should be sorted in ascending or descending order.  A <a href="http://markmail.org/thread/rpc3unlqlj72loah#query:+page:1+mid:k3zprjr4civlrkfg+state:results">nice markmail thread from Michael Blakely</a> reveals a nice solution.  For our example, it would look something like:</p>

<p>```
let $ascending := fn:false()
let $items :=
  <taffies></p>

<pre><code>&lt;taffy&gt;&lt;quantity&gt;13&lt;/quantity&gt;&lt;flavor&gt;Root Beer&lt;/flavor&gt;&lt;/taffy&gt;
&lt;taffy&gt;&lt;quantity&gt;5&lt;/quantity&gt;&lt;flavor&gt;Black Licorice&lt;/flavor&gt;&lt;/taffy&gt;
&lt;taffy&gt;&lt;quantity&gt;133&lt;/quantity&gt;&lt;flavor&gt;Cotton Candy&lt;/flavor&gt;&lt;/taffy&gt;
</code></pre>

<p>  </taffies>
for $i in $items/taffy
order by
  if ($ascending) then xs:integer($i/quantity) else () ascending,
  if ($ascending) then () else xs:integer($i/quantity) descending
return $i
```</p>

<p>The syntax is a little odd in order for us to get the result we want.  There are two <code>if</code> expressions.  They are separated by commas, so it is pretty much just a primary, then secondary sort.  The conditional is the same on each ("if is ascending");  But then notice that was just a way to get the syntax to work, because it's really an if-else.</p>

<h2>Multiple Sort Values</h2>

<p>The next case is slightly more complicated, but I initially tried the Michael Blakely approach.  This case introduced another parameter:  Sometimes I wanted to sort by quantity, but other times I instead wanted to sort by the name of the flavor.  So, I came out with something like this:</p>

<p>```
let $ascending := fn:false()
let $sortby := "flavor"
let $items :=
  <taffies></p>

<pre><code>&lt;taffy&gt;&lt;quantity&gt;13&lt;/quantity&gt;&lt;flavor&gt;Root Beer&lt;/flavor&gt;&lt;/taffy&gt;
&lt;taffy&gt;&lt;quantity&gt;5&lt;/quantity&gt;&lt;flavor&gt;Black Licorice&lt;/flavor&gt;&lt;/taffy&gt;
&lt;taffy&gt;&lt;quantity&gt;133&lt;/quantity&gt;&lt;flavor&gt;Cotton Candy&lt;/flavor&gt;&lt;/taffy&gt;
</code></pre>

<p>  </taffies>
for $i in $items/taffy
order by
  if ($ascending and $sortby eq "quantity") then xs:integer($i/quantity) else () ascending,
  if ($ascending and $sortby eq "quantity") then () else xs:integer($i/quantity) descending
  if ($ascending and $sortby eq "flavor") then $i/flavor else () ascending,
  if ($ascending and $sortby eq "flavor") then () else $i/flavor descending
return $i
```</p>

<p>El problemo is that because these are essentially just a list of secondary sorts and each <code>if</code> conditional has an <code>else</code> with an actual sort value, I'm not really sorting by just one thing.  This scenario has <code>$sortby</code> set to "flavor", but it's really still sorting by quantity descending primarily, then flavor descending secondarily.  Blast.</p>

<h2>Fully-dynamic order by clause -- and everything else</h2>

<p>At this point, I was contemplating doing the full smash and just evaluating a dynamically-built string describing my desired query:</p>

<p>```
let $ascending := fn:false()
let $sortby := "flavor"
let $items :=
  <taffies></p>

<pre><code>&lt;taffy&gt;&lt;quantity&gt;13&lt;/quantity&gt;&lt;flavor&gt;Root Beer&lt;/flavor&gt;&lt;/taffy&gt;
&lt;taffy&gt;&lt;quantity&gt;5&lt;/quantity&gt;&lt;flavor&gt;Black Licorice&lt;/flavor&gt;&lt;/taffy&gt;
&lt;taffy&gt;&lt;quantity&gt;133&lt;/quantity&gt;&lt;flavor&gt;Cotton Candy&lt;/flavor&gt;&lt;/taffy&gt;
</code></pre>

<p>  </taffies>
return xdmp:value(fn:concat("for $i in $items/taffy ",
"order by $i/", $sortby,
if ($ascending) then
  " ascending "
else
  " descending ",
"return $i"))
```</p>

<p>I guess that's all right.  I try to avoid string->query conversions just for safety and code complexity, but perhaps I call <code>xdmp:value</code> safe enough here, since it's just executing XQuery within the context of the current expression, because I could call this <em>less</em> complex than the previous (albeit not what we want) scenario.</p>

<p>So, what did I end up with?</p>

<h2>Sort by dynamic value first</h2>

<p>Again, all I wanted to was to sort by a single value based on a parameter, and have ascending/descending be another variable parameter.  If you don't care to get a descending sort, then dynamic order by is actually not too bad.  So, get that out of the way and then decide if you like the order or not.  If not, it must be backward, so reverse it:</p>

<p>```
let $ascending := fn:false()
let $sortby := "flavor"
let $items :=
  <taffies></p>

<pre><code>&lt;taffy&gt;&lt;quantity&gt;13&lt;/quantity&gt;&lt;flavor&gt;Root Beer&lt;/flavor&gt;&lt;/taffy&gt;
&lt;taffy&gt;&lt;quantity&gt;5&lt;/quantity&gt;&lt;flavor&gt;Black Licorice&lt;/flavor&gt;&lt;/taffy&gt;
&lt;taffy&gt;&lt;quantity&gt;133&lt;/quantity&gt;&lt;flavor&gt;Cotton Candy&lt;/flavor&gt;&lt;/taffy&gt;
</code></pre>

<p>  </taffies>
let $sorted :=
  for $i in $items/taffy
  order by</p>

<pre><code>if ($sortby eq "quantity") then 
  xs:integer($i/quantity)
else if ($sortby eq "flavor") then 
  $i/flavor
else 
  ()
</code></pre>

<p>  return $i
return if ($ascending) then
  $sorted
else
  fn:reverse($sorted)
```</p>

<p>Thanks for the suggestion, Tommy.  It's simple.  Maybe not super-efficient for large datasets.  But, it gets the job done.</p>

<p>Any other awesome ways you've found to get dynamic order by clauses in your XQuery statements?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test-driven Development on MarkLogic]]></title>
    <link href="http://jaketrent.com/post/test-driven-development-marklogic/"/>
    <updated>2011-10-11T19:46:00-06:00</updated>
    <id>http://jaketrent.com/post/test-driven-development-marklogic</id>
    <content type="html"><![CDATA[<p>Unit testing is a required part of a healthy software development lifecycle and a balanced breakfast.  But test-driven development is a rockin' part of an <em>awesome</em> development lifecycle.  What's the difference?  If you don't test-drive the dev of your MarkLogic XQuery, you may never come back to test again.  Test-driven XQuery development will ease your headaches, put you into the plush seat of a developer with confidence, and rocket you down the road to making all your wildest dreams come true.  Kachow!</p>

<!--more-->


<p>Ok, it may be slightly <em>more</em> magical than that.  But, I don't want to get your hopes up.  Seriously, though, if TDD is fun in, say Java Land (and it still is in MarkLogic land with "the Swede"), then it's a required portion of fun in MarkLogic Land?  Why?  While you might imagine yourself going back and adding tests to your Java project and sometimes you do, if you imagine it and then attempt it in your XQuery project, I believe the likelihood that you shrivel in shame and tears under your desk is much higher than in some other environments.</p>

<p>I the difficulty of the test after development approach is higher in MarkLogic XQuery because of what I've called "camouflaged dependencies" -- essentially, access to the http request and respond and to the database.</p>

<p>You can get access to request fields or headers or anything else dealing with the web context in which the code is executed at any place in your code.  This doesn't mean you have to code like this, but the language doesn't necessarily help you enforce your discipline.  This is where testing before you write the code will help.  Make you functions functional -- pass in parameters and make them the only data access.</p>

<p>You can read the database natively in MarkLogic XQuery.  That means that you can be retrieving data anywhere in your code.  There is an extreme lack of ceremony in making a connection to the database -- it's always there;  they're connected.  This is both refreshing and a shiny nail strip upon which to puncture the tires of your test-driven sports coupe e're you drive it off the lot.  Resist the temptation to read from the database or write to the database save in very determined and specific parts of your app -- parts that you will not actually unit test [gasp] because they'll be doing nothing but saving xmls at given database uris, and MarkLogic already has internal testing for that.</p>

<p>So, respect what you might call your dependencies -- the network and the database -- and be thrilled with the adventure of testing the business logic that you write yourself and need to verify.  And test it first to help keep you on the strait and narrow.  Otherwise, you're "discipline" will crumble under deadlines and in the end it will "just work" -- until it doesn't -- and you won't know why.</p>

<p>Note:
Below are the slides to support a presentation given at an in-house development conference.  It is an evolution of a talk previously given on <a href="">unit testing XQuery on MarkLogic</a> with streamlined principles and skills section and a not-included coding portion surrounding the use of XqTest, our XQuery unit test framework, and its integration in our environment.  Tonight, as I say my prayers, I will continue to hope that someday XqTest will be released from its prison and "the Swede" will see the light of day!</p>

<div style="width:425px" id="__ss_9651897"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/rockycode/testdriven-development-on-marklogic" title="Test-driven Development on MarkLogic" target="_blank">Test-driven Development on MarkLogic</a></strong> <iframe src="http://www.slideshare.net/slideshow/embed_code/9651897" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/rockycode" target="_blank">rockycode</a> </div> </div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I18n Strings in Javascript]]></title>
    <link href="http://jaketrent.com/post/i18n-strings-javascript/"/>
    <updated>2011-08-23T13:17:00-06:00</updated>
    <id>http://jaketrent.com/post/i18n-strings-javascript</id>
    <content type="html"><![CDATA[<p>I've seen a number of different ways that internationalized strings get put into Javascript code.  Of all of them, I kind of like just bundling the resource bundle of key value pairs in Javascript files themselves, one for each language or something close to that.  But, in a recent project, there were a few other constraints, so we did it another way.</p>

<!--more-->


<h2>The Situation</h2>

<ul>
<li>We're using MarkLogic on the backend -- our data is stored in xml.  Our server-side code is XQuery.</li>
<li>Some of these strings are needed on the server side as well, so storing them all on the client in .js files wasn't going to cut it.</li>
<li>We wanted to get all of the strings into the same place to make the list more manageable to update and maintain.</li>
</ul>


<p>So, now there are two parts to getting internationalized strings available in the front-end code: The data transform on the backend and the strings made available on the front-end.</p>

<h2>The Backend Transform</h2>

<p>The resource bundle data looks like this:</p>

<p>```xml
<resource-bundle xml:lang="spa">
  <resource key="my.key.name"></p>

<pre><code>&lt;value&gt;Translated String&lt;/value&gt;
</code></pre>

<p>  </resource></p>

<!-- ... more ... -->


<p></resource-bundle>
```</p>

<p>The transform a la:</p>

<p>```
declare function get-lang-dict($bundle-collection as xs:string, $lang as xs:string?, $keys as xs:string<em>) as xs:string</em> {
  let $eng :=</p>

<pre><code>if (fn:exists($keys)) then
  get-resource-bundle($bundle-collection, "eng")/resource[@key = $keys]
else
  get-resource-bundle($bundle-collection, "eng")/resource
</code></pre>

<p>  let $translations :=</p>

<pre><code>if (fn:exists($keys)) then
  get-resource-bundle($bundle-collection, $lang)/resource[@key = $keys]
else
  get-resource-bundle($bundle-collection, $lang)/resource
</code></pre>

<p>  let $max := fn:count($translations)
  for $translation at $i in $translations
  let $engTxt := $eng[@key eq $translation/@key]/value/text()
  let $key := if (fn:exists($engTxt)) then</p>

<pre><code>json:escape(fn:normalize-space(fn:string($engTxt[1])))
</code></pre>

<p>  else</p>

<pre><code>fn:string($translation/@key)
</code></pre>

<p>  return fn:concat("'", $key, "': '", json:escape(xdmp:quote($translation/value/text())), "'",</p>

<pre><code>if ($i eq $max) then () else ",")
</code></pre>

<p>};</p>

<p>declare function get-resource-bundle($bundle-collection as xs:string, $lang as xs:string) as element()* {
  fn:collection($resource-collection-uri)/resource-bundle[@xml:lang eq $lang]
};
```</p>

<p>Now we have our xml transformed into a sequence of xs:string, each a json object where the English text is the key and the language text is the value, like this:</p>

<p><code>json
{ "English String": "Translated String" }
</code></p>

<p>The XQuery expression that renders the html page includes a call to populate the Javascript "lang" object with the json:</p>

<p>
```
declare function lang-dictionary($lang as xs:string?) as element(script) {
  <script type="text/javascript"></p>

<pre><code>jQuery(document).ready(function(){{
  lang.dict("{$lang}", {{
    {get-lang-dict("bundle-collection", "spa", ("keys", "if", "any"))}
  }});
}});
</code></pre>

<p>  </script>
};
```
</p>

<p>Note that if you provide a pre-known set of i18n string $keys to the get-lang-dict() function, it will only add those resources to the dictionary.  Otherwsie, all the resources in your bundle are added.</p>

<h2>Front-end Usage</h2>

<p>The lang object that stores the dictionary of translated strings is like so:</p>

<p>```javascript
var lang = (function () {</p>

<p>  var current_dict = "eng";
  var dicts = {};</p>

<p>  var is_array = function (obj) {</p>

<pre><code>return Object.prototype.toString.call(obj) === '[object Array]';
</code></pre>

<p>  };
  var set_lang = function (lang_code) {</p>

<pre><code>current_dict = lang_code;
</code></pre>

<p>  };
  var dict = function (lang_code, dict) {</p>

<pre><code>dicts[lang_code] = dict;
set_lang(lang_code);
</code></pre>

<p>  };
  var get_translation = function (key, number) {</p>

<pre><code>var isPlural = number != undefined &amp;&amp; number != 1;
var dict = dicts[current_dict];
var entry = dict == undefined ? undefined : dict[key];
var val = null;
if (is_array(entry)) {
  val = isPlural &amp;&amp; entry[1] != undefined ? entry[1] : entry[0];
} else {
  val = entry;
}
return val == null ? key : val;
</code></pre>

<p>  };</p>

<p>  return {</p>

<pre><code>dict: dict,
_: get_translation,
get_current_lang: function () {
  return current_dict;
}
</code></pre>

<p>  };</p>

<p>})();
```</p>

<p>And when you want to grab a string from the language dictionary, just call:</p>

<p><code>javascript
lang._("English String")
</code></p>

<h2>Plurals</h2>

<p>Note that the lang object implementation also allows for storage of a plural form of the translated word.  In practice, it was decided not to store our resource bundles in a parallel format.  Still, you provided data to the lang.dict() populating function that looked like this:</p>

<p><code>json
{ "Result": ["Resultado", "Resultados"] }
</code></p>

<p>And then got the translation like this:</p>

<p><code>javascript
lang._("Result", results.length)
</code></p>

<p>If it had a plural form, it would use it, falling back to the singular (1st) form.</p>

<h2>Thoughts</h2>

<p>So, what are the pros and cons here?  The main design issue that I felt created a bit of give and take was the keying of the strings by the English word.  The pro: If the string doesn't exist, the intelligible English string is shown in its place.  The con: It's less reliable and more brittle because you have to be able to control and escape properly the text that appears in the key.  What alternate solutions might you create?</p>

<h2>Update: RequireJs</h2>

<p>Or if you're using some sweet new Javascript tech, check out <code>this article on i18n in RequireJs &lt;http://rockycode.com/blog/i18n-strings-requirejs/&gt;</code>_.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XQuery Browser Language Detection]]></title>
    <link href="http://jaketrent.com/post/xquery-browser-language-detection/"/>
    <updated>2011-05-06T14:07:00-06:00</updated>
    <id>http://jaketrent.com/post/xquery-browser-language-detection</id>
    <content type="html"><![CDATA[<p>If you've created an internationalized website lately, you've probably implemented some sort of language chooser widget in your site ui to allow your users to indicate which language they would like to see content displayed in.  What I often forget is that the user may have already made this indication previous to visiting your site, and you might be like to think about respecting their previously indicated preference.</p>

<!--more-->


<p>Within the browser, a user can store their preferred language.  The w3c has a <a href="http://www.w3.org/International/questions/qa-lang-priorities#changing">nice browser list</a> to give some terse instructions on how to set your language in your browser.</p>

<p>Your app might read the browser preference differently, but at least one component is consistent.  Your browser is going to pass an <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">HTTP header</a> called "Accept-Language" to your app.  In a recent app, I read this using XQuery:</p>

<p><code>
xdmp:get-request-header("Accept-Language")
</code>
That's going to return a string something like this one, which is mine:</p>

<p><code>
en-US,en;q=0.8
</code></p>

<p>This is a comma-delimited list of 2-letter <a href="http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">language codes &lt;http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes><code>_ and 2-letter</code>locale codes</a>, informally "language-locale".</p>

<p>The "q=#" describes the quality of the language.  The higher, the quality, the more preferred.  Notice that in my header, "en-US", American English, does not have a "q=" attribute.  The lack of "q=" indicates a default, actually the highest preference, of 1.0.</p>

<p>There's also a Content-Language header, that I suppose you could use if you were making a differentiation for what language the actual content was using compared to the site chrome.  But, as far as I can tell, this is used less.  Even less by myself.  (Never.)</p>

<p>Here's a full XQuery implementation for MarkLogic that will read the header and parse out the preferred language.  In my implementation, I don't care about the locale, so I'm paying attention only to the language code.  The regex used is an adjustment of <a href="http://www.thefutureoftheweb.com/blog/use-accept-language-header">this original php regex</a>:</p>

<p>```
xquery version "1.0-ml";</p>

<p>declare option xdmp:mapping "false";</p>

<p>declare function local:get-browser-lang() as xs:string? {
  let $header := xdmp:get-request-header("Accept-Language")
  return if (fn:exists($header)) then</p>

<pre><code>local:get-top-hit-lang($header)
</code></pre>

<p>  else</p>

<pre><code>()
</code></pre>

<p>};</p>

<p>declare private function local:get-top-hit-lang($header as xs:string) as xs:string? {
  let $langs :=</p>

<pre><code>for $entry in fn:tokenize(local:parse-header($header), ",")
let $data := fn:tokenize($entry, "q=")
let $quality := $data[2]
order by
  if (fn:exists($quality) and fn:string-length($quality) gt 0) then
    xs:float($quality)
  else
    xs:float(1.0)
  descending
return $data[1]
</code></pre>

<p>  return $langs[1]
};</p>

<p>declare private function local:parse-header($header as xs:string) as xs:string {
  let $regex := "(([a-z]{1,8})(-[a-z]{1,8})?)\s<em>(;\s</em>q\s<em>=\s</em>(1|0.[0-9]+))?"
  let $flags := "i"
  let $format := "$2q=$5"
  return fn:replace(fn:lower-case($header), $regex, $format)
};</p>

<p>local:get-browser-lang()
```</p>

<p>This implementation just takes the top language, no matter what.  You might want to check to see if your site actually supports the language before picking from the browser preference.  While you're looping through the list of acceptable languages in get-top-hit-lang(), you could add a where clause to check for support.</p>

<p>Do you find that the sites you visit respect this header?</p>

<h2>Update</h2>

<p>Here's an updated version of the code that respects secondary language selections as well (not just first choice):</p>

<p>```
xquery version "1.0-ml";</p>

<p>declare option xdmp:mapping "false";</p>

<p>declare function local:get-browser-lang() as xs:string? {
  let $header := xdmp:get-request-header("Accept-Language")
  return if (fn:exists($header)) then</p>

<pre><code>local:get-top-supported-lang(local:get-browser-langs($header), ("en", "es", "it"))
</code></pre>

<p>  else</p>

<pre><code>()
</code></pre>

<p>};</p>

<p>declare function local:get-top-supported-lang($ordered-langs as xs:string<em>, $translations as xs:string</em>) as xs:string? {
  if (fn:empty($ordered-langs)) then</p>

<pre><code>()
</code></pre>

<p>  else</p>

<pre><code>let $lang := $ordered-langs[1]
return if ($lang = $translations) then
  $lang
else
  local:get-top-supported-lang(fn:subsequence($ordered-langs, 2), $translations)
</code></pre>

<p>};</p>

<p>declare private function local:get-browser-langs($header as xs:string) as xs:string* {
  let $langs :=</p>

<pre><code>for $entry in fn:tokenize(local:parse-header($header), ",")
let $data := fn:tokenize($entry, "q=")
let $quality := $data[2]
order by
  if (fn:exists($quality) and fn:string-length($quality) gt 0) then
</code></pre>

<p>  xs:float($quality)</p>

<pre><code>  else
</code></pre>

<p>  xs:float(1.0)</p>

<pre><code>  descending
return $data[1]
</code></pre>

<p>  return $langs
};</p>

<p>declare private function local:parse-header($header as xs:string) as xs:string {
  let $regex := "(([a-z]{1,8})(-[a-z]{1,8})?)\s<em>(;\s</em>q\s<em>=\s</em>(1|0.[0-9]+))?"
  let $flags := "i"
  let $format := "$2q=$5"
  return fn:replace(fn:lower-case($header), $regex, $format)
};</p>

<p>local:get-browser-lang()
```</p>
]]></content>
  </entry>
  
</feed>
