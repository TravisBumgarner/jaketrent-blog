<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: encryption | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/encryption/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2014-12-26T10:42:47-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Setup Public/Private Key]]></title>
    <link href="http://jaketrent.com/post/setup-publicprivate-key/"/>
    <updated>2012-07-19T14:14:00-06:00</updated>
    <id>http://jaketrent.com/post/setup-publicprivate-key</id>
    <content type="html"><![CDATA[<p>When you connect to a remote server, you're connecting over ssh or scp or a similar protocol.  In each case, you may have to provide some authentication credentials to prove you are who you say you are.  This can come in the form of a user/password combo, but if you're connecting a lot or if you're trying to setup a non-interactive connection, this can become either really monotonous or really problematic.  Public/private keys will come to our rescue, and we'll never need to enter our password again.</p>

<!--more-->


<p>```bash</p>

<blockquote><p>ssh-keygen
```</p></blockquote>

<p>You can, but don't need to protect your private key with a passphrase.  It is private, after all.  The default names are:</p>

<ul>
<li>Private: id_rsa</li>
<li>Public: id_rsa.pub</li>
</ul>


<p>Now you need to share your public key with the remote server:</p>

<p>```bash</p>

<blockquote><p>scp ~/.ssh/id_rsa.pub myUsername@remoteServer:
```</p></blockquote>

<p>The trailing colon will separate your hostname from the destination path and drop it in your default/home directory on the server.  Now, get into the remote server for the last time using that antiquated password of yours:</p>

<p>```bash</p>

<blockquote><p>ssh myUsername@remoteServer
```</p></blockquote>

<p>Once here, we need to put the public key in a file that will be used for incoming connections:</p>

<p>```bash</p>

<blockquote><p>mkdir ~/.ssh
mv ~/id_rsa.pub ~/.ssh/authorized_keys
```</p></blockquote>

<p>And make sure that the permissions are locked down for security reasons:</p>

<p>```bash</p>

<blockquote><p>cd ~/.ssh
chmod 700 .
chmod 600 id_rsa.pub
```</p></blockquote>

<p>Jump back to your local box and prep your private key for your next ssh/scp connection:</p>

<p>```bash</p>

<blockquote><p>eval <code>ssh-agent</code>
ssh-add ~/.ssh/id_rsa
```</p></blockquote>

<p>Note that we're adding our private key only.  If you had a passphrase on your private key, you'll be prompted for it at this point.  Voila!  You're next connection to that remote server should not require a password.  Try it!:</p>

<p>```bash</p>

<blockquote><p>ssh myUsername@remoteServer
```</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Encrypt your IMs in Pidgin]]></title>
    <link href="http://jaketrent.com/post/encrypt-your-ims-pidgin/"/>
    <updated>2011-04-20T08:36:00-06:00</updated>
    <id>http://jaketrent.com/post/encrypt-your-ims-pidgin</id>
    <content type="html"><![CDATA[<p>Around the office, when someone security-minded finds out that I instant message (IM) over Pidgin (using Google Talk's service), there tends to be wailing and gnashing of teeth, because I am chatting in clear text over the wire.  I am encouraged to use a clunky, Windows-only, proprietary, corporate, different tool that is for internal talk with internal people.  "It's secure."  "It's encrypted," they say.  I never though I said too much of worth over chat, and what was occasionally awesome was well-encoded in l33t.  But, now my friend Dean teaches me the goodness of encrypting your IMs in Pidgin.</p>

<!--more-->


<p>First, install Pidgin and the pidgin-encryption plugin.  For Debian'ites, it's easy:</p>

<p><code>bash
sudo apt-get install pidgin pidgin-encryption
</code></p>

<p>For users who like to download their own binaries from the web, go to the <a href="http://pidgin-encrypt.sourceforge.net/">pidgin-encryption site</a>.</p>

<p>Once you install, start up <a href="http://www.pidgin.im/">Pidgin</a> awesomely in <a href="http://do.davebsd.com/">gnome-do</a>:</p>

<p><img src="https://lh4.googleusercontent.com/_mA-9kCcx0bs/Ta7_wER1voI/AAAAAAAAAB8/FupSAZdUz0c/s800/PidginGnomeDo.png" alt="image" /></p>

<p>On the Pidgin Buddy, go to Tools > Plugins, and enable the Pidgin-Encryption plugin:</p>

<p><img src="https://lh3.googleusercontent.com/_mA-9kCcx0bs/Ta7_wur-zRI/AAAAAAAAACI/160M7IL5Ajs/s800/PidginPlugin.png" alt="image" /></p>

<p>Next, inform Pidgin that you want to start using encryption whilst chatting with someone who also has their chats through Pidgin encrypted.  In your chat window, there's a new padlock icon on the top menu bar.  Click it and "Enable Encryption":</p>

<p><img src="https://lh6.googleusercontent.com/_mA-9kCcx0bs/Ta8R2IMyHNI/AAAAAAAAACs/RAAczsPJFkI/s800/PidginEnableEncryption.png" alt="image" /></p>

<p>Once you start chatting with someone you'll both have to accept the public key that the other person is sending with their chats:</p>

<p><img src="https://lh5.googleusercontent.com/_mA-9kCcx0bs/Ta8BbyPeIrI/AAAAAAAAACU/G9hf5dV0ObA/s800/PidginEncrypt.png" alt="image" /></p>

<p>Finally, if you don't want to accept keys and do the hand shake every time, you can enable encryption on every chat with that person.  Go to your buddy list, find the person on the list, right click on them, and select "Turn Auto-Encrypt On":</p>

<p><img src="https://lh6.googleusercontent.com/_mA-9kCcx0bs/Ta7_wMsvbKI/AAAAAAAAACA/dSIeOT7_QnI/s800/PidginAlwaysOn.png" alt="image" /></p>

<p>Well, now you can chat freely with the best of them.  Open tool.  Open protocol.  Linux support.  Google contact list.  All for the low cost of zero.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AES Encryption Odyssey in Java with Bouncy Castle]]></title>
    <link href="http://jaketrent.com/post/aes-encryption-java-bouncy-castle/"/>
    <updated>2011-04-12T15:24:00-06:00</updated>
    <id>http://jaketrent.com/post/aes-encryption-java-bouncy-castle</id>
    <content type="html"><![CDATA[<p>Recently, I've been working on a project where I've tried to use AES encryption for the first time.  I didn't have to implement it myself, thank goodness, but I still ran into a few snags.  Perhaps you can avoid my pitfalls and rise to new greatness on the peaks of glory and fortitude!  This article title sounds like a laundry detergent.</p>

<!--more-->


<h2>Why Java</h2>

<p>We do a fair amount of our development on MarkLogic lately.  Our app right now happens to be heaped in XQuery.  When we learned that we had to interface with an external system passing AES-encrypted payloads, I did a quick looksy into what was needed for AES encryption.  Turns out that AES is rather complicated to implement.  So easy, even a <a href="http://www.bouncycastle.org/">stick figure &lt;http://www.moserware.com/2009/09/stick-figure-guide-to-advanced.html><code>_ can do it.  :)  If you want a nice (but dry) higher level overview of AES,</code>Patrick Townsend &lt;http://www.youtube.com/watch?v=Xna-qBWgn90><code>_ can provide.  But the bottom line was that it couldn't be implemented in MarkLogic because the only hash function we had available was</code>xdmp:md5 &lt;http://developer.marklogic.com/pubs/4.2/apidocs/Ext-1.html#xdmp:md5><code>_.  And Java already had a nice AES encryption provider,</code>Bouncy Castle</a>.  So, it was Java Webservice time...</p>

<h2>Illegal Key Size Jar Fix</h2>

<p>The first issue I ran into was this exception:</p>

<p><code>java
java.security.InvalidKeyException:Illegal Key Size
</code></p>

<p>That is solved in an earlier <a href="http://rockycode.com/blog/java-encryption-illegal-key-size/">article about JCE jars</a>.</p>

<p>Finally, I was able to encrypt my payload using AES-192 but then when I sentthe data to the receiver, they weren't able to decrypt it.  Something was wrong again.</p>

<h2>Classpath Resource or Not?  Not!</h2>

<p>First, I found out that when I put my key in as a classpath resource, the key was changed at build time.  When it got deployed to target it went from 40 bytes to 69 bytes:</p>

<p><code>bash
-rw-r--r-- 1 me me 69 2011-04-12 08:05 after.key
-rw-r--r-- 1 me me 40 2011-04-12 08:05 before.key
</code></p>

<p>So, leave the key outside the classpath.  And put it in WEB-INF if you don't want it accessible over the network.  Then use the servlet context to load the file.  I happen to be in Spring3 land:</p>

<p>```java
import javax.servlet.ServletContext;</p>

<p>// ..</p>

<p>@Autowired
ServletContext servletContext;</p>

<p>private File getKeyFile() {
  String path = servletContext.getRealPath("/WEB-INF/key");
  return new File(path);
}
```</p>

<h2>Encrypted Payload on the Wire(shark)</h2>

<p>But, it turned out that the receiver still couldn't decrypt what I encrypted, even though we were fairly certain that our keys were either the same or generated in the same fashion (same passphrase, etc).  So, I ran some code provided by another app that encrypts data to send to the same receiver.  I set the debugger so I could grab their generated cipher text and then send it myself.  When I did this, it still didn't work!  Then I busted out Wireshark:</p>

<p><code>bash
sudo apt-get install wireshark
</code></p>

<p>(I love package managers!)  And I found that the cipher text going over the wire was different than what I had grabbed in the debugger.  When comparing the two, I found the length of the payload over the wire was longer than in the debugger.  For instance, the char "+2" was changed to "%2B2".  Different encoding!  So, then I made sure that I was using the proper encoding:</p>

<p>```java
import java.net.URLEncoder;</p>

<p>public String encrypt() {
  // .. encryption impl
  return URLEncoder.encode(cipherText, "UTF-8");
}
```</p>

<h2>ServletContext in a WAR deployment</h2>

<p>Finally!  I was able to pass an encrypted payload to the receiver in my local environment.  But when I deployed to Tomcat as a war file, suddently my key was unable to be found in WEB-INF.  I discovered that:</p>

<p><code>java
servletContext.getRealPath("/WEB-INF/key")
</code></p>

<p>Doesn't work in a war deploy.  From the Javadoc:</p>

<blockquote><p> The real path returned will be in a form appropriate to the computer and operating system on which the servlet container is running, including the proper path separators. This method returns <code>null</code> if the servlet container cannot translate the virtual path to a real path for any reason (such as when the content is being made available from a <code>.war</code> archive</p></blockquote>

<p>So, the Tomcat deploy had to be adjusted via the server.xml:</p>

<p><code>xml
&lt;Host name="localhost" appBase="webapps" unpackWARs="true"
</code></p>

<p>Once the WAR was exploded in the webapps directory, the key file was findable again.  But now I begin to learn that it's best to put such secret keys in a <a href="http://download.oracle.com/javase/6/docs/api/java/security/KeyStore.html">KeyStore</a>.</p>

<h2>Validate the BouncyCastle Provider</h2>

<p>Still the battle rages.  Now there was a new champion of evil to vanquish... Now that I could actually find the key and start encrypting in the deployed environment, this beast reared its ugly head:</p>

<p><code>java
java.security.NoSuchAlgorithmException: PBEWithSHAAndTwofish-CBC SecretKeyFactory not available
</code></p>

<p>Lame!  Googling this exception landed us on some sweet <a href="http://sce.uhcl.edu/yang/teaching/JDK_JCE_environment_Configuration.htm">BouncyCastle setup tutorials</a>.  Apparently your BouncyCastle version needs to match your JDK version.  So, we made the necessary adjustments in our pom:</p>

<p><code>xml
&lt;dependency&gt;
  &lt;groupId&gt;bouncycastle&lt;/groupId&gt;
  &lt;artifactId&gt;bcprov-jdk16&lt;/artifactId&gt;
  &lt;version&gt;140&lt;/version&gt;
&lt;/dependency&gt;
</code></p>

<p>(There are more recent versions that might be in your <a href="http://repo2.maven.org/maven2/org/bouncycastle/">Maven repo</a>.)</p>

<p>Still it wasn't enough.  The exception persisted and so did we.  Hours later our energy wained, but Spencer came to reinforce us and we were able to hook up a remote debugger to our deployed app.  We were obviously adding the BouncyCastle provider in our code, so that looked good:</p>

<p><code>java
Security.addProvider(new BouncyCastleProvider());
</code></p>

<p>But when we went to use it:</p>

<p><code>java
factory = SecretKeyFactory.getInstance("PBEWithSHAAndTwofish-CBC");
</code></p>

<p>It blew some serious chunks.  On our remote debugger, when we tried to retrieve the BouncyCastle provider ourself:</p>

<p><code>java
SecretKeyFactory.getInstance("PBEWithSHAAndTwofish-CBC", new BouncyCastleProvider())
</code></p>

<p>We got a new clue:</p>

<p>```java
java.lang.SecurityException: JCE cannot authenticate the provider BC</p>

<p>  .. caused by ..</p>

<p>  java.util.jar.JarException: Cannot parse file
```</p>

<p>The jar was the one deployed in WEB-INF/lib.  Well, somehow that clicked in our good friend, Spencer's, mind because he immediately changed our deployment to Tomcat so that instead of the bcprov-jdk16-140.jar being deployed to WEB-INF/lib, he deployed it to <TOMCAT_HOME>/applib.  The apparent difference is that when the jar is in applib, it's loaded by Tomcat's class loader.  When it's in WEB-INF/lib, it's loaded by the app's class loader, which apparently wasn't cutting it.<br/>
To get our BouncyCastle jar not to deploy to WEB-INF/lib, we had to change our dependency:</p>

<p><code>xml
&lt;dependency&gt;
  &lt;groupId&gt;bouncycastle&lt;/groupId&gt;
  &lt;artifactId&gt;bcprov-jdk16&lt;/artifactId&gt;
  &lt;version&gt;140&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></p>

<p>From the <a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">Maven Docs</a>:</p>

<p>  This is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope provided because the web container provides those classes. This scope is only available on the compilation and test classpath, and is not transitive.</p>

<p>Since we are deploying bcprov-jdk16-140.jar to applib by another means, this scope is perfect for us.  It also seems that there are other ways around this particular problem, such as defining BouncyCastle as a provider on your JVM via editing the <a href="http://www.randombugs.com/java/javalangsecurityexception-jce-authenticate-provider-bc.html">security.provider</a> file.</p>

<p>Well, now it works.  It was a serious adventure -- even an odyssey.  I need a nap.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Encryption - Illegal Key Size]]></title>
    <link href="http://jaketrent.com/post/java-encryption-illegal-key-size/"/>
    <updated>2011-04-04T11:07:00-06:00</updated>
    <id>http://jaketrent.com/post/java-encryption-illegal-key-size</id>
    <content type="html"><![CDATA[<p>By default, Java has a limit on the length of your encryption key.  The limit, by default 128-bit, seems a little small and dated.  So, let's break through that glass ceiling!  With the hammer of Thor!</p>

<!--more-->


<p>I'm currently trying to do 192-bit AES encryption.  So, I need to do a few things to get around this nasty exception I keep getting:</p>

<p><code>java
java.security.InvalidKeyException:Illegal Key Size
</code></p>

<p>Go to the Empire's <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">download page</a> and surf to the bottom and look for the "Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 6" (since I'm on Java 6).  Download that .zip of power and unzip it.</p>

<p>Finally, copy two files:</p>

<ul>
<li>local_policy.jar</li>
<li>US_export_policy.jar</li>
</ul>


<p>Into JAVA_HOME/jre/lib/security/</p>

<p>For example:</p>

<p><code>bash
sudo cp local_policy.jar US_export_policy.jar /usr/lib/jvm/java-6-sun/jre/lib/security/
</code></p>

<p>And voila!  Run your code again to do encryption against larger than 128-bit keys, and your illegal key size message should have vanished like the icebergs.</p>
]]></content>
  </entry>
  
</feed>
