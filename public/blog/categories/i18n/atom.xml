<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: i18n | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/i18n/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-08-22T15:56:20-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[i18n Strings in RequireJs]]></title>
    <link href="http://jaketrent.com/post/i18n-strings-requirejs/"/>
    <updated>2012-01-10T15:14:00-07:00</updated>
    <id>http://jaketrent.com/post/i18n-strings-requirejs</id>
    <content type="html"><![CDATA[<p>If you have to store your text strings for internationalization (i18n) on the server, that's <a href="http://rockycode.com/blog/i18n-strings-javascript/">one thing</a>.  But, if you can store them in Javascript, you might think about using RequireJs and its i18n plugin, because it makes it nice and easy.</p>

<!--more-->


<h2>Get the Plugin</h2>

<p>RequireJs is a single <a href="http://requirejs.org/docs/download.html">download</a>.  It's an AMD-style module loader.  And it rocks.  Especially if you dig those little arrows <img src="http://requirejs.org/i/arrow.png" alt="arrow img" />!</p>

<p>The <a href="http://requirejs.org/docs/api.html#i18n">i18n plugin</a> is another .js file to <a href="http://requirejs.org/docs/download.html#i18n">download</a>.</p>

<h2>Specify your Strings</h2>

<p>The i18n uses the philosophy that you have a default/fallback language specified that usually the entire set of strings that your app will display.  Then, you can specify a set of those strings in another language or even partially implement them.  For instance, if my default language is English and I have 10 strings total but then I only specify 6 of those strings in the Spanish version of the bundle, then English will be used for the remaining 4 as the fallback language.</p>

<p>Your directory structure should look something like this:</p>

<p>```bash
js/
  nls/</p>

<pre><code>spa/
  str.js
str.js
</code></pre>

<p>  main.js
  require.js
  i18n.js
```</p>

<p>The important thing is that there is a subdirectory as sibling to main.js, your main Require module, that is named 'nls'.  This is what the plugin looks for by default.  The names of the 'str.js' files don't matter.  In fact you can have as many and name them things with meaning in to app if you'd like.</p>

<p>Here's an example bundle of the English/default bundle:</p>

<p>```javascript
define({
  'root': {</p>

<pre><code>welcome: 'Welcome!',
eng_only_idiom: 'You have got to be pulling on my leg!'
</code></pre>

<p>  },
  'spa': true
});
```</p>

<p>In the <code>root</code> property, we default an object with string keys and the English text that we want associated with that key.  The name 'root' specifies that this is the default set of strings.</p>

<p>Below, we list a new property for each language code that our app supports (or doesn't if it's listed as false, but I just leave them off if they're false).  You can use whatever language code you care to use.  On our app, the server is feeding us a three-letter language code with no locale.  Browsers will feed you a two-letter code, with locale if available (eg, 'es-mx').</p>

<p>The Spanish bundle would look something like this:</p>

<p><code>javascript
define({
  welcome: '¡bienvenido'
});
</code></p>

<p>Note that only the <code>welcome</code> string was implemented.  English only things or unsupported or not-yet translated strings can just remain unmentioned in the language bundle.</p>

<h2>Specify RequireJs Locale</h2>

<p>In our main Require module, we want to specify which is the current language so the plugin knows which language bundle to look up and use.  That might look like this:</p>

<p><code>javascript
require({
  locale: lang
}, ['myModule'], function (myModule) {
  var myMod = new myModule()
  myMod.doCoolStuff();
});
</code></p>

<p>We haven't used the language string yet.  We've only specified the current user's language.  In my case, with the language code being provided by the server, <code>lang</code> is a global js var that gets rendered on the html page from the server.  You could interrogate the browser langugage here instead via Javascript if you'd like.</p>

<h2>Use i18n Strings in a Require Module</h2>

<p>We know what strings we need to have translated.  We know our current user's language.  And now finally we need to use our bundles.  Here's how to import the bundle via the i18n plugin into your require module:</p>

<p>```javascript
define(['i18n!nls/str'], function(str) {
  return {</p>

<pre><code>doCoolStuff: function () {
  alert(str.welcome);
}
</code></pre>

<p>  }
});
```</p>

<p>Note that we require as a dependency the main/English <code>str.js</code>.  And because we import it with the 'i18n!' prefix, it will be read as a language bundle and the appropriate language's bundle will be used.  So if the require <code>locale</code> was set to 'spa', then we would see '¡bienvenido' alerted to our screen.  Pretty dang exciting.</p>

<h2>Bonus:  With Handlebars!</h2>

<p>But you wouldn't normally just blast out strings via your Javascript code.  At least, if you love your sanity, you'll stop using string concatenation and a Javascript-based templating language.  There are many out there, but one that I have recent success with is <a href="http://handlebarsjs.com/">HandlebarsJs</a>.  It's a superset of mustache -- based on the same syntax but with built-in helpers and ability to extend with other custom helper functions.</p>

<p>So, if we were using a Handlebars template to blast our i18n strings plus markup to the DOM, our handlebars template could look like this:</p>

<p>{% raw %}
```javascript</p>

<h1>{{ str.welcome }}</h1>


<!-- you know, something super huge and inviting -->


<p>```
{% endraw %}</p>

<p>And you could import it and use it in your module:</p>

<p>```javascript
define(['i18n!nls/str', 'text!template'], function (str, myTmpl) {
  return {</p>

<pre><code>doCoolStuff: function () {
  var compiledTmpl = Handlebars.compile(myTmpl);
  document.body.appendChild(compiledTmpl({ str: str }));
});
</code></pre>

<p>  }
});
```</p>

<p>Note that I'm making a couple leaps here:  Have the RequireJs <a href="http://requirejs.org/docs/api.html#text">text plugin</a> available, and have handlebars.js available.</p>

<p>Compile the template with handlebars and then pass in the <code>str</code> module as a property called <code>str</code> (or whatever) to the template and then just access it like the Javascript objec that it is within the template, using <code>str.welcome</code> or <code>str.eng_only_idiom</code> or whatever other strings you invent in that wild, internationalized mind of yours.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I18n Strings in Javascript]]></title>
    <link href="http://jaketrent.com/post/i18n-strings-javascript/"/>
    <updated>2011-08-23T13:17:00-06:00</updated>
    <id>http://jaketrent.com/post/i18n-strings-javascript</id>
    <content type="html"><![CDATA[<p>I've seen a number of different ways that internationalized strings get put into Javascript code.  Of all of them, I kind of like just bundling the resource bundle of key value pairs in Javascript files themselves, one for each language or something close to that.  But, in a recent project, there were a few other constraints, so we did it another way.</p>

<!--more-->


<h2>The Situation</h2>

<ul>
<li>We're using MarkLogic on the backend -- our data is stored in xml.  Our server-side code is XQuery.</li>
<li>Some of these strings are needed on the server side as well, so storing them all on the client in .js files wasn't going to cut it.</li>
<li>We wanted to get all of the strings into the same place to make the list more manageable to update and maintain.</li>
</ul>


<p>So, now there are two parts to getting internationalized strings available in the front-end code: The data transform on the backend and the strings made available on the front-end.</p>

<h2>The Backend Transform</h2>

<p>The resource bundle data looks like this:</p>

<p>```xml
<resource-bundle xml:lang="spa">
  <resource key="my.key.name"></p>

<pre><code>&lt;value&gt;Translated String&lt;/value&gt;
</code></pre>

<p>  </resource></p>

<!-- ... more ... -->


<p></resource-bundle>
```</p>

<p>The transform a la:</p>

<p>```
declare function get-lang-dict($bundle-collection as xs:string, $lang as xs:string?, $keys as xs:string<em>) as xs:string</em> {
  let $eng :=</p>

<pre><code>if (fn:exists($keys)) then
  get-resource-bundle($bundle-collection, "eng")/resource[@key = $keys]
else
  get-resource-bundle($bundle-collection, "eng")/resource
</code></pre>

<p>  let $translations :=</p>

<pre><code>if (fn:exists($keys)) then
  get-resource-bundle($bundle-collection, $lang)/resource[@key = $keys]
else
  get-resource-bundle($bundle-collection, $lang)/resource
</code></pre>

<p>  let $max := fn:count($translations)
  for $translation at $i in $translations
  let $engTxt := $eng[@key eq $translation/@key]/value/text()
  let $key := if (fn:exists($engTxt)) then</p>

<pre><code>json:escape(fn:normalize-space(fn:string($engTxt[1])))
</code></pre>

<p>  else</p>

<pre><code>fn:string($translation/@key)
</code></pre>

<p>  return fn:concat("'", $key, "': '", json:escape(xdmp:quote($translation/value/text())), "'",</p>

<pre><code>if ($i eq $max) then () else ",")
</code></pre>

<p>};</p>

<p>declare function get-resource-bundle($bundle-collection as xs:string, $lang as xs:string) as element()* {
  fn:collection($resource-collection-uri)/resource-bundle[@xml:lang eq $lang]
};
```</p>

<p>Now we have our xml transformed into a sequence of xs:string, each a json object where the English text is the key and the language text is the value, like this:</p>

<p><code>json
{ "English String": "Translated String" }
</code></p>

<p>The XQuery expression that renders the html page includes a call to populate the Javascript "lang" object with the json:</p>

<p>{% raw %}
```
declare function lang-dictionary($lang as xs:string?) as element(script) {
  <script type="text/javascript"></p>

<pre><code>jQuery(document).ready(function(){{
  lang.dict("{$lang}", {{
    {get-lang-dict("bundle-collection", "spa", ("keys", "if", "any"))}
  }});
}});
</code></pre>

<p>  </script>
};
```
{% endraw %}</p>

<p>Note that if you provide a pre-known set of i18n string $keys to the get-lang-dict() function, it will only add those resources to the dictionary.  Otherwsie, all the resources in your bundle are added.</p>

<h2>Front-end Usage</h2>

<p>The lang object that stores the dictionary of translated strings is like so:</p>

<p>```javascript
var lang = (function () {</p>

<p>  var current_dict = "eng";
  var dicts = {};</p>

<p>  var is_array = function (obj) {</p>

<pre><code>return Object.prototype.toString.call(obj) === '[object Array]';
</code></pre>

<p>  };
  var set_lang = function (lang_code) {</p>

<pre><code>current_dict = lang_code;
</code></pre>

<p>  };
  var dict = function (lang_code, dict) {</p>

<pre><code>dicts[lang_code] = dict;
set_lang(lang_code);
</code></pre>

<p>  };
  var get_translation = function (key, number) {</p>

<pre><code>var isPlural = number != undefined &amp;&amp; number != 1;
var dict = dicts[current_dict];
var entry = dict == undefined ? undefined : dict[key];
var val = null;
if (is_array(entry)) {
  val = isPlural &amp;&amp; entry[1] != undefined ? entry[1] : entry[0];
} else {
  val = entry;
}
return val == null ? key : val;
</code></pre>

<p>  };</p>

<p>  return {</p>

<pre><code>dict: dict,
_: get_translation,
get_current_lang: function () {
  return current_dict;
}
</code></pre>

<p>  };</p>

<p>})();
```</p>

<p>And when you want to grab a string from the language dictionary, just call:</p>

<p><code>javascript
lang._("English String")
</code></p>

<h2>Plurals</h2>

<p>Note that the lang object implementation also allows for storage of a plural form of the translated word.  In practice, it was decided not to store our resource bundles in a parallel format.  Still, you provided data to the lang.dict() populating function that looked like this:</p>

<p><code>json
{ "Result": ["Resultado", "Resultados"] }
</code></p>

<p>And then got the translation like this:</p>

<p><code>javascript
lang._("Result", results.length)
</code></p>

<p>If it had a plural form, it would use it, falling back to the singular (1st) form.</p>

<h2>Thoughts</h2>

<p>So, what are the pros and cons here?  The main design issue that I felt created a bit of give and take was the keying of the strings by the English word.  The pro: If the string doesn't exist, the intelligible English string is shown in its place.  The con: It's less reliable and more brittle because you have to be able to control and escape properly the text that appears in the key.  What alternate solutions might you create?</p>

<h2>Update: RequireJs</h2>

<p>Or if you're using some sweet new Javascript tech, check out <code>this article on i18n in RequireJs &lt;http://rockycode.com/blog/i18n-strings-requirejs/&gt;</code>_.</p>
]]></content>
  </entry>
  
</feed>
