<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: bash | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/bash/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2014-12-26T08:33:30-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pipe stdout to SocketIO]]></title>
    <link href="http://jaketrent.com/post/pipe-stdout-socketio/"/>
    <updated>2012-07-20T13:32:00-06:00</updated>
    <id>http://jaketrent.com/post/pipe-stdout-socketio</id>
    <content type="html"><![CDATA[<p>When you run a shell script or some other process from NodeJs and want to get the output in a stream to a client, you can redirect or pipe the output from the process that originally outputs to stdout into your socketio stream.</p>

<!--more-->


<p>First, setup socketio on your server as you normally would:</p>

<p><code>js
var io = require('socket.io').listen(80);
</code></p>

<pre><code>io.sockets.on('connection', function (socket) {
  runMyProcess(socket);
  socket.on('my other event', function (data) {
    console.log(data);
  });
});
</code></pre>

<p>Second, setup your process to run <a href="http://rockycode.com/blog/run-shell-script-nodejs/">using spawn</a>.  For instance:</p>

<p><code>js
var spawn = require('child_process').spawn;
var myProcess = spawn('sh', [ 'myShellScript.sh' ]);
</code></p>

<p>And setup your <code>myProcess</code> variable with the needed callbacks.  The 'data' callback is called whenever there is output from the process.  So, if you want to catch data from <code>stdout</code> and <code>stderr</code>, catch those and emit the data into your socketio stream, a la:</p>

<p><code>js
myProcess.stdout.setEncoding('utf-8');
myProcess.stdout.on('data', function (data) {
  socket.emit('process_data', data);
});
myProcess.stderr.setEncoding('utf-8');
myProcess.stderr.on('data', function (data) {
  socket.emit('process_data', data);
});
</code></p>

<p>An important note from <a href="http://nodejs.org/api/stream.html#stream_event_data">the docs</a> is that:</p>

<blockquote><p>The 'data' event emits either a Buffer (by default) or a string if setEncoding() was used.</p></blockquote>

<p>If I didn't set the encoding so strings were returned, they did not transfer well over socketio.  Well, there you have it.  You can now get output from child processes to stream through socketio.  In my case, I was wanting to show realtime output in a web client.  It's a fun combination of abilities that should produce interesting applications.  Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Run a Shell Script from NodeJs]]></title>
    <link href="http://jaketrent.com/post/run-shell-script-nodejs/"/>
    <updated>2012-07-20T12:58:00-06:00</updated>
    <id>http://jaketrent.com/post/run-shell-script-nodejs</id>
    <content type="html"><![CDATA[<p>NodeJs can do many things.  It can even run things that it can't do itself.  For instance, I have a shell script that I don't want to rewrite in Javascript, so I want my Node app to run the shell script.  No problemo.</p>

<!--more-->


<p>The <a href="http://nodejs.org/api/child_process.html">docs</a> indicate a number of ways you can kick off child processes.  In my case, I wanted to use <a href="http://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options"><code>spawn</code></a>.</p>

<p>Import the <code>child_process</code> library:</p>

<p><code>js
var spawn = require('child_process').spawn;
</code></p>

<p>Now you have <code>spawn</code> available to call.  Just send it the right stuff.  I have a <code>deploy.sh</code> script that I want to run.  The command I'll actually run is <code>sh</code>, and I'll pass the name of the script to it in the 2nd parameter.  I can also specify other options in the 3rd parameter.  For instance, I want this to execute in a certain directory and with certain commands available to it via the <code>PATH</code> variable.  And so:</p>

<p><code>js
var _ = require('underscore'); // for some utility goodness
var deploySh = spawn('sh', [ 'deploy.sh' ], {
  cwd: process.env.HOME + '/myProject',
  env:_.extend(process.env, { PATH: process.env.PATH + ':/usr/local/bin' })
});
</code></p>

<p>This will execute the shell script.  There are other callback events that you may/not want to set to grab the data that comes back from the process, such as 'data', 'end', or 'exit'.</p>

<p>Rock that!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find and Kill a Process on a Port]]></title>
    <link href="http://jaketrent.com/post/find-and-kill-process-port/"/>
    <updated>2012-06-20T09:49:00-06:00</updated>
    <id>http://jaketrent.com/post/find-and-kill-process-port</id>
    <content type="html"><![CDATA[<p>Have you ever tried to start up a local dev server and attach it to a port only to find that the port says it's already in use.  Here's a quick way to find those zombies and kill 'em good.</p>

<!--more-->


<h2>Server Startup Messages</h2>

<p>When you go to start your server, you get your annoying error message that just irks you.  If you're starting a Java server, it looks something like:</p>

<p><code>bash
java.net.BindException: Address already in use localhost:8080
</code></p>

<p>Or in node:</p>

<p><code>bash
Error: listen EADDRINUSE
</code></p>

<p>No matter the server, you're trying to start, there's something in your way, and it's going down.</p>

<h2>Finding the Perp</h2>

<p>Once you find him, he's toast.  Open your terminal and query the problem port:</p>

<pre><code>&gt; lsof -i tcp:8080
</code></pre>

<p>From the man file, lsof is:</p>

<blockquote><p>Lsof revision 4.84 lists on its standard output file information about files opened by processes</p></blockquote>

<p>And the -i is showing you Internet addresses:</p>

<blockquote><p>This option selects the listing of files any of whose Internet address matches the  address specified in i.  If no address is specified, this option selects the listing of all Internet and x.25 (HP-UX) network files.</p></blockquote>

<h2>Kill the process</h2>

<p>Running the <code>lsof</code> command should return something like:</p>

<pre><code>COMMAND  PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    7135 jtsnake   46u  IPv4 0xffffff801a349c00      0t0  TCP *:http-alt (LISTEN)
</code></pre>

<p>That <code>PID</code> is the identifier you were looking for.  Now, run a handy:</p>

<p>```bash</p>

<blockquote><p>kill 7135
```</p></blockquote>

<p>to put the thing out of its misery.</p>

<p>Just like a fire in the forest, now a new tree has a place to grow.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find django-admin.py]]></title>
    <link href="http://jaketrent.com/post/find-django-adminpy/"/>
    <updated>2009-09-03T07:49:00-06:00</updated>
    <id>http://jaketrent.com/post/find-django-adminpy</id>
    <content type="html"><![CDATA[<p>django-admin.py is a utility script that is used by django to start projects, etc.  Sometimes, it seems that it's available to me in the terminal.  At other times, it melts away, unavailable.  So, where is it, and how do I make it findable?</p>

<!--more-->


<p>django-admin.py is in the your site-packages/django/bin/ directory.  And that brings up another good point.  Where is your site-packages directory specifically?  You can find it with this command:</p>

<p><code>bash
python -c "from distutils.sysconfig import get_python_lib; print get_python_lib()"
</code></p>

<p>Once you find the site-packages directory, go to the bin/ subdirectory to find the django-admin.py.  You just need to put this in your path so that it's findable from wherever you need to use it.  Here's a possibility:</p>

<p><code>bash
cd /usr/local/bin/ &amp;&amp;
sudo ln -s [site-packages]/bin/django-admin.py django-admin.py
</code></p>
]]></content>
  </entry>
  
</feed>
