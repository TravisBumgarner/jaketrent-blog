<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testacular | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/testacular/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-09-27T10:41:57-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RequireJs Paths in Prod, Test, and Build]]></title>
    <link href="http://jaketrent.com/post/requirejs-paths-in-prod-test-build/"/>
    <updated>2012-12-07T11:18:00-07:00</updated>
    <id>http://jaketrent.com/post/requirejs-paths-in-prod-test-build</id>
    <content type="html"><![CDATA[<p>RequireJs makes dependency management on the client mostly better.  Once it's setup, it's nice.  Getting the patterns of your paths to work correctly can be difficult to setup, depending on the constraints of your system.  Making the same paths work in a prod, test, and build environment can be even more adventuresome.  In my case, there were a few extra hoops.  My scenario might not fully match yours, but perhaps you can apply this solution to your own needs.</p>

<p><img src="http://i.imgur.com/xZqm5.png" alt="Alt Text" /></p>

<!--more-->


<h2>Prod: Loading Modules From a Different Server</h2>

<p>Recently, we built a portal.  It contains a bunch of widgets that are served from domains different from the host page.  The portal requested these widget js files via <a href="http://requirejs.org/">RequireJs</a>.</p>

<p>Because the widgets live on other domains, those widgets' subdependencies needed a path that would be relative to that other widget domain and not the portal domain.  In order to accomplish this, widget dependencies were specified in this way:</p>

<p>{% codeblock lang:js %}
define(['./widgetDependency.js'], function (dep) {
  // my widget code
});
{% endcodeblock %}</p>

<p>The <code>.js</code> extension tells RequireJs to load the dependency <a href="https://github.com/jrburke/r.js/blob/2.1.1/require.js#L1521">as a URL</a>.  The <code>./</code> makes the URL relative to the widget domain.</p>

<h2>Test: RequireJs Paths in Testacular</h2>

<p>When you go to test your modules in a test environment, you may not want to load your modules as URLs.  Such was the case for me, <a href="http://jaketrent.com/post/test-requirejs-testacular/">running Testacular</a>, where the source code is requested into the context of the test server already.</p>

<p>In prod, I needed the <code>.js</code> extension.  But, in test I didn't want to load modules from URLs.  So, I need to make the test environment ignore the extension.  The solution?  Override the regular expression that checks for the extension in my test runner to be something that was never matched:</p>

<p>{% codeblock lang:js %}
require.jsExtRegExp = /<sup>pileOTest/;</sup>
{% endcodeblock %}</p>

<p>This allows RequireJs to load the module by module name.</p>

<h4>RequireJs Adds Double .js Extension</h4>

<p>It's getting better in the test environment, but we still haven't totally appeased RequireJs.  It turns out that when it loads a module by name, it still has to <a href="https://github.com/jrburke/r.js/blob/2.1.1/require.js#L1526">convert that name to a path</a>.</p>

<p>Given my constraints (widgets from another domain on a portal), my name actually includes a <code>.js</code> extension.  This isn't usually the case.  RequireJs doesn't test for this again (remember, we overrode the regex that did), so it just adds a <code>.js</code> extension on the end, creating two: <code>.js.js</code>.</p>

<p>But there is one final way to trick it out:  Add a '?' to the name.  This rule was meant to apply to URLs that represented dynamic scripts (and would thus take query strings) as opposed to static js files.  That's not why we'll add it, but it will help us nonetheless.</p>

<p>So now your module dependencies will look like this:</p>

<p>{% codeblock lang:js %}
define(['./widgetDependency.js?'], function (dep) {
  // my widget code
});
{% endcodeblock %}</p>

<p>And in your test environment they will load, and you will be happy.  Until...</p>

<h2>Build: Module Names for Optimization</h2>

<p>When you go to <a href="http://requirejs.org/docs/optimization.html#basics">optimize your RequireJs modules</a> you'll again need RequireJs to load your modules by module name instead of url.  If you don't, you'll get nice messages like:</p>

<p>```</p>

<blockquote><blockquote><p>Tracing dependencies for: MyModule
Cannot optimize network URL, skipping: nls/str.js?
Error: ENOENT, no such file or directory
'/Users/.../style.css?'
In module tree:</p>

<pre><code>MyModule
</code></pre>

<p>```</p></blockquote></blockquote>

<p>You may cry a little, but we're almost there.  Remember, your module dependency paths worked just fine in prod.  You only changed them to accommodate the test environment.  So, it's time to change them back when you optimize your module into one file for production use.</p>

<p>The <code>r.js</code> configuration in <code>app.build.js</code> includes an function called <code>onBuildRead()</code>'.  Call it to transform the code as it goes out the door for optimization.  We want to strip out the '?' question marks from our dependency arrays.  Stripping out all '?'s might be a bit too dangerous.  So, let's make a benign adjustment that will help us identify exactly what we're trying to strip out and replace our '?' string in our dependency paths with '?test', finally:</p>

<p>{% codeblock lang:js %}
define(['./widgetDependency.js?test'], function (dep) {
  // my widget code
});
{% endcodeblock %}</p>

<p>And <a href="https://github.com/jrburke/r.js/blob/2.1.1/build/example.build.js#L417">implement <code>onBuildRead</code></a> as:</p>

<p>{% codeblock lang:js %}
onBuildRead: function (moduleName, path, contents) {<br/>
  return contents.replace(/\?test/g, '');
}
{% endcodeblock %}</p>

<h4>"Shut off all the garbage smashers on the detention level!"</h4>

<p>Take a deep breath.  That was a little much to make all that work.  You have made your RequireJs paths happy in 3 contexts:</p>

<ol>
<li>In production, where modules are served from domains different from the host page and must be loaded by URL.</li>
<li>In test, where your modules must be loaded by module name.</li>
<li>In the optimization build, where modules must be loaded by module name.</li>
</ol>


<p>I fill like I've tricked out RequireJs a bit to make this work.  How could we adjust the solution to be more straightforward?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt and Testacular]]></title>
    <link href="http://jaketrent.com/post/grunt-and-testacular/"/>
    <updated>2012-11-06T17:05:00-07:00</updated>
    <id>http://jaketrent.com/post/grunt-and-testacular</id>
    <content type="html"><![CDATA[<p><a href="http://vojtajina.github.com/testacular/">Testacular</a> is a test runner for running browser tests.  Once you have it <a href="http://jaketrent.com/post/test-requirejs-testacular/">up and running</a>, you may want to integrate it with your <a href="http://gruntjs.com/">Grunt</a> build process.  This will allow Testacular to be started and your tests to be run from Grunt.</p>

<p><img src="http://i.imgur.com/zze56.jpg" alt="Grunt and Testacular" /></p>

<!--more-->


<h2>grunt-testacular</h2>

<p>Lucky for us, <a href="https://npmjs.org/package/grunt-testacular">Friedel Ziegelmayer</a> has created a nice little plugin, <a href="https://npmjs.org/package/grunt-testacular">grunt-testacular</a>.</p>

<p>To install:</p>

<pre><code>$ npm install grunt-testacular
</code></pre>

<p>Add the current version to your <code>package.json</code> for the future:</p>

<pre><code>"grunt-testacular": "0.2.x"
</code></pre>

<p>Import the plugin in your <code>grunt.js</code> file:</p>

<p>{% codeblock lang:js %}
grunt.loadNpmTasks('grunt-testacular');
{% endcodeblock %}</p>

<p>And finally, in <code>grunt.js</code>, specify your tasks:</p>

<p>{% codeblock lang:js %}
testacularServer: {
  unit: {</p>

<pre><code>options: {
  keepalive: true
},
configFile: 'testacular.conf.js'
</code></pre>

<p>  }
},
testacularRun: {
  unit: {</p>

<pre><code>runnerPort: 9100
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<h4>Two Tasks</h4>

<p>Grunt-testacular provides two tasks:</p>

<ol>
<li>testacularServer - starts the Testacular server (equivalent to <code>testacular start</code>)</li>
<li>testacularRun - runs your tests against an already-started server (equivalent to <code>testacular run</code>)</li>
</ol>


<h4>A grunt-testacular Oddity</h4>

<p>If you don't have <code>keepalive: true</code> set for grunt-testacular, the Testacular server will shutdown before it has a chance to capture browsers or run your tests.  I'm really not sure why this is even an option.  The false case behavior doesn't seem to be useful.  With the <code>singleRun</code> ability of Testacular, the plugin should just call start on the server and let the server configuration decide when it's appropriate to shut down.</p>

<p><strong>Update:</strong>
I logged an <a href="https://github.com/Dignifiedquire/grunt-testacular/issues/3#issuecomment-10234529">issue for grunt-testacular</a> that Grunt tasks listed after <code>testacularServer</code> weren't being run.  Friedal responded that <code>keepalive: true</code> was the problem.  If it is specified true, then it has to be the last task in the list.  So, if you have tasks after <code>testacularServer</code> specified, remove <code>keepalive: true</code> and add <code>watch</code> to the end of your task list.</p>

<h2>Grunt and Testacular Work Flow</h2>

<p>Of course, your work flow is up to you, and Grunt and Testacular give you enough flexibility to decide your own, but I think you'll run your tests in two main scenarios: development and continuous integration.</p>

<h4>Development</h4>

<p>For development, I like to start up the Testacular server and keep it running.  Then, I go write tests and update source code.  Testacular will notice my changes and automatically re-run my tests.</p>

<p>To set this up, make sure your grunt-testacular task has this option:</p>

<pre><code>keepalive: true
</code></pre>

<p>This will keep the server up even after the tests have completed.</p>

<p>And make sure your <code>testacular.conf.js</code> file includes:</p>

<pre><code>autoWatch = true;
</code></pre>

<p>This will force Testacular to re-run your tests if anything in your source or tests change (specifically, if anything in testacular.conf.js's <code>files</code> array changes).</p>

<h4>Continuous Integration</h4>

<p>For continuous integration, you just want your automated build to be able to verify the source code integrity prior to deploying.</p>

<p>We don't want tests to re-run automatically based on our changes, so we turn off <code>autoWatch</code> in <code>testacular.conf.js</code>:</p>

<pre><code>autoWatch = false;
</code></pre>

<p>And we set one more value in <code>testacular.conf.js</code> to:</p>

<pre><code>singleRun = true;
</code></pre>

<p>This will allow the <code>testacularServer</code> task to be run once, have Testacular run all the tests, and then make the server shut down.</p>

<p>Finally, remember to keep <code>keepalive: true</code> set in <code>grunt.js</code>.  Odd, right?</p>

<h2>Multiple Testacular Configurations</h2>

<p>To manage the options that are distinct to these two work flows, one could just create two separate <code>testacular.conf.js</code> files.  But, that would be overkill, because there'd be a lot of overlap between the two files.</p>

<p>Instead, the grunt-testacular plugin gives you override ability on a per-variable basis.  To support the development and integration scenario, the grunt multiTask might look like this:</p>

<p>{% codeblock lang:js %}
testacularServer: {
  unit: {</p>

<pre><code>options: {
  keepalive: true
},
configFile: 'testacular.conf.js'
</code></pre>

<p>  },
  integration: {</p>

<pre><code>options: {
  keepalive: true
},
configFile: 'testacular.conf.js',
autoWatch: false,
singleRun: true
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>Following this same pattern, you could create a separate config for automated functional or end-to-end tests as well.</p>

<p>Note that the <code>options</code> object is strictly for the plugin.  The other variables at that level feed straight into Testacular as overrides.</p>

<h2>Integrated Testing</h2>

<p>Process and product maturity are increased as tests are integrated into the build process.  Grunt and Testacular make integrating your browser tests a snap.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test RequireJs Code in Testacular]]></title>
    <link href="http://jaketrent.com/post/test-requirejs-testacular/"/>
    <updated>2012-10-31T17:04:00-06:00</updated>
    <id>http://jaketrent.com/post/test-requirejs-testacular</id>
    <content type="html"><![CDATA[<p>Did you write your source code as JavaScript AMD modules in <a href="http://requirejs.org/">RequireJs</a>?  Do you want to test them in real browsers?  Do you want the flexibility of using <a href="http://visionmedia.github.com/mocha/">Mocha</a> or <a href="http://pivotal.github.com/jasmine/">Jasmine</a>?  This is the moment you've been waiting for.</p>

<p><a href="http://vojtajina.github.com/testacular/">Testacular is a "spetacular test runner for JavaScript"</a> that was written to support the <a href="http://angularjs.org/">AngularJs</a> project.  It is valuable because it will run your tests in real browsers.  This is important for front-end code that relies on browser globals such as <code>window</code> (eg, if you use jQuery) or that manipulates the DOM (which could vary browser to browser).</p>

<p>Client-side JavaScript testing is a somewhat crazy space.  Some have even called it <a href="http://rzrsharp.net/2012/08/01/client-side-testing-insanity.html">"insane"</a> and taken drastically different routes than what follows.  But we're gonna see if we can power through, and Testacular will help us get the job done.</p>

<p><img src="http://i.imgur.com/7gh40.jpg" alt="Testacular Javascript Testing" /></p>

<!--more-->


<h2>RequireJs Modules</h2>

<p>We wrote our source code using RequireJs-implemented AMD modules.  This gives us:</p>

<ul>
<li>Clean code organization</li>
<li>Namespaced code (not global)</li>
<li>Explicit dependency management</li>
<li>Source optimized via the RequireJs build</li>
</ul>


<p>Unfortunately, it also makes our source a bit more tricky to test.</p>

<h2>Testacular RequireJs Support</h2>

<p><a href="https://groups.google.com/forum/?fromgroups=#!topic/testacular/CRsf8Ig4bgE">RequireJs support was just barely added</a> to Testacular, so it only lives in the canary channel (master).  To install with npm:</p>

<pre><code>npm install -g testacular@canary
</code></pre>

<p>This will currently install version <del datetime="2012-11-05T14:38:54+00:00">0.5.1</del> 0.5.2.  This is the first version of Testacular with RequireJs support.  So your <code>package.json</code> should include an entry like:</p>

<pre><code>"testacular": "&gt;=0.5.2"
</code></pre>

<p>If <a href="https://npmjs.org/package/testacular">Testacular</a> has moved to >=0.6.0, you can use the stable channel.</p>

<h2>Configure Testacular For RequireJs</h2>

<h4>Directory Setup</h4>

<p>For clarity in the example configuration files and test below, the directory structure upon which these are based looks like this:</p>

<pre><code>project/
    lib/
        jquery.js #etc
    node_modules/
        chai/ #etc
    src/
        MyModule.js
    test/
        MyModule.test.js
        test-main.js
testacular.conf.js
</code></pre>

<h4>Initialize Testacular</h4>

<p>Testacular comes with a nice utility for generating a config file (default name: 'testacular.conf.js') that it needs in order to run.  In your terminal, type:</p>

<pre><code>testacular init
</code></pre>

<p>This will give you a series of prompts for things such as paths to source and tests and which browsers to capture.  <del datetime="2012-11-05T14:38:54+00:00">These prompts do not include the option to add RequireJs support automatically, so you'll need to add those lines manually to your <code>testacular.conf.js</code> (see below).</del>  As of testacular 0.5.2, <code>testacular init</code> will prompt for usage of the RequireJs adapter.</p>

<h4>Testacular Include</h4>

<p>Testacular 0.5.1, while adding RequireJs support, has added a new concept of "included" to the files listed in your config.  This is because RequireJs will balk about a the module not being loaded correctly (ie, loaded synchronously in the <code>&lt;head/&gt;</code> tag of the runner).  From the <a href="http://requirejs.org/docs/errors.html#mismatch">RequireJs docs</a>:</p>

<blockquote><p>"Be sure to load all scripts that call define() via the RequireJS API. Do not manually code script tags in HTML to load scripts that have define() calls in them."</p></blockquote>

<h4>RequireJs Shim</h4>

<p>Not immediately apparent is the fact that the 'shim' config from RequireJs 2.x does not work from within Testacular.  I haven't yet figured out why.  For instance, I was constantly getting "'Backbone' is not defined" messages even though it was specified in the 'shim' config and required in the test.  I could have been doing something wrong.  My solution thus far has been to list each of the non-RequireJs modules and their dependencies in the 'files' attribute of <code>testacular.conf.js</code>.</p>

<h4>testacular.conf.js</h4>

<p>The final point is that the RequireJs main module for your test runner should be the last file listed.</p>

<p>So, finally, here is the 'file' excerpt of <code>testacular.conf.js</code>:</p>

<p>{% codeblock lang:js %}
files = [
  MOCHA,
  MOCHA_ADAPTER,
  REQUIRE,
  REQUIRE_ADAPTER,</p>

<p>  // !! libs required for test framework
  {pattern: 'node_modules/chai/chai.js', included: false},</p>

<p>  // !! put what used to be in your requirejs 'shim' config here
  'lib/jquery.js',
  'lib/underscore.js',
  'lib/backbone.js',
  'lib/handlebars.js',</p>

<p>  // !! put all libs in requirejs 'paths' config here (included: false)
  {pattern: 'lib/<em>*/</em>.js', included: false},</p>

<p>  // !! all src and test modules (included: false)
  {pattern: 'src/<strong>/*', included: false},
  {pattern: 'test/</strong>/*.test.js', included: false},</p>

<p>  // !! test main require module last
  'test/test-main.js'
];
{% endcodeblock %}</p>

<p>This config is awesome.  It replaces an html test runner that you would otherwise have to build.</p>

<h2>RequireJs Main Module</h2>

<p>Just like any RequireJs project, you need a main module to bootstrap your tests.  In the main module, you setup the <a href="http://requirejs.org/docs/api.html#config"><code>require.config</code></a>.</p>

<h4>Testacular '/base' Directory</h4>

<p>Testacular serves files under the '/base' directory.  So, on the server, requests to files will be served up under 'http://localhost:9876/base/*'.  The RequireJs config for <code>baseUrl</code> gives a starting context for modules that load with relative paths.  When setting this value for the Testacular server, it will need to start with '/base'.  I want my baseUrl to be at the root of my '/src' directory so relative requires in the source won't need to change.  My baseUrl has the value of '/base/src'.</p>

<h4>Require Each Test File</h4>

<p>One of the things I hate is having to update a master list of all tests to run every time I add a test.  Unfortunately, that's what I currently have.  The test main module has to specifically require each of the test modules.  I would love it if I could add a <code>*.test.js</code> file to the test directory and just have it run the next time the tests run.</p>

<h4>Asynchronously Run Testacular</h4>

<p>Because the RequireJs require statements are asynchronous, Testacular needs to wait until they're done (the code is loaded and ready) before it starts the tests.</p>

<p>The <code>main-test.js</code> file ends up looking like this:</p>

<p>{% codeblock lang:js %}
require({</p>

<p>  // !! Testacular serves files from '/base'
  baseUrl: '/base/src',
  paths: {</p>

<pre><code>require: '../lib/require',
text: '../lib/text'
</code></pre>

<p>  },
}, ['../test/MyModule.test'], function() {
  window.<strong>testacular</strong>.start();
});
{% endcodeblock %}</p>

<h2>RequireJs Test in Testacular</h2>

<p>All the setup thus far has been in preparation for the code to follow.  The test can now be setup as a RequireJs module.  It can require the source code under test.  It can use <a href="http://visionmedia.github.com/mocha/">Mocha</a> (or whatever framework there is a Testacular adapter for).</p>

<p>I will also use <a href="http://chaijs.com/">Chai</a> in order to get the <a href="http://chaijs.com/guide/styles/">'should' BDD-style assertions</a>.  Note that by using RequireJs and running in the browser, we can't just <code>require('chai')</code>.  It has to be required using the asynchronous callback to avoid <a href="http://requirejs.org/docs/errors.html#notloaded">this error</a>:</p>

<blockquote><p>Uncaught Error: Module name "../node_modules/chai/chai" has not been loaded yet for context: _. Use require([])</p></blockquote>

<p>And finally, <code>should()</code> must be invoked to be available in the test.</p>

<p>So, a simple test will look like:</p>

<p>{% codeblock lang:js %}
define(['../node_modules/chai/chai', 'MyModule'],
  function(chai, MyModule) {</p>

<p>  var assert = chai.assert,</p>

<pre><code>expect = chai.expect,
should = chai.should();
</code></pre>

<p>  describe('MyModule', function () {</p>

<pre><code>describe('#initialize()', function () {
  it('should be a stinkin object', function () {
    var yippee = new MyModule();
    yippee.should.be.an('object');
  });
});
</code></pre>

<p>  });
});
{% endcodeblock %}</p>

<h2>Run the Tests in Testacular</h2>

<p>There are a couple options set in <code>testacular.conf.js</code> that will describe how your tests can be run:</p>

<ul>
<li><strong>singleRun</strong> - Start Testacular server, capture browsers, run all tests, shutdown server</li>
<li><strong>autoWatch</strong> - Have the server run tests every time a source or test file changes (and requires you to turn off singleRun)</li>
</ul>


<p>To start the Testacular server:</p>

<pre><code>testacular start
</code></pre>

<p>Finally, if your Testacular server is already running and you want to kick off the tests, type:</p>

<pre><code>testacular run
</code></pre>

<h2>Now to Test</h2>

<p>Thank you to <a href="https://github.com/vojtajina">Vojta Jina</a> and the rest of the AngularJs crew and other contributors for making an awesome test runner.  I'm very happy that RequireJs support was added.  Vojta has also provided an <a href="https://github.com/vojtajina/testacular/tree/master/test/e2e/requirejs">end-to-end example</a> with code on Github.</p>

<p>How do you see that we could improve this configuration or testing process?</p>

<p>Now to test some sweet code!</p>
]]></content>
  </entry>
  
</feed>
