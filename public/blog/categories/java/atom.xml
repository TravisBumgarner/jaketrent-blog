<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-08-25T11:13:26-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Read Request Body in Spring Bean]]></title>
    <link href="http://jaketrent.com/post/http-request-body-spring/"/>
    <updated>2012-11-27T14:10:00-07:00</updated>
    <id>http://jaketrent.com/post/http-request-body-spring</id>
    <content type="html"><![CDATA[<p>Spring is a great addition to your Java stack.  It helps you access the request for inside your Spring beans easily.  Maybe I'm doing it wrong, but reading the request body seems blasted verbose after that.  It takes a surprising amount of code.</p>

<p><img src="http://i.imgur.com/w8Ezm.jpg" alt="Happy Spring" /></p>

<!--more-->


<h2>Access the Request</h2>

<p>Spring's bread and butter, of course, is inversion of control.  So, to get to the request object itself is no big deal.  Just inject it (canonical packages shown forâ€¦ fun, mostly):</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="nd">@javax.inject.Inject</span>
</span><span class='line'>  <span class="n">javax</span><span class="o">.</span><span class="na">servlet</span><span class="o">.</span><span class="na">http</span><span class="o">.</span><span class="na">HttpServletRequest</span> <span class="n">req</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>And now for the pile of non-abstracted code.</p>

<h2>Parse the Body</h2>

<p>Number one, the body is accessed from the <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html"><code>HttpServletRequest</code></a> object it a place that wasn't obvious to me: <code>request.getReader()</code>.  Heads up, we've got a BufferedReader here.  Hey, at least we don't get a stream that we have to wrap in more than one reader!</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kd">private</span> <span class="n">String</span> <span class="n">getBody</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">body</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">&quot;POST&quot;</span><span class="o">)</span> <span class="o">)</span>
</span><span class='line'>  <span class="o">{</span>
</span><span class='line'>    <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
</span><span class='line'>    <span class="n">BufferedReader</span> <span class="n">bufferedReader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">bufferedReader</span> <span class="o">=</span>  <span class="n">req</span><span class="o">.</span><span class="na">getReader</span><span class="o">();</span>
</span><span class='line'>      <span class="kt">char</span><span class="o">[]</span> <span class="n">charBuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">bytesRead</span><span class="o">;</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">((</span><span class="n">bytesRead</span> <span class="o">=</span> <span class="n">bufferedReader</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">charBuffer</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">charBuffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bytesRead</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// swallow silently -- can&#39;t get body, won&#39;t</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">bufferedReader</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">bufferedReader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">// swallow silently -- can&#39;t get body, won&#39;t</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">body</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">body</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The code.  There is to much.  Let me sum up.  There's only going to be a body if you are doing a post.  Otherwise, don't worry about it.  If there is data, pull it into a string.  Everything else is for (not) handling errors.</p>

<p>There's a bit there.  It's not the worst.  But after getting used to <a href="http://expressjs.com/api.html#req.body">Express' bodyParser</a>, it was hard to see this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom Exception Handling for AccessDeniedException]]></title>
    <link href="http://jaketrent.com/post/custom-exception-handling-accessdeniedexception/"/>
    <updated>2012-01-06T13:20:00-07:00</updated>
    <id>http://jaketrent.com/post/custom-exception-handling-accessdeniedexception</id>
    <content type="html"><![CDATA[<p>Our app throws all sorts of exceptions.  Well, it doesn't usually.  It shouldn't normally.  Er... But, when it does we want to put in some handling so that the app doesn't blow up in some unsuspecting user's face.  And even then, sometimes we want special handling for certain exceptions and make sure others are just caught.  And that's what we'll do with AccessDeniedException.</p>

<!--more-->


<h2>The Simple Case</h2>

<p>In the simple case, all exceptions that bubble up to the servlet container will just need to be caught and a user needs to get a nice view instead of stack trace shown to them.  There's a nice class called <code>SimpleMappingExceptionResolver</code> that does, in fact, resolve this.  Provide it with the mappings from exception types to views that you've created, and as exceptions surface, the user will be shown the views instead of the exceptions.  Here's the config:</p>

<p>```xml
<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
  <property name="exceptionMappings"></p>

<pre><code>&lt;props&gt;
  &lt;prop key=".AccessDeniedException"&gt;errors/accessDenied&lt;/prop&gt;
  &lt;prop key=".DataAccessException"&gt;errors/dataAccessFailure&lt;/prop&gt;
  &lt;prop key=".TypeMismatchException"&gt;errors/resourceNotFound&lt;/prop&gt;
  &lt;prop key=".NoSuchRequestHandlingMethodException"&gt;errors/resourceNotFound&lt;/prop&gt;
  &lt;prop key=".MissingServletRequestParameterException"&gt;errors/resourceNotFound&lt;/prop&gt;
&lt;/props&gt;
</code></pre>

<p>  </property>
  <property name="defaultErrorView" value="errors/generalError"/>
  <property name="warnLogCategory" value="com.rockycode"/>
</bean>
```</p>

<p>As it turns out, this is perfect for the simple case.  What if I want something special?  And when don't I?!</p>

<h2>Custom HandlerExceptionResolver</h2>

<p>In my case, I want to catch <code>AccessDeniedException</code> just like all others, except I want to do some special checking of the user attributes who just go rejected via Spring Security.  This means I need a custom <code>HandlerExceptionResolver</code>.  And thankfully these things aren't all that complicated.  Something custom to handle our <code>AccessDeniedException</code> might be called <code>AccessDeniedExceptionResolver</code> and looks somewhat like this:</p>

<p>```java
public class AccessDeniedExceptionResolver implements HandlerExceptionResolver, Ordered {</p>

<p>  private int order;</p>

<p>  public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {</p>

<pre><code>ModelAndView view = null;
if (ex instanceof AccessDeniedException) {
  // super special handling lives here
  view = new ModelAndView("specialness");
}
return view;
</code></pre>

<p>  }</p>

<p>  // .. getters and setters ..
}
```</p>

<p>The <code>resolveException()</code> method is where the magic goes.  I only care about a certain type of exception, so I check for it and do special stuff.  If not, the <code>view</code> is returned as null with just falls through to the next resolver in line if there is one.  And blast it, we want one.  Let's just use our existing simple case resolver.</p>

<h2>Setting up 2 ExceptionResolvers</h2>

<p>In <code>AccessDeniedExceptionResolver</code>, we implemented <code>Ordered</code>.  This shows priority in a potential string of resolvers.  We're going to setup our resolver for the specific case to be higher priority (lower number), remove the <code>AccessDeniedException</code> entry on <code>SimpleMappingExceptionResolver</code> and add an order property to it:</p>

<p>```xml
<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
  <property name="exceptionMappings"></p>

<pre><code>&lt;props&gt;
  &lt;prop key=".DataAccessException"&gt;errors/dataAccessFailure&lt;/prop&gt;
  &lt;prop key=".TypeMismatchException"&gt;errors/resourceNotFound&lt;/prop&gt;
  &lt;prop key=".NoSuchRequestHandlingMethodException"&gt;errors/resourceNotFound&lt;/prop&gt;
  &lt;prop key=".MissingServletRequestParameterException"&gt;errors/resourceNotFound&lt;/prop&gt;
&lt;/props&gt;
</code></pre>

<p>  </property>
  <property name="defaultErrorView" value="errors/generalError"/>
  <property name="warnLogCategory" value="com.rockycode"/>
  <property name="order" value="1"/>
</bean></p>

<p><bean class="com.rockycode.AccessDeniedExceptionResolver">
  <property name="order" value="0"/>
</bean>
```</p>

<p>Slap that config in your app context and sing for joy.  Now you can create as many custom handlers as you'd like and just string em up like clean laundry on the line.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Calling Webservices in Java]]></title>
    <link href="http://jaketrent.com/post/calling-webservices-java/"/>
    <updated>2011-12-30T14:54:00-07:00</updated>
    <id>http://jaketrent.com/post/calling-webservices-java</id>
    <content type="html"><![CDATA[<p>In Java Land, everything is tied up in multiple layers of multi-colored wrapping paper.  The abstraction often provides niceties and protections and convenience, etc.  But, sometimes it practically makes you forget where you are.  For instance, why would anyone write a little howto on requesting something over the web from the context of the web.  That should be easy, right?  Well, yes, I think so.  And it turns out it is in Java, as it is in many <a href="http://developer.marklogic.com/pubs/5.0/apidocs/Ext-2.html">other languages</a>.  It's just that there you're super close to the HTTP protocol all the time, and in many Java uber-frameworks, if you want to know how to break into the low-level operations, you have to know where the fire exit is.</p>

<!--more-->


<h2>The Right Class</h2>

<p>By 'fire exit', I mean you have to know what specific API to use.  Hehe, and since we're doing some I/O (a request across the network), be prepared for at least a multi-layered chain of wrapper classes to package the data into.</p>

<p>It turns out that <a href="http://docs.oracle.com/javase/6/docs/api/java/net/URL.html"><code>java.net.URL</code></a> and <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/net/HttpURLConnection.html"><code>java.net.HttpUrlConnection</code></a> are the classes that will give us the operations we need.  And the operation is <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/net/URLConnection.html#getInputStream("><code>connection.getInputStream()</code></a>).  So, we have the bits to make a simple helper class for requesting other web resources like REST webservices.</p>

<h2>UrlReader.java</h2>

<p>```java
// ...package and imports...
public class UrlReader {
  public String request(String req) {</p>

<pre><code>String response = null;
HttpURLConnection conn = null;
try {
  URL url = new URL(req);
  conn = (HttpURLConnection) url.openConnection();
  BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
  StringBuilder sb = new StringBuilder();
  String line;
  while ((line = br.readLine()) != null) {
    sb.append(line);
  }
  br.close();
  response = sb.toString();
} catch (Exception e) {
  // An I/O exception handling you care for
} finally {
  if (conn != null) {
    conn.disconnect();
  }
}
return response;
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>It doesn't consist of too much:  Specify your url, open an input stream to that url, read it back, and buffer it into a string response.</p>

<p>But as is often the case, let's try a little bonus twist...</p>

<h2>Internal Https With Invalid Certificate</h2>

<p>When I started requesting webservices from my Java app, I needed to connect to an interanl web service that was https only but had a self-signed (not valid) SSL certificate.  It turns out that <code>HttpUrlConnection</code> doesn't handle https requests.  If you request such a resource, you'll turn up a nice stack trace that includes:</p>

<p><code>bash
javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
</code></p>

<p>It turns out that Java has another class that's doing some validation for you.  Also in the stack trace, <code>com.sun.net.ssl.internal.ssl.X509TrustManagerImpl.validate()</code> is called at <code>X509TrustManagerImpl.java:126</code>.</p>

<p>In my case, I didn't care if the certificate was good because to me it's an internal, trusted source anyway.  So, I want to accept any certificates in my http request.</p>

<h2>A TrustManager that Trusts all Certificates</h2>

<p>So, when it goes to validate, we need to give it an automatic pass.  Here's the modified <code>UrlReader.java</code>:</p>

<p>```java
// ...package and imports...  <br/>
public class UrlReader {</p>

<p>  private static SSLContext SSL_CONTEXT;</p>

<p>  static {</p>

<pre><code>try {
  TrustManager[] trustAllCerts = new TrustManager[]{
    new X509TrustManager() {
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {return null;}
        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType){}
        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType){}
    }
  };
  SSL_CONTEXT = SSLContext.getInstance("SSL");
  SSL_CONTEXT.init(null, trustAllCerts, new java.security.SecureRandom());
} catch (NoSuchAlgorithmException e) {
  throw new RuntimeException("Unable to initialise SSL context", e);
} catch (KeyManagementException e) {
  throw new RuntimeException("Unable to initialise SSL context", e);
}
</code></pre>

<p>  }</p>

<p>  public String request(String req) {</p>

<pre><code>String response = null;
HttpsURLConnection conn = null;
try {
  URL url = new URL(req);
  conn = (HttpsURLConnection) url.openConnection();
  conn.setSSLSocketFactory(SSL_CONTEXT.getSocketFactory());

  BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
  StringBuilder sb = new StringBuilder();
  String line;
  while ((line = br.readLine()) != null) {
    sb.append(line);
  }
  br.close();
  response = sb.toString();
} catch (Exception e) {
  // I/O exception handling -- or NOT!
} finally {
  if (conn != null) {
    conn.disconnect();
  }
}
return response;
</code></pre>

<p>  }
}
```</p>

<p>So, we pretty much doubled the size of the class, but most of it is on ceremony.  There's no much there.  In the static block, we are creating an <code>SSLContext</code> that has includes a <code>TrustManager</code> anonymous class in which the method implementations explictly leave out any checking for valid certification of the connection.  Plug er in and roll.  Or not.  Please at least <em>think</em> for a moment if you really know your app, what's going to use this <code>UrlReader</code> class and whether it's a good idea or not, because trusting all "https" connections regardless isn't a great general philosophy.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone and JAX-RS]]></title>
    <link href="http://jaketrent.com/post/backbone-and-jax-rs/"/>
    <updated>2011-12-28T13:23:00-07:00</updated>
    <id>http://jaketrent.com/post/backbone-and-jax-rs</id>
    <content type="html"><![CDATA[<p>BackboneJS is setup to do some pretty sweet single-page app action.  And of course, a single page app will probably be wanting to talk to web services on the server.  And if your server code is doing the Java jive, then a great way to expose your REST services is via JAX-RS.  It's as easy as Mikey singin' ABC-123!</p>

<!--more-->


<p>Note:  These examples use AMD-style modules in Javascript.  I personally use <a href="http://requirejs.org/">RequireJS</a> for my module loading fettish.</p>

<h2><a href="http://documentcloud.github.com/backbone/">BackboneJS</a> Model Url</h2>

<p>To tell a client-side <a href="http://documentcloud.github.com/backbone/#Model"><code>Backbone.Model</code></a> object where it syncs to on the server, it needs a <a href="http://documentcloud.github.com/backbone/#Model-url"><code>url</code></a> field like so (in <code>Cat.js</code>):</p>

<p>```javascript
define(function () {
  return Backbone.Model.extend({</p>

<pre><code>url: '/ws/cat'
</code></pre>

<p>  });
});
```</p>

<p>The <code>url</code> field can be a string literal or a function that has more meat to it.  The point is that it be awesome and point correctly to your REST endpoint exposed on the server.</p>

<p>If you want to fetch a model from the server, you can call <a href="http://documentcloud.github.com/backbone/#Model-fetch"><code>fetch()</code></a> directly on the model a la <code>myModelInstance.fetch()</code>, but in practice you won't know which specific model you want initially, and instead your model will be part of a <a href="http://documentcloud.github.com/backbone/#Collection-fetch">collection</a>.  But let's say that your model had an id of, say, 1334, and you wanted to get it off the server, you'd call <code>fetch()</code> and that call will delegate to <a href="http://documentcloud.github.com/backbone/#Sync"><code>Backbone.sync</code></a>, making an HTTP GET to:</p>

<p><code>bash
GET /ws/cat/1334
</code></p>

<p>When you save a model by calling <code>myModelInstance.save()</code>, it delegates to <code>Backbone.sync</code> in the same way.  If it's a new object (in Backbone, that means it doesn't yet have an <code>id</code> field) that was initially created on the client and thus doesn't appear on the server yet, it'll make an HTTP POST to:</p>

<p><code>bash
POST /ws/cat
</code></p>

<p>If it's already an object that was requested from the server (and has, say, and id of 1334) and is now being updated based on client action, it'll make an HTTP PUT to:</p>

<p><code>bash
PUT /ws/cat/1334
</code></p>

<p>(BTW, HTTP DELETE works the same way as PUT.)</p>

<h2>JAX-RS Endpoints</h2>

<p><a href="http://en.wikipedia.org/wiki/Java_API_for_RESTful_Web_Services">JAX-RS</a> endpoints are exceedingly easy to setup.  It's all annotation-based, so you're free to rejoice.  Here's an example (It's also a <a href="http://static.springsource.org/spring/docs/2.5.x/reference/beans.html">Spring <code>@Controller</code></a>):</p>

<p>```java</p>

<p>import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Controller;</p>

<p>@Controller
@Scope("singleton")
@Path("/ws/cat")
public class CatRest {</p>

<p>  @GET
  @Produces("application/json")
  public List<CatDto> getCats() {</p>

<pre><code>return getCatsFromSomewhere();
</code></pre>

<p>  }</p>

<p>  @POST
  @Produces("application/json")
  @Consumes("application/json")
  public CatDto createCat(CatDto dto) {</p>

<pre><code>return saveCatAndReturnInstanceWithId();      
</code></pre>

<p>  }</p>

<p>  @PUT
  @Path("/{id}")
  @Produces("application/json")
  public CatDto updateCat(CatDto dto) {</p>

<pre><code>return updateCatReturnSameInstance();
</code></pre>

<p>  }</p>

<p>  @DELETE
  @Path("/{id}")
  @Produces("application/json")
  public void deleteCat(@PathParam("id") Long id) {</p>

<pre><code>removeTheBlastedCat();
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>This should all be fairly self-descriptive.  It matches the HTTP actions that can be made from Backbone.sync.  So what is JAX-RS doing for you.  It's allowing your methods to be exposed as rest endpoints by the simple addition of the <code>@GET</code>, <code>@POST</code>, etc annotations.</p>

<p>Note that the <code>@Path</code> matches the <code>url</code> field on your Backbone model.  And <code>@PUT</code> and <code>@DELETE</code> append an <code>{id}</code> variable to the end of the path.  In the case of <code>@PUT</code>, the id gets set on the <code>CatDto</code>.  For HTTP DELETE, a body is not send, just the HTTP request, so a <code>@PathParam</code> is all you get.</p>

<p>If these operations are successful, they all <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">respond with</a> HTTP 200, except for DELETE which returns 204 NO CONTENT.</p>

<p>JAX-RS is also dealing with the marshalling and unmarshalling from, in this case, json into and out of <code>CatDto</code>.  The <code>CatDto</code>, but like most <a href="http://en.wikipedia.org/wiki/Data_Transfer_Object">DTOs</a> just provides a wrapper around your actually domain object that exposes only what you desire in your web service (ie, possibly not everything in domain objects).</p>

<p>And what does the DTO look like?  I'm glad you asked.</p>

<h2>DTOs -- The Backbone / JAX-RS Gophers</h2>

<p>Here's <code>CatDto.java</code>:</p>

<p>```java
import javax.xml.bind.annotation.XmlRootElement;
import java.io.Serializable;</p>

<p>@SuppressWarnings("serial")
@XmlRootElement
public class CatDto implements Serializable {</p>

<p>  private Long id;</p>

<p>  private String name;</p>

<p>  // getters and setters...</p>

<p>}
```</p>

<p>There's not much to it  -- just like a DTO should be.</p>

<p>By default, when JAX-RS gets some JSON in the body of an HTTP request, it's going to try and bind fields in the JSON to the DTO fields.  So, a nice piece of JSON from the client that could be unmarshalled into a <code>CatDto</code> instance would look something like:</p>

<p><code>javascript
{
  id: 1334,
  name: 'Cotton-headed Ninnymuggins'
}
</code></p>

<p>It's as magical as <a href="http://www.youtube.com/watch?v=Fig956-MuVA">maple syrup</a>!</p>

<h2>Binding form fields to a Backbone Model</h2>

<p>By default, BackboneJS has no built-in ability to automatically bind the values that are entered in form fields in the UI to fields in the corresponding <code>Backbone.Model</code> object.  But, Derick Bailey has created a nice little Backbone plugin for this purpose called <a href="https://github.com/derickbailey/backbone.modelbinding">Backbone.ModelBinding</a>.  This is a <a href="http://knockoutjs.com/">KnockoutJS</a>-inspired dom to model (and vice versa) data transfer lib.</p>

<p>If you don't have <code>Backbone.ModelBinding</code> on your project, you'll have to do your own setting of fields when you save with the "set and save" idiom from Backbone that will look something like:</p>

<p><code>javascript
myModel.save({
  name: $("#name-form-field").val()
});
</code></p>

<p>If you do want to use <code>Backbone.ModelBinding</code>, make sure you make it globally available (as a dependency <a href="http://requirejs.org/docs/api.html#order">ordered</a> after Backbone itself) just put this snippet in your <code>Backbone.View</code> code:</p>

<p>```javascript
define(function () {
  return Backbone.View.extend({</p>

<pre><code>initialize: function () {
  // ...
  Backbone.ModelBinding.bind(this);
},
// more view goodness
</code></pre>

<p>  }
});
```</p>

<p>You should also be aware of some of the limitations of <code>Backbone.ModelBinding</code>.  For instance, it can only bind anything that a Backbone.Model can get() and set(), which doesn't include nested objects or arrays.  So, some stuff you'll have to set manually anyway if you have objects more interesting than cats.</p>

<p>Also note that any inputs on the form, that are sometimes fields you don't care about or necessarily want attached to your <code>Backbone.Model</code>, show up there anyway.  So now when you call <code>myModelInstance.save()</code>, the json that gets sent to the server will be laden with extra coconuts, potentially like this:</p>

<p><code>javascript
{
  id: 1334,
  name: 'Mittens',
  ladenWith: 'coconuts,
  africaan: true
}
</code></p>

<p>And just between you and me, that won't work with our currently-defined <code>CatDto</code>.  It's time for a season reboot:</p>

<h2>Backbone.ModelBinding and JAX-RS</h2>

<p>If we get these extra, albeit more exciting, fields in the json, when unmarshalling happens, we get a late Christmas present:</p>

<p><code>text
[12/26/12 00:00:0:001] 0000000e Wr WebApplicationExceptionMapper: WebApplicationException has been caught :
Unrecognized field "laden_with" (Class CatDto), not marked as ignorable
  at [Source: org.apache.cxf.transport.http.AbstractHTTPDestination$1@b98117; line: 1, column: 286] (through reference chain: CatDto["laden_with"])
</code></p>

<p>"Not marked as ignorable", eh?  A couple ways to fix this.  The one requiring more typing and creating a brittle dto first.  Back to <code>CatDto.java</code>:</p>

<p>```java
import javax.xml.bind.annotation.XmlRootElement;
import java.io.Serializable;</p>

<p>@SuppressWarnings("serial")
@XmlRootElement
public class CatDto implements Serializable {</p>

<p>  private Long id;</p>

<p>  private String name;</p>

<p>  @XmlTransient
  private String ladeWith;</p>

<p>  @XmlTransient
  private Boolean africaan;</p>

<p>  // getters and setters...</p>

<p>}
```</p>

<p>We can label each of the undesirable fields with <code>@XmlTransient</code>, but oh the pain.</p>

<p>It's maybe not all that bad that this blows big chunks.  Perhaps more secure.  You want to validate input at the REST endpoints.  Maybe this is the way you personally do it.  I do it elsewhere -- in the converstion from DTOs to domain objects and with Hibernate validators on those objects.</p>

<p>So, for me the better option that allows me to not have to go back and mess with <code>CatDto.java</code> as much is:</p>

<p>```java
import javax.xml.bind.annotation.XmlRootElement;
import java.io.Serializable;
import org.codehaus.jackson.annotate.JsonIgnoreProperties;</p>

<p>@SuppressWarnings("serial")
@XmlRootElement
@JsonIgnoreProperties(ignoreUnknown = true)
public class CatDto implements Serializable {</p>

<p>  private Long id;</p>

<p>  private String name;</p>

<p>  // getters and setters...</p>

<p>}
```</p>

<p>This is whitelisting instead of blacklisting.  Lots less maintenance when more fields show up as unrecognizable.  Either way, I just use what I want on the server, so just ignore <em>everything</em> else with the <a href="http://wiki.fasterxml.com/JacksonAnnotations"><code>@JsonIgnoreProperties</code></a> annotation.</p>

<h2>Lots of HTTP</h2>

<p>This kind of programming is really quite fun.  And it feels pretty clean.  There's lots of cool UI possibilities for single-page apps on the client.  BackboneJS and RequireJS makes handling the complexity there much more doable.  And data-handling REST endpoints on the backend are super simple.  The simplicity of the REST endpoints makes Java feel a little heavy-handed on ceremony (like it often seems these days), but JAX-RS is a great framework if Java is what you have on the backend.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stored Procedures in Spring Jdbc]]></title>
    <link href="http://jaketrent.com/post/stored-procedure-spring-jdbc/"/>
    <updated>2011-12-21T14:33:00-07:00</updated>
    <id>http://jaketrent.com/post/stored-procedure-spring-jdbc</id>
    <content type="html"><![CDATA[<p>In addition to some sweet Inversion of Control injection action, Spring brings flowers and baby deer.  And it brings some nice database connection help.  Spring JdbcTemplate is a vanguard of strength and ease for connecting to your favorite RDBMS.  And it so happens that the DBA I'm working with right now digs the stored procs.  So, we'll meet in the middle with some more goodness born of Spring.</p>

<!--more-->


<h2>StoredProcedure</h2>

<p>Blessed Rod Johnson gives us the <code>org.springframework.jdbc.object.StoredProcedure</code>.  It's abstract, and you'll want to extend it and fully implement it in order to specify what stored proc in your database you're calling.  And here's a sample implementation:</p>

<p>```java
@Component
public class ItemInsert extends StoredProcedure {
  public static final String SPROC_NAME = "schema.oracle_pkg.proc_name";
  public static final String INPUT_PARAM = "input_prm_name";
  public static final String OUPUT_PARAM = "output_prm_name";</p>

<p>  @Inject
  public ItemInsert(DataSource ds) {</p>

<pre><code>super(ds, SPROC_NAME);
declareParameter(new SqlParameter(INPUT_PARAM, Types.VARCHAR));
declareParameter(new SqlOutParameter(OUTPUT_PARAM, Types.NUMERIC));
compile();
</code></pre>

<p>  }</p>

<p>  public Item insert(Item item)</p>

<pre><code>  throws DataAccessException {
Map&lt;String, Object&gt; inputs = new HashMap&lt;String, Object&gt;();
inputs.put(INPUT_PARAM, item.getSomething());
Map&lt;String, Object&gt; output = super.execute(inputs);
Object newId = output.get(OUTPUT_PARAM);
if (newId != null) {
  item.setId(Long.parseLong(newId.toString()));
}
return item;
</code></pre>

<p>  }
}
```</p>

<p>Points to consider:</p>

<ul>
<li><code>ItemInsert</code> is itself injectable as a Spring bean <code>@Component</code>.</li>
<li>Input and output parameters are declared in the constructor</li>
<li><code>insert()</code> is where <code>super.execute()</code> is call, which is the function that really does the magic.</li>
</ul>


<p>The only other interesting thing...</p>

<h2>Execute()</h2>

<p>From the JavaDoc:</p>

<p>  Execute the stored procedure. Subclasses should define a strongly typed execute method (with a meaningful name) that invokes this method, populating the input map and extracting typed values from the output map. Subclass execute methods will often take domain objects as arguments and return values.  Alternatively, they can return void.</p>

<p>Thusly, out method is called <code>insert()</code> because it's a meaningful name.  It takes our domain object, <code>Item</code> and pulls out the necessary fields inside the method, putting them into a map for the call <code>super.execute()</code>.</p>

<h2>Call it from a service</h2>

<p>Now the only work left is just to call your awesome procedure and use the results for something wonderful.  Eg,</p>

<p>```java
@Service
public class ItemServiceImpl implements ItemService {</p>

<p>  @Inject
  private ItemInsert itemInsert;</p>

<p>  public Item doWonderfulThingsWithItems(Item item) {</p>

<pre><code>return itemInsert.insert(item);
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>Items are now stored procedurally and you can rest easy knowing that Oracle has all your data.</p>
]]></content>
  </entry>
  
</feed>
