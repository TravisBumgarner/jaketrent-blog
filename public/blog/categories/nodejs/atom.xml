<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nodejs | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-04-23T22:31:18-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[List Npm Scripts]]></title>
    <link href="http://jaketrent.com/post/list-npm-scripts/"/>
    <updated>2015-03-02T07:44:00-07:00</updated>
    <id>http://jaketrent.com/post/list-npm-scripts</id>
    <content type="html"><![CDATA[<p>Tools for storing and then later easily running scripts alias names are awesome.  Npm is one of those tools.  Rake is another.  Rake has a cool feature of allowing you to list the scripts available to you.  Npm has not -- until now.</p>

<p><img src="http://i.imgur.com/ZDCd9u1.png" alt="npm" /></p>

<!--more-->


<h2>Npm Scripts</h2>

<p>You can specify scripts in your <code>package.json</code> for later use.  They go in the <code>scripts</code> attribute:</p>

<p>```json package.json
{
  "scripts": {</p>

<pre><code>"start": "node server.js",
"dist": "webpack -p"
</code></pre>

<p>  }
}
```</p>

<p>To run these scripts, you use the <a href="https://docs.npmjs.com/cli/run-script"><code>npm run</code></a> command.  For example, type <code>npm run build</code> to actually execute the <code>webpack -p</code> command in your terminal.  <code>start</code> and <code>test</code> are specially commands to npm and do not require <code>run</code>.  Instead, you can use <code>npm start</code>.</p>

<h2>Npm List Scripts</h2>

<p>In Rake, you run <code>rake -T</code> in your terminal and all the available scripts for your project are displayed.  This allows you to see the what's potentially helpful.  You can't be expected to remember all of them, especially months later, right?</p>

<p>I certainly was having a hard time remembering all of my scripts and getting tired of typing <code>cat package.json</code>.  It didn't feel as cool as the <code>rake -T</code> experience.  I wrote a library called <a href="https://www.npmjs.com/package/npm-ls-scripts"><code>npm-ls-scripts</code></a>.  To install, run:</p>

<p><code>bash
npm install npm-ls-scripts -g
</code></p>

<p>I like installing this package globally because then the CLI binary is available globally -- it does seem applicable to all projects.  You could instead include it under project <code>devDependencies</code> if you'd like.</p>

<p>If installed globally, you can then run it with:</p>

<p><code>bash
ls-scripts
</code></p>

<p>If I was to run this in the above project, it would print:</p>

<p>```bash</p>

<h2>NPM - ls scripts</h2>

<p>start - node server.js</p>

<h2>dist - webpack -p</h2>

<p>```</p>

<p>This prints the exact code that can be executed for each script.  If I would like to add some prose around any or all of the available scripts, I can do so by adding more config data to my <code>package.json</code> that will print when I run <code>ls-scripts</code>:</p>

<p>```json package.json
{
  "config": {</p>

<pre><code>"scripts: {
   "dist": "Builds project for distribution"
}
</code></pre>

<p>  }
}
```</p>

<p>Now if I were to run the <code>ls-scripts</code> command, I would see:</p>

<p>```bash</p>

<h2>NPM - ls scripts</h2>

<p>start - node server.js</p>

<h2>dist - Builds project for distribution</h2>

<p>```</p>

<p>Cool, right?  Complete with Shakespearean prose.</p>

<h2>New: Npm Run</h2>

<p>After I had developed the above <code>npm-ls-scripts</code> tool, Npm built this feature natively into the core tool -- finally!  Now, to list available scripts, the command is intuitively to leave off the target script and instead simply type:</p>

<p><code>bash
npm run
</code></p>

<p>On the above example, this would yield:</p>

<p>```bash
Available scripts in the package:
  start</p>

<pre><code>node server.js
</code></pre>

<p>  dist</p>

<pre><code>webpack -p
</code></pre>

<p>```</p>

<p>So, they work about the same, and now it's built in!  What other cool features could you imagine this having?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Express Validator]]></title>
    <link href="http://jaketrent.com/post/testing-express-validator/"/>
    <updated>2014-03-10T07:37:00-06:00</updated>
    <id>http://jaketrent.com/post/testing-express-validator</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/ctavan/express-validator">Express-validator</a> is a <a href="http://expressjs.com/api.html#middleware">middleware for Express</a> on Node.js that can help you validate user input.  It's a lovely library.  Here's a pattern for testing code that uses it.</p>

<p><img src="http://i.imgur.com/ZfK9bv4.png" alt="express-validator" /></p>

<!--more-->


<h2>Install</h2>

<p>To get <code>express-validator</code> in your project, install with npm:</p>

<p><code>bash
npm install express-validator --save
</code></p>

<h2>Plug in the Middleware</h2>

<p>To use the middleware in your code, crack open the part of your app that sets up Express middlewares, and add in a reference to this lil beaut:</p>

<p>```coffeescript
expressValidator = require 'express-validator'</p>

<h1>...</h1>

<p>app.use express.json()
app.use expressValidator()
```</p>

<p>Note that you should insert the new <code>express-validator</code> middleware directly after the <code>json</code> middleware.  Also note that the <code>json</code> middleware, used in conjunction with <code>urlencoded</code> now <a href="http://andrewkelley.me/post/do-not-use-bodyparser-with-express-js.html">replace <code>bodyParser</code></a> to avoid deprecation warnings on startup.</p>

<h2>Validate Something</h2>

<p>Let's say you're writing a validator for new posts to a blog.  That code might look like this.</p>

<p>```coffeescript blog-new-validator.coffee
module.exports = (req) -></p>

<p>  req.checkBody('title', 'Title is required').notEmpty()
  req.checkBody('body', 'Body is required').notEmpty()</p>

<p>  !req.validationErrors() or req.validationErrors().length is 0
```</p>

<p>It checks to see if there is a title and a body given.  If there is not, the validator will return false, and there will be a validation errors array on the <code>req</code> object.  There are many <a href="https://github.com/chriso/validator.js">other assertions (provided internally by validator.js)</a> besides <code>notEmpty</code> that you can use.</p>

<h2>Validating the Validator</h2>

<p>First, setup a test helper that stubs the request, <code>req</code>, for validation:</p>

<p>```coffeescript req.coffee
expressValidator = require('express-validator')()</p>

<p>exports.stubForValidation = (done) ->
  req =</p>

<pre><code>query: {}
body: {}
params: {}
param: (name) -&gt;
  @params[name]
</code></pre>

<p>  expressValidator req, {}, -></p>

<pre><code>done(req)
</code></pre>

<p>```</p>

<p>There's nothing too incredibly special here.  It's just abstracted out of your test into a reusable helper.  The <code>req</code> object has empty objects to slap fixture data onto in your tests.  It includes a stubbed <code>param</code> function that can return params by name.  Finally, the <code>express-validator</code> middleware is called with the stubbed <code>req</code> object.</p>

<p>Now, in your test, you can simply:</p>

<ol>
<li>Stub the request before each test</li>
<li>Setup your fixture data to make the test pass (or not)</li>
<li>Assert validation errors' existence and messages</li>
</ol>


<p>```coffeescript blog-new-validator.spec.coffee
stubReq = require('req').stubForValidation
validateNew = require 'blog-new-validator'</p>

<p>describe 'blog-new-validator', -></p>

<p>  req = null</p>

<p>  beforeEach (done) -></p>

<pre><code>stubReq (r) -&gt;
  req = r
  done()
</code></pre>

<p>  it 'is invalid without title', -></p>

<pre><code>validateNew(req).should.be.false
req.validationErrors(true).title.msg.should.eql 'Title is required'
</code></pre>

<p>  it 'is invalid without body', -></p>

<pre><code>validateNew(req).should.be.false
req.validationErrors(true).body.msg.should.eql 'Body is required'
</code></pre>

<p>  it 'is valid with title and body', -></p>

<pre><code>req.body.title = 'New Blog Title'
req.body.body = 'The body of the blog.'
validateNew(req).should.be.true
</code></pre>

<p>```</p>

<p>What do you think?  Is there an easier way?  A way to get better assertions?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongoose Population]]></title>
    <link href="http://jaketrent.com/post/mongoose-population/"/>
    <updated>2013-06-18T07:39:00-06:00</updated>
    <id>http://jaketrent.com/post/mongoose-population</id>
    <content type="html"><![CDATA[<p><a href="http://mongoosejs.com">Mongoose</a> is an object modeler for <a href="http://mongodb.org">MongoDb</a>.  It has a particularly great feature, called <a href="http://mongoosejs.com/docs/populate.html">population</a>.  Population allows you to include other objects in a specified object.  It makes the process a lot easier and more automatic.</p>

<p><img src="http://i.imgur.com/pezEyw7.jpg" alt="Mongoose" /></p>

<!--more-->


<h2>Document Design</h2>

<p>Document databases provide a lot of flexibility in how data is modeled.  Just as the name suggests, data will often mimic real-world documents.  MongoDb isn't a document database per se, but it has enough flexibility to be treated as one.  Mongoose population can help.</p>

<p>A document is often optimized for reads.  All the data is included, such as it would be on a real-world piece of paper.</p>

<p>In Mongo, data is divided into collections.  Mongoose helps define discrete schemas for data in each.  This separates and makes data fields explicit.  This helps with data organization, storage, and writing.  Population helps bring data from different collections back together again easily.  From the <a href="http://mongoosejs.com/docs/populate.html">docs</a>:</p>

<blockquote><p>Population is the process of automatically replacing the specified paths in the document with document(s) from other collection(s).</p></blockquote>

<p>So, let's try it out with a couple examples.</p>

<h2>Data Definition</h2>

<p>Mongo will add a primary surrogate key to each object, called <a href="http://docs.mongodb.org/manual/reference/object-id/">ObjectId</a>, referenced as <code>_id</code> in the data.  This will be the key used to refer to objects in other collections.  If I wanted to model players in leagues -- foosball leagues of course --  I might create schemas like this:</p>

<p>```coffeescript player.coffee
mongoose = require 'mongoose'
Schema = mongoose.Schema</p>

<p>playerSchema = new mongoose.Schema
  display_name: String
  leagues: [</p>

<pre><code>type: Schema.Types.ObjectId
ref: 'League'
</code></pre>

<p>  ]</p>

<p>Player = mongoose.model 'Player', playerSchema
```</p>

<p>```coffeescript league.coffee
mongoose = require 'mongoose'
Schema = mongoose.Schema</p>

<p>leagueSchema = new mongoose.Schema
  display_name: String
  created_by:</p>

<pre><code>type: Schema.Types.ObjectId
ref: 'Player'
</code></pre>

<p>  players: [</p>

<pre><code>type: Schema.Types.ObjectId
ref: 'Player'
</code></pre>

<p>  ]</p>

<p>League = mongoose.model 'League', leagueSchema
```</p>

<p>A few points of interest:</p>

<ul>
<li>Since we are using <code>_id</code> to refer to other objects, we use the <code>ObjectId</code> type in the Mongoose definition.  You can use other fields.  Just make sure the type matches.</li>
<li>The <code>ref</code> attribute must match <em>exactly</em> the model name in your model definition.  Otherwise you'll get something like this little beauty: <code>MissingSchemaError: Schema hasn't been registered for model "Player".</code>.</li>
<li>Note that <code>League.players</code> is an array.  Just surround the field definition in square brackets to get this functionality.</li>
</ul>


<h2>Data Read</h2>

<p>Reading data is where Mongoose population really shines.  This is the magic that makes reads of documents very straightforward, easy, and fast.  The magic is in the <code>populate()</code> function.</p>

<h3>Populate One Field</h3>

<p>If I want to populate a single field in the query for an object, I specify the name of that field in a string to the <code>populate</code> function:</p>

<p><code>coffeescript
Player
  .findOne({ _id: 'abc123' })
  .populate('leagues')
  .exec (err, player) -&gt; #...
</code></p>

<p><code>leagues</code> will be populated with an array of full <code>League</code> objects when the resulting json returned, just like magic.</p>

<h3>Populate Multiple Fields</h3>

<p>Populating multiple referenced objects is similarly easy:</p>

<p><code>coffeescript
League
  .find()
  .populate('created_by players')
  .exec (err, league) -&gt; #...
</code></p>

<p>Just separate the field names in your <code>populate</code> parameter with spaces.  This query will return an array of <code>League</code> with the <code>created_by</code> and <code>player</code> fields populated with the associated <code>Player</code> objects.</p>

<h3>Populate Partial Objects</h3>

<p>Populating objects like this can quickly bloat your payload size.  To limit included objects to only a subset of fields, you can specify exactly what parts you want populated.  For instance, if my client UI only needed to show a list of leagues that a player belongs to, I could ask for just the <code>display_name</code> of the included <code>League</code> object by using a 2nd parameter:</p>

<p><code>coffeescript
Player
  .findOne({ _id: 'abc123' })
  .populate('leagues', 'display_name')
  .exec (err, player) -&gt; #...
</code></p>

<p>For listing multiple parts, separate the attribute names with spaces.</p>

<h3>Forget to Populate</h3>

<p>You might get so used to having objects populated for some of your queries that you might wonder why they're not populated in your latest query.  You probably just forgot to call <code>populate()</code> in your query.  You must do this explicitly to get the inclusions you desire.  Otherwise, you the data you query will just include the <code>_id</code> values.</p>

<h3>Explicitly Exclude Field</h3>

<p>It might not be that you forgot to populate, but that on some queries you don't want to populate.  In these cases, you might not want to be sending around unneeded <code>_id</code> values, especially if they make up a large portion of your data size.  You can explicitly exclude such fields.  For instance, if you wanted all <code>Player</code> models but weren't going to populate <code>leagues</code>, you might query:</p>

<p><code>coffeescript
Player
  .find()
  .select('-leagues')
  .exec (err, players) -&gt; #...
</code></p>

<p>Note the <code>-</code> sign in the <code>select</code> clause.  This removes the field from the results.</p>

<h2>Data Write</h2>

<p>When you go to read the data, it's quick, easy, and automatic.  But that's because some work was done previously to reference the correct objects and make sure these references are saved.  Therefore, the naturally more work-intensive part of the population story is the data writing.</p>

<p>When we write to our example models, we need to save the proper references.  For instance, when a new <code>League</code> is created, let's say it automatically needs a <code>created_by</code> <code>Player</code> reference saved and the creating <code>Player</code> will automatically join the league:</p>

<p>```coffeescript
league =
  display_name: myLeagueName
  created_by: currentPlayer._id</p>

<p>League.create league, (err, league) ->
  if err?</p>

<pre><code># ... do smart things that are never shown in a tutorial
</code></pre>

<p>  else</p>

<pre><code>Player.update { _id: currentPlayer._id },
  $push:
    leagues: league._id
, (err, numberAffected, raw) -&gt;
  if err?
    # you know...
  else
    res.json league
</code></pre>

<p>```</p>

<p>A few points of interest:</p>

<ul>
<li>Lowercase <code>league</code> is just the json to populate a <code>League</code> model.  <code>league</code> is also the shadowed variable name in the <code>League.create</code> callback.</li>
<li><code>currentPlayer</code> is just an imagined <code>Player</code> reference that has an <code>_id</code> that you will use to associate <code>Player</code> to this <code>League</code>.</li>
<li><a href="http://docs.mongodb.org/manual/reference/operator/push/"><code>$push</code></a> is a special <code>update</code> attribute that appends new elements to a model's array.</li>
</ul>


<p>Depending on how complex your model relationships become, you may opt for a difference code strategy besides nesting callbacks.  Don't like your pyramid of doom?  Try the awesome <a href="https://github.com/caolan/async">async.js</a>.</p>

<p>I don't know if Mongoose population is going to change your life, but I was very happy when I found this feature.  I had been doing junk like this manually.  What are some other great use cases that you've found?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LiveReload for NodeJs]]></title>
    <link href="http://jaketrent.com/post/livereload-for-nodejs/"/>
    <updated>2013-04-23T16:44:00-06:00</updated>
    <id>http://jaketrent.com/post/livereload-for-nodejs</id>
    <content type="html"><![CDATA[<p>LiveReload is a wonderful tool/strategy for being able to develop websites more quickly.  You can make a change and see it immediately shown in the browser without requiring you to manually refresh.  To do this in NodeJs with Express, you'll need just a few packages.</p>

<p><img src="http://i.imgur.com/4773D.jpg" alt="grunt" /></p>

<!--more-->


<h2>LiveReload Express</h2>

<p>If you're doing a website on Nodejs these days, you're probably using Express.  Express uses the Connect library for its middleware scheme.  Just grab one more middleware to handle the LiveReload.  It will add a little snippet of JavaScript to each of the html responses that is requested through this middleware.  First, install:</p>

<p><code>
npm install connect-livereload --save-dev
</code></p>

<p>Next, import:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">configure</span> <span class="s">&#39;development&#39;</span><span class="p">,</span> <span class="o">-&gt;</span>
</span><span class='line'>  <span class="nx">app</span><span class="p">.</span><span class="nx">use</span> <span class="nx">require</span><span class="p">(</span><span class="s">&#39;connect-livereload&#39;</span><span class="p">)</span> <span class="mi">35729</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Note that we only want to import and use the middleware when in development.  This matches the fact that we are only declaring this package as in <code>devDependencies</code>.</p>

<h2>LiveReload Grunt</h2>

<p>Now you need to something to start a livereload server, watch files for changes, and broadcast their availability.  The rest of this will be done via Grunt.</p>

<p>First, install:</p>

<p><code>
npm install grunt-cli -g
npm install grunt grunt-regarde grunt-contrib-livereload --save-dev
</code></p>

<ul>
<li><code>grunt-cli</code> will allow you to run the <code>grunt</code> command in the terminal.  Global puts the bin in your path.</li>
<li><code>grunt-regarde</code> is a file watcher.  It senses changes to the filesystem.</li>
<li><code>grunt-contrib-reload</code> will handle the pushing of new code to the browser.</li>
</ul>


<p>Next setup the <code>Gruntfile.coffee</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">module.exports = </span><span class="nf">(grunt) -&gt;</span>
</span><span class='line'>  <span class="nx">grunt</span><span class="p">.</span><span class="nx">initConfig</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nv">regarde:</span>
</span><span class='line'>  <span class="nv">style:</span>
</span><span class='line'>    <span class="nv">files: </span><span class="p">[</span><span class="s">&#39;app/static/css/*.css&#39;</span><span class="p">]</span>
</span><span class='line'>    <span class="nv">tasks: </span><span class="p">[</span><span class="s">&#39;livereload&#39;</span><span class="p">]</span>
</span><span class='line'><span class="o">&lt;/</span><span class="nx">code</span><span class="o">&gt;&lt;/</span><span class="nx">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="nx">grunt</span><span class="p">.</span><span class="nx">loadNpmTasks</span> <span class="s">&#39;grunt-contrib-livereload&#39;</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="nx">grunt</span><span class="p">.</span><span class="nx">registerTask</span> <span class="s">&#39;be-lively&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s">&#39;livereload-start&#39;</span><span class="p">,</span> <span class="s">&#39;regarde&#39;</span> <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now when you run:</p>

<p><code>
grunt be-lively
</code></p>

<p>A livereload server is going to be setup.  Then we watch for filesystem changes.  The only things we're watching are css files in our app.  You could expand the <code>files</code> array to watch more if you wish.</p>

<p>Yay!</p>

<h2>LiveReload all the Things</h2>

<p>There are many ways to make this happen.  There are numerous Node libraries, Grunt plugins, and browser plugins.  Do what works for you.  Just make it happen fast and tend it well from the beginning to the end of your project.  Almost every solution I've found is somewhat high maintenance.  This one has proven to be the same.  What have you found to be your favorite LiveReload solution, and in what environment?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Access NodeJs App on Xip.io]]></title>
    <link href="http://jaketrent.com/post/nodejs-app-on-xipio/"/>
    <updated>2013-04-23T07:22:00-06:00</updated>
    <id>http://jaketrent.com/post/nodejs-app-on-xipio</id>
    <content type="html"><![CDATA[<p>Xip.io is a DNS wildcard domain that was initially created for use on Ruby projects.  But its application is desirable across platforms.  Recently, I wanted to use Xip.io on a NodeJs project.  It was easy to make happen.</p>

<p><img src="http://i.imgur.com/PJTnZmM.jpg" alt="xip.io" /></p>

<!--more-->


<h2>Update: Proxying is Built Into Pow</h2>

<p>After having a handful of problems with these home-grown proxies, my search eventually led me to know that Pow 0.4.0+ includes proxying as a built-in feature.  So, you don't need your own <code>config.ru</code> any more.  Once you install pow, choose the port that your app will run on and at what pow address you want to access your app, and run one command in your terminal:</p>

<p><code>
echo 3000 &gt; ~/.pow/myapp
</code></p>

<p>Then you'll access your app, running in the background on port 3000 via the web browser at <code>http://myapp.dev</code>.  Way better.  Skip the rest of this article.</p>

<h2>Install Pow and Powder</h2>

<p>Pow is a development server that uses Xip.io.  Powder is a cli that makes working with Pow even easier.  To start, make sure that <a href="http://www.ruby-lang.org/en/downloads/">Ruby</a> is setup with <a href="http://rubygems.org">Rubygems</a> in your environment.  Then install Pow.  They have a short little install script you can run, as <a href="http://pow.cx/">referenced on the Pow site</a>.</p>

<p>Then install Powder:</p>

<p><code>
gem install powder
</code></p>

<h2>Proxy your NodeJs app</h2>

<p>Pow only knows how to handle Rack apps, so we have to create one to be loaded into Pow.  Since we're writing the guts of our app on another platform -- in this case, Node -- we'll just create a proxy Rack app.</p>

<p>I found a bit of <a href="https://github.com/linjunpop/node-with-pow">proxy app code</a>, which you should save in your project root as <code>config.ru</code>, and which I paste here:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s2">&quot;net/http&quot;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;class ProxyApp</span>
</span><span class='line'><span class="sr">  def call(env)&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">begin</span>
</span><span class='line'>  <span class="n">request</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
</span><span class='line'>  <span class="n">headers</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">env</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">key</span> <span class="o">=~</span> <span class="sr">/^http_(.*)/i</span>
</span><span class='line'>      <span class="n">headers</span><span class="o">[</span><span class="vg">$1</span><span class="o">]</span> <span class="o">=</span> <span class="n">value</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">http</span> <span class="o">=</span> <span class="no">Net</span><span class="o">::</span><span class="no">HTTP</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">3000</span><span class="p">)</span>
</span><span class='line'>  <span class="n">http</span><span class="o">.</span><span class="n">start</span> <span class="k">do</span> <span class="o">|</span><span class="n">http</span><span class="o">|</span>
</span><span class='line'>    <span class="n">response</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">request_method</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>
</span><span class='line'>    <span class="o">[</span><span class="n">response</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">to_hash</span><span class="p">,</span> <span class="o">[</span><span class="n">response</span><span class="o">.</span><span class="n">body</span><span class="o">]]</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNREFUSED</span>
</span><span class='line'>  <span class="o">[</span><span class="mi">500</span><span class="p">,</span> <span class="p">{},</span> <span class="o">[</span><span class="s2">&quot;Server is down, try $npm start&quot;</span><span class="o">]]</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">run</span> <span class="no">ProxyApp</span><span class="o">.</span><span class="n">new</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The only change you might have to make is the port number for your app (line 13).  In this case, I'm using port 3000 for my NodeJs app.</p>

<h2>Link Your App</h2>

<p>Now all we have to do is link our app to Pow.  Powder helps us do this easily.  Go to your project root directory and type:</p>

<p><code>
powder link &lt;project_name&gt;
</code></p>

<p>Now run your app with whatever command starts NodeJs.  It's probably something like this:</p>

<p><code>
node app.js
</code></p>

<p>Now you should be able to access your app via your web browser at <code>http://&lt;project_name&gt;.dev</code>.  One of the great things about Xip.io is that it makes running your local app <a href="http://jaketrent.com/post/run-pow-server-on-vm/">extremely easy from a local Virtual machine</a> as well.  To get the address of your app to use in your VM, type this from your native terminal:</p>

<p><code>
powder open --xip
</code></p>

<p>And copy the resulting URL into your VM web browser.</p>

<p>Ah, the fusion of Node and Ruby is pretty sweet.</p>
]]></content>
  </entry>
  
</feed>
