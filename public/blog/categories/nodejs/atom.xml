<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nodejs | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-08-24T10:37:40-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Handle Errors in a Node App]]></title>
    <link href="http://jaketrent.com/post/handle-errors-node-app/"/>
    <updated>2016-08-23T16:34:00-06:00</updated>
    <id>http://jaketrent.com/post/handle-errors-node-app</id>
    <content type="html"><![CDATA[<p>As with any software, here you can expect the unexpected.  Node apps experience errors as well.  Let's say that an error crops in our Node API -- what should we do about it?</p>

<p><img src="http://i.imgur.com/1arT8Ho.jpg" alt="nodejs" /></p>

<!--more-->


<p>Errors can be handled in a lot of different ways.  "Handling" in this article will essentially mean error response messaging.</p>

<h4>Specific Messages are Best</h4>

<p>When handling errors, we should do so as specifically and quickly as possible.  As an example, if we can respond to a request that causes an error with a more specific error message, this would be better than responding with a generic, catch-all message.  This first message:</p>

<p><code>
{ errors: [{ title: 'Title field missing', source: '/data/attributes/title' }] }
</code></p>

<p>is better than this:</p>

<p><code>
{ errors: [{ title: 'Bad request' }] }
</code></p>

<p>But <em>some</em> error messaging is better than nothing.</p>

<p>So, starting with the most specific handling cases and going to the most generic.</p>

<h2>Handle Specific Business Errors</h2>

<p>Let's say that we have an endpoint that creates a new book in our books database, requested at <code>POST /books</code>.  It validates the request body data shape to ensure sufficient and correct data is entered for new books.  Let's say that a user submits a new book without the required title field.  It would be great to have specific response that tells the client what exactly is wrong.  The controller code, in part, might look like this in <a href="https://expressjs.com/">Express</a>:</p>

<p>```js
router.post('/books', (req, res, next) => {
  const errors = validate(req.body.data)
  if (errors) {</p>

<pre><code>saveBook(req.body.data, (_, newBook) =&gt; {
  res.status(201).json({ data: newBook })
})
</code></pre>

<p>  } else {</p>

<pre><code>res.status(400).json({ errors })
</code></pre>

<p>  }
})
```</p>

<p>That last line is the error response with specific error messages.  These messages are presumeably generated by the <code>validate</code> function.  We can provide a specific <code>bad request</code> response status code with a <code>400</code>.  We can provide the specific error response body, which would look like:</p>

<p><code>
{ errors: [{ title: 'Title field missing', source: '/data/attributes/title' }] }
</code></p>

<h2>Catch All Other Errors*</h2>

<p>Now there are other errors that might occur that we either haven't, don't want, or will never be able to anticipate enough to provide specific handling for.  In these cases, we still want to handle the error, but we'll only be able to provide minimal value and insight into the nature of the error to clients in the responses.</p>

<p>Let's adjust our controller code to handle potentially errors that might happen in the book saving process.  What could happen?  Anything... like database issues with connections, constraints, locks or just something bad in our code.  In our callback, let's do something with that potential error:</p>

<p>```js
router.post('/books', (req, res, next) => {
  const errors = validate(req.body)
  if (errors) {</p>

<pre><code>saveBook(req.body, (err, newBook) =&gt; {
  if err return next(err) // new line

  res.status(201).json({ data: newBook })
})
</code></pre>

<p>  } else {</p>

<pre><code>res.status(400).json({ errors })
</code></pre>

<p>  }
})
```</p>

<h4>Required Error Contract</h4>

<p>The <code>err</code> that comes back should be an <code>Error</code> or a subtype that at least follows the error contract and has the 3 required fields of <code>name</code> to identify the type of error, <code>message</code> for the human readable main issue of the error, and <code>stack</code> a string of the accurate location and stack trace of the error.</p>

<h4>Express' <code>next</code> for Errors</h4>

<p>The <code>next</code> function in <a href="https://expressjs.com/">Express</a> will advance to the next middleware.  In the case of passing a non-null value to <code>next</code>, remaining normal middleware will be skipped and the first error middleware will be executed.  Error middleware functions have an arity of 4 parameters instead of the usual 3, where <code>err</code> is the first parameter.  Here's a basic catch-all error handler:</p>

<p><code>js
app.use((err, req, res, next) =&gt; {
  res.status(500).json(serializeError(err))
})
</code></p>

<p><code>serializeError</code> is just going to take that and transform it into something to push across the network in the response.</p>

<p><code>
function serializeError(err) {
  return { errors: [{ status: 500, title: err.message, stack: err.stack }] }
}
</code></p>

<h4>Don't Leak Stacktraces</h4>

<p>Let's add a little something else here.  We probably don't want to leak the stack trace to our users in production, so let's protect it by detecting <code>NODE_ENV</code> and update it to be something like:</p>

<p>```
function serializeError(err) {
  const body = { status: 500, title: err.message }
  if (process.env.NODE_ENV !== 'production')</p>

<pre><code>body.stack = err.stack
</code></pre>

<p>  return { errors: [payload] }
}
```</p>

<p>Even better.  Generic errors handled.</p>

<h2>Crash On the Rest</h2>

<p>Now note the asterisk on the previous section.  We aren't actually able to catch <em>all</em> errors in that generic "catch-all" error handler.  To illustrate, let's create two new routes.  The first is a route that does nothing but throw a new <code>Error</code>:</p>

<p><code>js
router.get('/debug/error', (req, res, next) =&gt; {
  throw new Error('Test explosion')
})
</code></p>

<p>The above route, if requested at <code>GET /debug/error</code>, would throw a new Error and it would be caught by the generic error handler of the previous section.  This is because <code>throw</code> delivers that new <code>Error</code> synchronously.  It stays in the context of the current call stack of the request through Express middleware.  And Express can catch the <code>Error</code> and call your first error-handling middleware.</p>

<h4>Out-of-Context Errors</h4>

<p>But we can easily break out of this context and bypass the catch-all handler entirely.  All we have to do is use a <code>setTimeout</code>.  Calling <code>setTimeout</code> will queue a new message for the event loop to, at some later tick of the clock, run the enclosed function.  Within that function, we'll throw another <code>Error</code>:</p>

<p>```js
router.get('/debug/crash', (req, res, next) => {
  setTimeout(_ => {</p>

<pre><code>throw new Error('Error outside request context')
</code></pre>

<p>  }, 1000)
})
```</p>

<h4>Let the Process Die</h4>

<p>And now there's really nothing that Express can do to help us.  The <code>Error</code> will instead bubble up to the Node process running our app.  That process gives us one final opportunity to know about the occurrence of such a fatal error.  Once we know about it, we can log it.  Perhaps we can get off a call to our monitoring service.  After that, we should assume our process is compromised, potentially unstable, and just crash.  Then use a tool like <a href="https://github.com/foreverjs/forever">forever</a> to detect the downed process and restart it.  Such a crash handler might look like:</p>

<p>```js
  process.on('uncaughtException', err => {</p>

<pre><code>log.fatal({ err }, 'uncaught exception')

process.nextTick(_ =&gt; process.exit(1))
</code></pre>

<p>  })
```</p>

<p>The call to <code>process.nextTick</code> is meant to give some leeway for just enough processing time to finish those last ditch logging/monitoring efforts.</p>

<p>Now we have caught all the errors, in hopefully the best and most helpful way possible.</p>

<p>What other things have you done in your app to make Node error handling better?</p>

<h5>Great Resources</h5>

<ul>
<li><a href="https://www.joyent.com/node-js/production/design/errors">Joyent Production Practices</a> for all-around design practices</li>
<li><a href="https://expressjs.com/en/guide/error-handling.html">Express Error Handling</a> for framework-specific understanding</li>
<li><a href="http://jsonapi.org/format/#error-objects">JSON-API Error Objects</a> for sensible info to include in an error response</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">MDN Event Loop</a> for basics on the message queue in the event loop</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Console.log Deep Objects]]></title>
    <link href="http://jaketrent.com/post/console-log-deep-objects/"/>
    <updated>2016-03-14T15:13:00-06:00</updated>
    <id>http://jaketrent.com/post/console-log-deep-objects</id>
    <content type="html"><![CDATA[<p>With deep object structures, <code>console.log</code> can leave you wondering what's down in the depths of the objects you're printing out.  Here's a quick help from Node stdlib.</p>

<p><img src="http://i.imgur.com/00WAox4.jpg" alt="console.log deep objects" /></p>

<!--more-->


<p>You can usually see the objects that you're <code>console.log</code>ing, and life is good:</p>

<p>Given:</p>

<p><code>js
const stickers = {
  are: 'fun'
}
console.log('stickers', stickers)
// Outputs: stickers { are: 'fun' }
</code></p>

<p>We can see the whole object, and we're happy.  We can even do objects up to a depth of 3 sub objects, and it works great:</p>

<p>```js
const stickers = {
  are: {</p>

<pre><code>even: {
  more: 'fun'
}
</code></pre>

<p>  }
}
console.log('stickers', stickers)
// Outputs: stickers { are: { even: { more: 'fun' } } }
```</p>

<p>If, however, we have a potentially deeply-nested object, we'll get some of our data truncated:</p>

<p>```js
const stickers = {
  are: {</p>

<pre><code>even: {
  more: {
            than: {
                outrageously: 'fun'
            }
        }
}
</code></pre>

<p>  }
}
console.log('stickers', stickers)
// Outputs: stickers { are: { even: { more: [Object] } } }
```</p>

<p><code>[Object]</code>s are cool and all, but not very informative.</p>

<p>To get at this information, use <a href="https://nodejs.org/api/util.html#util_util_inspect_object_options"><code>util.inspect</code></a> from the <a href="https://nodejs.org/api/util.html#util_util_inspect_object_options">stdlib</a>.  Here, you can set a depth option to be higher, letting you peer into those deep objects in the console:</p>

<p>```js
const util = require('util')
const stickers = {
  are: {</p>

<pre><code>even: {
  more: {
            than: {
                outrageously: 'fun'
            }
        }
}
</code></pre>

<p>  }
}
console.log('stickers', util.inspect(stickers, { depth: 4 }))
// Outputs: stickers { are: { even: { more: { than: { outrageously: 'fun' } } } } }
```</p>

<p>Your data is yours again!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Node Skills to Explore]]></title>
    <link href="http://jaketrent.com/post/node-skills-explore/"/>
    <updated>2016-01-26T10:00:00-07:00</updated>
    <id>http://jaketrent.com/post/node-skills-explore</id>
    <content type="html"><![CDATA[<p>We are hiring a bunch of Node.js developers at the moment.  You may be as well.  I'm sure you have a good list of skills that you're looking for in developers that join your posse.  Here are a few <em>technical</em> things I think about when getting the opportunity  to sit down with a Node developer.</p>

<p><img src="http://i.imgur.com/9WglUIw.jpg" alt="Exploring Node Skills" /></p>

<!--more-->


<p>What might you add to the list?</p>

<h2>Async Programming</h2>

<ul>
<li>What are options for async flow control?  Favorites?  Least?  Pros?  Cons?</li>
<li>Node event loop -- How does it work?  What applications does it fit?</li>
</ul>


<h2>Error Handling</h2>

<ul>
<li>Limitations/advantages in handling async errors?</li>
<li>Handle errors in Promises?</li>
<li>Handle errors in callbacks?</li>
<li>What errors should be thrown?</li>
</ul>


<h2>Functional</h2>

<ul>
<li>What is immutability?  Why want it?</li>
<li>Basic Array.prototype methods?</li>
<li>What does shared state give you?</li>
<li>Advantages to pure functions?</li>
<li>Applications of higher-order functions?</li>
</ul>


<h2>API</h2>

<ul>
<li>Specifically, how does CORS work?</li>
<li>Familiar with which request and response formats?  Favorite?  Worst?  Why?</li>
<li>How does middleware work?  When do you like to use it?</li>
</ul>


<h2>Ops</h2>

<ul>
<li>How can you use all CPUs on a server?</li>
<li>How to associate logs together with a single request path?</li>
<li>How to recover from fatal errors?</li>
<li>How do you load per-environment configuration?</li>
<li>How do you handle versioning of your apps and libs?</li>
</ul>


<h2>Modules</h2>

<ul>
<li>Why use modules?</li>
<li>How do you organize your API apps' modules?</li>
<li>Flavors of exports?  When do use each?</li>
</ul>


<h2>ES Next</h2>

<ul>
<li>Which new features have you used?  Like, not like?</li>
<li>async/await - Used instead of what?</li>
<li>Object literal extensions - How used?</li>
<li>Spread operator - Helpful usecases?</li>
<li>Arrow functions - What do they help with?</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[List Npm Scripts]]></title>
    <link href="http://jaketrent.com/post/list-npm-scripts/"/>
    <updated>2015-03-02T07:44:00-07:00</updated>
    <id>http://jaketrent.com/post/list-npm-scripts</id>
    <content type="html"><![CDATA[<p>Tools for storing and then later easily running scripts alias names are awesome.  Npm is one of those tools.  Rake is another.  Rake has a cool feature of allowing you to list the scripts available to you.  Npm has not -- until now.</p>

<p><img src="http://i.imgur.com/ZDCd9u1.png" alt="npm" /></p>

<!--more-->


<h2>Npm Scripts</h2>

<p>You can specify scripts in your <code>package.json</code> for later use.  They go in the <code>scripts</code> attribute:</p>

<p>```json package.json
{
  "scripts": {</p>

<pre><code>"start": "node server.js",
"dist": "webpack -p"
</code></pre>

<p>  }
}
```</p>

<p>To run these scripts, you use the <a href="https://docs.npmjs.com/cli/run-script"><code>npm run</code></a> command.  For example, type <code>npm run build</code> to actually execute the <code>webpack -p</code> command in your terminal.  <code>start</code> and <code>test</code> are specially commands to npm and do not require <code>run</code>.  Instead, you can use <code>npm start</code>.</p>

<h2>Npm List Scripts</h2>

<p>In Rake, you run <code>rake -T</code> in your terminal and all the available scripts for your project are displayed.  This allows you to see the what's potentially helpful.  You can't be expected to remember all of them, especially months later, right?</p>

<p>I certainly was having a hard time remembering all of my scripts and getting tired of typing <code>cat package.json</code>.  It didn't feel as cool as the <code>rake -T</code> experience.  I wrote a library called <a href="https://www.npmjs.com/package/npm-ls-scripts"><code>npm-ls-scripts</code></a>.  To install, run:</p>

<p><code>bash
npm install npm-ls-scripts -g
</code></p>

<p>I like installing this package globally because then the CLI binary is available globally -- it does seem applicable to all projects.  You could instead include it under project <code>devDependencies</code> if you'd like.</p>

<p>If installed globally, you can then run it with:</p>

<p><code>bash
ls-scripts
</code></p>

<p>If I was to run this in the above project, it would print:</p>

<p>```bash</p>

<h2>NPM - ls scripts</h2>

<p>start - node server.js</p>

<h2>dist - webpack -p</h2>

<p>```</p>

<p>This prints the exact code that can be executed for each script.  If I would like to add some prose around any or all of the available scripts, I can do so by adding more config data to my <code>package.json</code> that will print when I run <code>ls-scripts</code>:</p>

<p>```json package.json
{
  "config": {</p>

<pre><code>"scripts: {
   "dist": "Builds project for distribution"
}
</code></pre>

<p>  }
}
```</p>

<p>Now if I were to run the <code>ls-scripts</code> command, I would see:</p>

<p>```bash</p>

<h2>NPM - ls scripts</h2>

<p>start - node server.js</p>

<h2>dist - Builds project for distribution</h2>

<p>```</p>

<p>Cool, right?  Complete with Shakespearean prose.</p>

<h2>New: Npm Run</h2>

<p>After I had developed the above <code>npm-ls-scripts</code> tool, Npm built this feature natively into the core tool -- finally!  Now, to list available scripts, the command is intuitively to leave off the target script and instead simply type:</p>

<p><code>bash
npm run
</code></p>

<p>On the above example, this would yield:</p>

<p>```bash
Available scripts in the package:
  start</p>

<pre><code>node server.js
</code></pre>

<p>  dist</p>

<pre><code>webpack -p
</code></pre>

<p>```</p>

<p>So, they work about the same, and now it's built in!  What other cool features could you imagine this having?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Express Validator]]></title>
    <link href="http://jaketrent.com/post/testing-express-validator/"/>
    <updated>2014-03-10T07:37:00-06:00</updated>
    <id>http://jaketrent.com/post/testing-express-validator</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/ctavan/express-validator">Express-validator</a> is a <a href="http://expressjs.com/api.html#middleware">middleware for Express</a> on Node.js that can help you validate user input.  It's a lovely library.  Here's a pattern for testing code that uses it.</p>

<p><img src="http://i.imgur.com/ZfK9bv4.png" alt="express-validator" /></p>

<!--more-->


<h2>Install</h2>

<p>To get <code>express-validator</code> in your project, install with npm:</p>

<p><code>bash
npm install express-validator --save
</code></p>

<h2>Plug in the Middleware</h2>

<p>To use the middleware in your code, crack open the part of your app that sets up Express middlewares, and add in a reference to this lil beaut:</p>

<p>```coffeescript
expressValidator = require 'express-validator'</p>

<h1>...</h1>

<p>app.use express.json()
app.use expressValidator()
```</p>

<p>Note that you should insert the new <code>express-validator</code> middleware directly after the <code>json</code> middleware.  Also note that the <code>json</code> middleware, used in conjunction with <code>urlencoded</code> now <a href="http://andrewkelley.me/post/do-not-use-bodyparser-with-express-js.html">replace <code>bodyParser</code></a> to avoid deprecation warnings on startup.</p>

<h2>Validate Something</h2>

<p>Let's say you're writing a validator for new posts to a blog.  That code might look like this.</p>

<p>```coffeescript blog-new-validator.coffee
module.exports = (req) -></p>

<p>  req.checkBody('title', 'Title is required').notEmpty()
  req.checkBody('body', 'Body is required').notEmpty()</p>

<p>  !req.validationErrors() or req.validationErrors().length is 0
```</p>

<p>It checks to see if there is a title and a body given.  If there is not, the validator will return false, and there will be a validation errors array on the <code>req</code> object.  There are many <a href="https://github.com/chriso/validator.js">other assertions (provided internally by validator.js)</a> besides <code>notEmpty</code> that you can use.</p>

<h2>Validating the Validator</h2>

<p>First, setup a test helper that stubs the request, <code>req</code>, for validation:</p>

<p>```coffeescript req.coffee
expressValidator = require('express-validator')()</p>

<p>exports.stubForValidation = (done) ->
  req =</p>

<pre><code>query: {}
body: {}
params: {}
param: (name) -&gt;
  @params[name]
</code></pre>

<p>  expressValidator req, {}, -></p>

<pre><code>done(req)
</code></pre>

<p>```</p>

<p>There's nothing too incredibly special here.  It's just abstracted out of your test into a reusable helper.  The <code>req</code> object has empty objects to slap fixture data onto in your tests.  It includes a stubbed <code>param</code> function that can return params by name.  Finally, the <code>express-validator</code> middleware is called with the stubbed <code>req</code> object.</p>

<p>Now, in your test, you can simply:</p>

<ol>
<li>Stub the request before each test</li>
<li>Setup your fixture data to make the test pass (or not)</li>
<li>Assert validation errors' existence and messages</li>
</ol>


<p>```coffeescript blog-new-validator.spec.coffee
stubReq = require('req').stubForValidation
validateNew = require 'blog-new-validator'</p>

<p>describe 'blog-new-validator', -></p>

<p>  req = null</p>

<p>  beforeEach (done) -></p>

<pre><code>stubReq (r) -&gt;
  req = r
  done()
</code></pre>

<p>  it 'is invalid without title', -></p>

<pre><code>validateNew(req).should.be.false
req.validationErrors(true).title.msg.should.eql 'Title is required'
</code></pre>

<p>  it 'is invalid without body', -></p>

<pre><code>validateNew(req).should.be.false
req.validationErrors(true).body.msg.should.eql 'Body is required'
</code></pre>

<p>  it 'is valid with title and body', -></p>

<pre><code>req.body.title = 'New Blog Title'
req.body.body = 'The body of the blog.'
validateNew(req).should.be.true
</code></pre>

<p>```</p>

<p>What do you think?  Is there an easier way?  A way to get better assertions?</p>
]]></content>
  </entry>
  
</feed>
