<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nodejs | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2013-05-01T08:26:15-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LiveReload for NodeJs]]></title>
    <link href="http://jaketrent.com/post/livereload-for-nodejs/"/>
    <updated>2013-04-23T16:44:00-06:00</updated>
    <id>http://jaketrent.com/post/livereload-for-nodejs</id>
    <content type="html"><![CDATA[<p>LiveReload is a wonderful tool/strategy for being able to develop websites more quickly.  You can make a change and see it immediately shown in the browser without requiring you to manually refresh.  To do this in NodeJs with Express, you'll need just a few packages.</p>

<p><img src="http://i.imgur.com/4773D.jpg" alt="grunt" /></p>

<!--more-->


<h2>LiveReload Express</h2>

<p>If you're doing a website on Nodejs these days, you're probably using Express.  Express uses the Connect library for its middleware scheme.  Just grab one more middleware to handle the LiveReload.  It will add a little snippet of JavaScript to each of the html responses that is requested through this middleware.  First, install:</p>

<p><code>
npm install connect-livereload --save-dev
</code></p>

<p>Next, import:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">configure</span> <span class="s">&#39;development&#39;</span><span class="p">,</span> <span class="o">-&gt;</span>
</span><span class='line'>  <span class="nx">app</span><span class="p">.</span><span class="nx">use</span> <span class="nx">require</span><span class="p">(</span><span class="s">&#39;connect-livereload&#39;</span><span class="p">)</span> <span class="mi">35729</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Note that we only want to import and use the middleware when in development.  This matches the fact that we are only declaring this package as in <code>devDependencies</code>.</p>

<h2>LiveReload Grunt</h2>

<p>Now you need to something to start a livereload server, watch files for changes, and broadcast their availability.  The rest of this will be done via Grunt.</p>

<p>First, install:</p>

<p><code>
npm install grunt-cli -g
npm install grunt grunt-regarde grunt-contrib-livereload --save-dev
</code></p>

<ul>
<li><code>grunt-cli</code> will allow you to run the <code>grunt</code> command in the terminal.  Global puts the bin in your path.</li>
<li><code>grunt-regarde</code> is a file watcher.  It senses changes to the filesystem.</li>
<li><code>grunt-contrib-reload</code> will handle the pushing of new code to the browser.</li>
</ul>


<p>Next setup the <code>Gruntfile.coffee</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">module.exports = </span><span class="nf">(grunt) -&gt;</span>
</span><span class='line'>  <span class="nx">grunt</span><span class="p">.</span><span class="nx">initConfig</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nv">regarde:</span>
</span><span class='line'>  <span class="nv">style:</span>
</span><span class='line'>    <span class="nv">files: </span><span class="p">[</span><span class="s">&#39;app/static/css/*.css&#39;</span><span class="p">]</span>
</span><span class='line'>    <span class="nv">tasks: </span><span class="p">[</span><span class="s">&#39;livereload&#39;</span><span class="p">]</span>
</span><span class='line'><span class="o">&lt;/</span><span class="nx">code</span><span class="o">&gt;&lt;/</span><span class="nx">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="nx">grunt</span><span class="p">.</span><span class="nx">loadNpmTasks</span> <span class="s">&#39;grunt-contrib-livereload&#39;</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="nx">grunt</span><span class="p">.</span><span class="nx">registerTask</span> <span class="s">&#39;be-lively&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s">&#39;livereload-start&#39;</span><span class="p">,</span> <span class="s">&#39;regarde&#39;</span> <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now when you run:</p>

<p><code>
grunt be-lively
</code></p>

<p>A livereload server is going to be setup.  Then we watch for filesystem changes.  The only things we're watching are css files in our app.  You could expand the <code>files</code> array to watch more if you wish.</p>

<p>Yay!</p>

<h2>LiveReload all the Things</h2>

<p>There are many ways to make this happen.  There are numerous Node libraries, Grunt plugins, and browser plugins.  Do what works for you.  Just make it happen fast and tend it well from the beginning to the end of your project.  Almost every solution I've found is somewhat high maintenance.  This one has proven to be the same.  What have you found to be your favorite LiveReload solution, and in what environment?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Access NodeJs App on Xip.io]]></title>
    <link href="http://jaketrent.com/post/nodejs-app-on-xipio/"/>
    <updated>2013-04-23T07:22:00-06:00</updated>
    <id>http://jaketrent.com/post/nodejs-app-on-xipio</id>
    <content type="html"><![CDATA[<p>Xip.io is a DNS wildcard domain that was initially created for use on Ruby projects.  But its application is desirable across platforms.  Recently, I wanted to use Xip.io on a NodeJs project.  It was easy to make happen.</p>

<p><img src="http://i.imgur.com/PJTnZmM.jpg" alt="xip.io" /></p>

<!--more-->


<h2>Install Pow and Powder</h2>

<p>Pow is a development server that uses Xip.io.  Powder is a cli that makes working with Pow even easier.  To start, make sure that <a href="http://www.ruby-lang.org/en/downloads/">Ruby</a> is setup with <a href="http://rubygems.org">Rubygems</a> in your environment.  Then install Pow.  They have a short little install script you can run, as <a href="http://pow.cx/">referenced on the Pow site</a>.</p>

<p>Then install Powder:</p>

<p><code>
gem install powder
</code></p>

<h2>Proxy your NodeJs app</h2>

<p>Pow only knows how to handle Rack apps, so we have to create one to be loaded into Pow.  Since we're writing the guts of our app on another platform -- in this case, Node -- we'll just create a proxy Rack app.</p>

<p>I found a bit of <a href="https://github.com/linjunpop/node-with-pow">proxy app code</a>, which you should save in your project root as <code>config.ru</code>, and which I paste here:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s2">&quot;net/http&quot;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;class ProxyApp</span>
</span><span class='line'><span class="sr">  def call(env)&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">begin</span>
</span><span class='line'>  <span class="n">request</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
</span><span class='line'>  <span class="n">headers</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">env</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">key</span> <span class="o">=~</span> <span class="sr">/^http_(.*)/i</span>
</span><span class='line'>      <span class="n">headers</span><span class="o">[</span><span class="vg">$1</span><span class="o">]</span> <span class="o">=</span> <span class="n">value</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">http</span> <span class="o">=</span> <span class="no">Net</span><span class="o">::</span><span class="no">HTTP</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">3000</span><span class="p">)</span>
</span><span class='line'>  <span class="n">http</span><span class="o">.</span><span class="n">start</span> <span class="k">do</span> <span class="o">|</span><span class="n">http</span><span class="o">|</span>
</span><span class='line'>    <span class="n">response</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">request_method</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>
</span><span class='line'>    <span class="o">[</span><span class="n">response</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">to_hash</span><span class="p">,</span> <span class="o">[</span><span class="n">response</span><span class="o">.</span><span class="n">body</span><span class="o">]]</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNREFUSED</span>
</span><span class='line'>  <span class="o">[</span><span class="mi">500</span><span class="p">,</span> <span class="p">{},</span> <span class="o">[</span><span class="s2">&quot;Server is down, try $npm start&quot;</span><span class="o">]]</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">run</span> <span class="no">ProxyApp</span><span class="o">.</span><span class="n">new</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The only change you might have to make is the port number for your app (line 13).  In this case, I'm using port 3000 for my NodeJs app.</p>

<h2>Link Your App</h2>

<p>Now all we have to do is link our app to Pow.  Powder helps us do this easily.  Go to your project root directory and type:</p>

<p><code>
powder link &lt;project_name&gt;
</code></p>

<p>Now run your app with whatever command starts NodeJs.  It's probably something like this:</p>

<p><code>
node app.js
</code></p>

<p>Now you should be able to access your app via your web browser at <code>http://&lt;project_name&gt;.dev</code>.  One of the great things about Xip.io is that it makes running your local app <a href="http://jaketrent.com/post/run-pow-server-on-vm/">extremely easy from a local Virtual machine</a> as well.  To get the address of your app to use in your VM, type this from your native terminal:</p>

<p><code>
powder open --xip
</code></p>

<p>And copy the resulting URL into your VM web browser.</p>

<p>Ah, the fusion of Node and Ruby is pretty sweet.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploy Yeoman App on Heroku]]></title>
    <link href="http://jaketrent.com/post/yeoman-app-on-heroku/"/>
    <updated>2013-04-23T07:12:00-06:00</updated>
    <id>http://jaketrent.com/post/yeoman-app-on-heroku</id>
    <content type="html"><![CDATA[<p>Yeoman is great developer tool that will help you generate a project format that is easy to get up and running quickly.  Out of the box, Yeoman only generates static sites.  But, with a few small tweaks, you can get it running on an app server, Nodejs, and up on Heroku.</p>

<p><img src="http://i.imgur.com/1Mc2kXh.jpg" alt="Yeoman" /></p>

<!--more-->


<h2>New Project With Yeoman</h2>

<p>To install Yeoman, run:</p>

<p><code>
npm install -g yo
</code></p>

<p>Now navigate to your new project directory and generate the scaffolding by running:</p>

<p><code>
yo webapp
</code></p>

<p>There are other generators, specifically for angularjs or a handful of other frameworks.  To see more options, run:</p>

<p><code>
yo --help
</code></p>

<h2>Add Node for Heroku</h2>

<p>Since Yeoman creates a static site, it should be read to serve out of any old web server.  But Heroku specifically wants an app server.  Node is one of the options, and it's a great option for a lightweight app server.</p>

<p>To get the node dependencies you need, create a <code>package.json</code> via:</p>

<p><code>
npm init
</code></p>

<p>Then pull down the dependencies you'll need:</p>

<p><code>
npm install gzippo express coffee-script --save
</code></p>

<p>Now create your app server, <code>web.coffee</code>.  It's about as light as they come:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">gzippo = </span><span class="nx">require</span> <span class="s">&#39;gzippo&#39;</span>
</span><span class='line'><span class="nv">express = </span><span class="nx">require</span> <span class="s">&#39;express&#39;</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nv">app = </span><span class="nx">express</span><span class="p">()</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">use</span> <span class="nx">express</span><span class="p">.</span><span class="nx">logger</span> <span class="s">&#39;dev&#39;</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">use</span> <span class="nx">gzippo</span><span class="p">.</span><span class="nx">staticGzip</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">__dirname</span><span class="si">}</span><span class="s">/dist&quot;</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">listen</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">PORT</span> <span class="o">||</span> <span class="mi">5000</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It's going to be serving the static resources that you build w/ Yeoman/Grunt that end up in the <code>dist</code> directory.  In order for code to get to Heroku, it needs to be commited to your git repo.  Thus, you need to remove the "dist" line from your <code>.gitignore</code> file, and don't forget to add and commit the files to git as you build them.  You may also have to add more tasks to the <code>Gruntfile.js</code> to copy over any other assets to <code>dist</code> that your app needs to run.</p>

<p>Finally create a <code>Procfile</code> file for Heroku in the root of your project that points to the <code>web.coffee</code> server:</p>

<p><code>
web: coffee web.coffee
</code></p>

<p>Now it's time to push to Heroku.  You should have the Heroku Toolbelt installed and create a heroku url by running:</p>

<p><code>
heroku create &lt;my_project&gt;
</code></p>

<p>To test your yeoman app as it will be run in production, first build it:</p>

<p><code>
grunt build
</code></p>

<p>Then run the grunt server:</p>

<p><code>
grunt server:dist
</code></p>

<p>Or if you have foreman and want to run the app using your <code>Procfile</code>, run:</p>

<p><code>
foreman start
</code></p>

<p>It's time.  Commit your code, especially that <code>dist</code> directory, and... deploy!</p>

<p><code>
git push heroku master
</code></p>

<p>There are quite a few steps there.  What did we miss?  Or what needs more explanation?  Perhaps we just need a <code>yo heroku</code> target.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Https Redirect for Node on Heroku]]></title>
    <link href="http://jaketrent.com/post/https-redirect-node-heroku/"/>
    <updated>2013-02-26T07:33:00-07:00</updated>
    <id>http://jaketrent.com/post/https-redirect-node-heroku</id>
    <content type="html"><![CDATA[<p>When your app requires users to be using the <code>https</code> protocol to make requests and get responses, it's helpful to have an automatic redirect so the user is always in the right place.  Here's how to do that for a Node Express app on Heroku.</p>

<p><img src="http://i.imgur.com/5rZ8H.png" alt="NodeJs Https Redirect" /></p>

<!--more-->


<h2>Secure Express Requests</h2>

<p>The <a href="http://expressjs.com">Express</a> request object has a bunch of great information.  One of its attributes is <code>secure</code>.  It's a boolean.  Usually, <code>secure == true</code> will mean that you're on <code>https</code>.  When that is not true, you're ready for a redirect.</p>

<p>Unfortunately for apps hosted on Heroku, <code>request.secure</code> will always be false.  The way that Heroku routing works, it will just never be set.</p>

<h2>Heroku Https Header</h2>

<p>Instead, Heroku forwards an http header that allows us to do the same "is secure" test.  On Heroku, <code>request.header('x-forwarded-proto')</code> will contain the actual protocol string (eg, 'http' or 'https').</p>

<h2>Express Middleware SSL Redirect</h2>

<p>If you're using the Express framework on Node, then you have it easy.  There's already a great middleware mechanism for you to send any or all requests through.  If you set your Express app (v3) up like this:</p>

<p><code>coffeescript
app = express()
</code></p>

<p>Then you can use the <code>app.use</code> functionality to specify a middleware.  Since I only have certificates and want the redirect to happen in the production environment, I will likewise wrap this middleware inside <code>app.configure</code> for prod (it inspects <code>NODE_ENV</code> for you).  This redirect will be pretty rudimentary, but it's just that simple, so here it goes:</p>

<p>```coffeescript
app.configure 'production', ->
  app.use forceSsl(req, res, next) -></p>

<pre><code>if req.header 'x-forwarded-proto' != 'https'
  res.redirect "https://#{req.header 'host'}#{req.url}"
else
  next()
</code></pre>

<p>```</p>

<p>If it's not <code>https</code> already, redirect the same url on <code>https</code>.  If it is, that's what I want, and you can pass on through my middleware function.  Note that this middleware will protect <em>all</em> urls on the site with an <code>https</code> redirect.  Your middleware could be more selective.  You could even create this as a stacked middleware per route if you wanted.  We could even enhance our middleware to use inspect both the http header <em>and</em> the <code>secure</code> flag.</p>

<p>Heroku threw us a for a minor, unexpected loop, but it was nothing that we couldn't easily code for.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smashing Node Review]]></title>
    <link href="http://jaketrent.com/post/smashing-node-review/"/>
    <updated>2013-01-29T16:51:00-07:00</updated>
    <id>http://jaketrent.com/post/smashing-node-review</id>
    <content type="html"><![CDATA[<p>Node.js is everywhere.  There's a lot of room for people to learn and get into it.  A good starter book is <a href="http://amzn.to/14ttetp">Smashing Node by Guillermo Rauch</a>.  Here's what I thought and what I learned while reading it.</p>

<p><img src="http://i.imgur.com/hQTBeAF.jpg" alt="Smashing Node" /></p>

<!--more-->


<h2>Overall</h2>

<p>Overall, I would call Smashing Node an introduction to Node book.  This is a good thing.  It does a nice job of building on itself.  It starts with the JavaScript that everyone knows and advances to the new places that Node allows you to go.  The chapters are incremental.</p>

<p>It's a good length.  This is not a tome that you might pick up in a level 3 dungeon in order to boost your fire magic.  You can read a couple chapters a day and be done in a week.  Thankfully, it's in consumable-sized bits.  Maybe you'll end up boosting your fire magic a bit too.</p>

<p>The book boasts a fair breadth of subjects.  It introduces purely syntax subjects.  It also expands into working examples dealing with real network protocols and database apis.</p>

<h2>Style</h2>

<p>Guirremo has a very easy-to-read, conversational style.  I value this more and more in books -- perhaps even especially in technical books.  It helps me engage.  It helps me read faster and more.  I can read API docs when I need them.  A book should not read like an API doc.</p>

<p>Most subjects in the book were chosen well.  I enjoyed almost all of them.  There always is a bottom of the list, however, and mine ended with the MySQL, HTTP, and TCP chapters.  Knowledge on those subjects is probably good to have, but I had to slog through these chapters.</p>

<p>The code examples were enjoyable because they eventually turned into functional prototypes.  We built a Twitter client, an IRC chat, a social DJ program, and more.  That's pretty cool.  The downside was that the code examples could get a little long.  And with the entire working example, complete with all the npm commands and boilerplate code, sometimes the meaningful bits got a little obscured.  I read the book as a <a href="http://amzn.to/14ttetp">Kindle book</a> on a phone, so the long code snippets probably seemed even longer than they were.</p>

<h2>Highlight Subjects</h2>

<h4>Express Features</h4>

<p>I use <a href="http://expressjs.com/">Express</a> more than any other library in Node.  It's a great HTTP request/response wrapper that makes creating web servers fun and easy.  Even so, this book introduced a number of features of the library that I was previously unaware of.  Generally, I think it helped illuminate for me a lot of the bits of Connect, which functions underneath Express.  Specifically, did you know that you can modify the Express logger to log specific request tokens of your choosing?</p>

<h4>Redis</h4>

<p>There was a great section that took a look at <a href="http://www.mongodb.org/">Mongo</a>, <a href="http://www.mysql.com/">MySQL</a>, and <a href="http://redis.io/">Redis</a>.  I enjoyed the chapter on Redis the most.  This is probaby somewhat because I have the most to learn in Redis and have used it the least.  I was also impressed at the ease with which Guirremo layed out a simple social graph using the Redis API.  The chosen tools, Node and Redis, made it simple, short, and elegant.</p>

<p>Try writing many of the code examples in this book in Java and printing them on dead trees.  You'll need a bigger backpack.</p>

<h4>Testing</h4>

<p>I enjoyed the fact that testing was even mentioned.  A few testing styles and frameworks were introduced.  It was enjoyable but very light.  It would be cool to see a more thorough treatment, perhaps with applicable tests worked into the examples throughout the book.</p>

<p>In this same vein, I think the book did an ok job at addressing the subject of error handling.  I think this book and other Node resources and educators should focus more on this issue.  It is, after all, more important in Node's single-threaded environment than on most platforms.</p>

<h4>Web Sockets</h4>

<p>I had only previously done web sockets via <a href="http://socket.io/">Socket.IO</a>, a web socket wrapper written by the author of the book.  It was good to see vanilla web sockets in action so I could better understand the technology, its limitations, and be grateful for the great libraries that help it be more useful and easy to use.</p>

<h4>Great Libraries</h4>

<p>The booked worked in usages of some great libraries throughout the coding examples.  As mentioned, <a href="http://socket.io/">Socket.IO</a> is a great web socket wrapper.  <a href="https://github.com/visionmedia/superagent">Superagent</a> is a great higher-level request API.  <a href="http://visionmedia.github.com/mocha/">Mocha</a> is a fantastic test framework.  And <a href="http://mongoosejs.com/">Mongoose</a> provides a nice model layer on top of the native MongoDb calls.</p>

<p>So, what are you waiting for?  Go learn Node!  Use this book to help you.</p>
]]></content>
  </entry>
  
</feed>
