<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cors | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/cors/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-06-18T08:00:45-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Expose HTTP Headers in CORS]]></title>
    <link href="http://jaketrent.com/post/expose-http-headers-in-cors/"/>
    <updated>2014-09-15T09:42:00-06:00</updated>
    <id>http://jaketrent.com/post/expose-http-headers-in-cors</id>
    <content type="html"><![CDATA[<p>For APIs, it seems more and more data is making its way into the HTTP headers.  Recently, whilst adding a <code>Link</code> header, for paging data, into the HTTP response, I realized that my browser code couldn't see it.  Who was the culprit?  CORS, of course.</p>

<p><img src="http://i.imgur.com/JAce7py.jpg" alt="Cors" /></p>

<!--more-->


<h2>Headers in Browser</h2>

<p>It was just another day, and I was developing in my browser of choice, Chrome, known, in part, for its unequaled developer tools.  The <code>Link</code> header that I had added onto my HTTP responses for my API were viewable from the Network tab.  It looked good.  The browser could see it, curl could even see it.</p>

<p>In the browser client code, I was using <code>superagent</code>, but the code failed to see it.  I'd run:</p>

<p><code>js
var request = require('superagent')
request.get('myApi').end(function (err, res) {
  res.xhr.getResponseHeader('Link') // nothing
  res.headers.link // nothing
})
</code></p>

<p>And the header was not coming through.  I ran the same command in the console, <code>res.xhr.getResponseHeader('Link')</code>, and got the error response:</p>

<p><code>
Refused to get unsafe header ‘Link’
</code></p>

<p>These are a classic CORS symptoms.</p>

<h2>CORS Spec</h2>

<p>Well, a few great <a href="http://blog.import.io/tech-blog/exposing-headers-over-cors-with-access-control-expose-headers">google results</a> later, I ended up at the <a href="http://www.w3.org/TR/cors/#simple-response-header">CORS spec</a>, which drones on that only simple headers are allowable in CORS requests by default.  These headers include:</p>

<ul>
<li>Cache-Control</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Pragma</li>
</ul>


<p><code>Link</code> is definitely not on that list.  So, how to add it?</p>

<h2>Access-Control-Expose-Headers in rack-cors</h2>

<p>Like the other CORS headers, the <code>Access-Control-</code> prefix is present.  The one you're looking for is <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS"><code>Access-Control-Expose-Headers</code></a>.  It is a comma-separated list of header names. You can add this header manually to your response, or depending on the library you're using, it might be added differently.</p>

<p>I was using <code>rack-cors</code>.  Thus, my addition ended up looking something like:</p>

<p>```ruby config/application.rb</p>

<h1>...</h1>

<p>config.middleware.use Rack::Cors do
  allow do</p>

<pre><code>origins '*'
resource '*', :headers =&gt; :any, :methods =&gt; [:get, :post, :put, :delete, :options], :expose =&gt; ['Link']
</code></pre>

<p>  end
end
```</p>

<p>Can you see that the <code>expose</code> key was the key for me?  Once that was added, the browser let the client code read the link, and all was safe and well.</p>

<h2>Bonus:</h2>

<p>As a bonus, here's a great client library for consuming a <a href="https://developer.github.com/v3/#link-header">GitHub API-style</a> <code>Link</code> header, called <a href="https://www.npmjs.org/package/parse-link-header">parse-link-header</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make Jsonp Requests with AngularJs]]></title>
    <link href="http://jaketrent.com/post/make-jsonp-requests-with-angularjs/"/>
    <updated>2013-03-20T07:08:00-06:00</updated>
    <id>http://jaketrent.com/post/make-jsonp-requests-with-angularjs</id>
    <content type="html"><![CDATA[<p>There are a couple ways to make cross domain requests from a client browser.  One method is called Jsonp or Json with padding.  The AngularJs library makes this really simple.</p>

<p><img src="http://i.imgur.com/wVBKD.png" alt="AngularJs Jsonp" /></p>

<!--more-->


<h2>Web Server Support</h2>

<p>First of all, your Jsonp request will be worth nothing if the server you're requesting data from does not support it.  Jsonp requests require explicit support on the server side.  This is because the data that's returned is formatted differently.  The 'p' in Jsonp stands for padding.</p>

<p>But that's kind of a weird name.  Maybe Jsonf would be more analogous to reality.  This is because the Json data that you seek is really wrapped in a Javascript function.  This function is then evaluated as a script, passing the data into a callback to be saved by your client program.</p>

<p>This essentially is a browser hack to get around the security constraint of browsers not being able to request non-script items from different domains.  But since we request Javascript this way all the time, we'll just make our data look like Javascript.</p>

<h2>Angular Jsonp</h2>

<p>You're probably already used to using the <code>$http</code> service.  It provides the normal <code>get</code>, <code>post</code> and other functions mapped to http methods.  It also provides the function that we'll need: <code>jsonp</code>.</p>

<p>The client script also requires that we specify the callback to send data to.  AngularJs has its own callback pattern, so it would follow that it has a pattern to handle Jsonp callbacks.  It does.  The callback is always called <code>JSON_CALLBACK</code>.  What parameter that it's assigned to in the query string depends on the design of the web service you're calling.  Take a look at the documentation on what's required there.</p>

<p>All that jibber jabber for this simple example of a script asking for <a href="http://colorwheelie.tumblr.com">Tumblr</a> data:</p>

<p>```coffeescript
$http.jsonp 'http://api.tumblr.com/v2/blog/colorwheelie.tumblr.com/posts/photo?api_key=<mykey>&amp;callback=JSON_CALLBACK'
  .success (data) -></p>

<pre><code> $scope.colorwheelies = data.response.posts;
</code></pre>

<p>  .error (data) -></p>

<pre><code> console.log('ERROR');
</code></pre>

<p>```</p>

<p>The interesting line is line one.  We call the <code>jsonp</code> function.  We assign our callback like this: <code>callback=JSON_CALLBACK</code>.  And in our success callback, we can consume our data variable like it was pure Json.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cross-Domain RequireJs Text]]></title>
    <link href="http://jaketrent.com/post/cross-domain-requirejs-text/"/>
    <updated>2012-06-07T13:11:00-06:00</updated>
    <id>http://jaketrent.com/post/cross-domain-requirejs-text</id>
    <content type="html"><![CDATA[<p>Through long-available browser quirks/features, javascript has been available for requests across disparate domains.  But, other resources, such as text files (eg, handlebars templates) have had more restrictions placed on them.  Recently, CORS support has enhanced the ability to make these requests.  Here's how you get your text files from another domain via requirejs.</p>

<!--more-->


<h2>CORS</h2>

<p><a href="https://developer.mozilla.org/en/http_access_control">CORS</a> is a great feature for modern browsers that allows a site on a domain A to request a resource from domain B without restriction, because domain B already said that it's willing to accept those requests. In an <a href="http://remysharp.com/2011/04/21/getting-cors-working/">article on CORS by Remy Sharp</a>, he outlines in more detail how to setup your server to be CORS ready.  Simply, it comes down to the server responding with an http header.  To allow all sites to request a server's resources:</p>

<p><code>http
Access-Control-Allow-Origin: *
</code></p>

<p>To allow a whitelist of sites to request resources, the server must give the same header with only certain sites listed:</p>

<p><code>http
Access-Control-Allow-Origin: http://rockycode.com http://builtbyjake.com
</code></p>

<p>What servers can <a href="http://html5please.com/#cors">support CORS</a>?  Firefox and Chrome have supported it for some time.  IE8 has its own Microsoft flavor.  iOS and Android also have strong support for a few version back.  Check out the <a href="http://caniuse.com/cors">detailed stats on caniuse.com</a>.</p>

<h2>RequireJs</h2>

<p><a href="http://requirejs.org/">RequireJs</a> Is a fantastic Javascript loader that allows for client-side async loading of js and other static assets.  For textual, non-code things, there is a <a href="http://requirejs.org/docs/download.html#text"><code>text</code> plugin</a>.</p>

<p>Because RequireJs knows about non-CORS-enabled browser restrictions, by default it functions differently for cross-domain requests.  In the current (2.0.0) implementation of the text plugin, line 163, the plugin decides whether to do a normal XHR (more lenient on text assets) request or to skip to the <code>else</code> statement to require what it will <a href="https://groups.google.com/group/requirejs/browse_thread/thread/bc0608ef5f8943e7/3a1cafaa93869c32">assume is javascript</a> because that's requestable across domains:</p>

<p>```js
//Load the text. Use XHR if possible and in a browser.
if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
  text.get(url, function (content) {</p>

<pre><code>text.finishLoad(name, parsed.strip, content, onLoad);
</code></pre>

<p>  }, function (err) {</p>

<pre><code>if (onLoad.error) {
    onLoad.error(err);
}
</code></pre>

<p>  });
} else {
  //Need to fetch the resource across domains. Assume
  //the resource has been optimized into a JS module. Fetch
  //by the module name + extension, but do not include the
  //!strip part to avoid file system issues.
  req([nonStripName], function (content) {</p>

<pre><code>text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                parsed.strip, content, onLoad);
</code></pre>

<p>  });
}
```</p>

<p>To allow CORS-enabled servers to get resources requested from them, we <a href="http://requirejs.org/docs/api.html#config">configure RequireJs</a> to override the <code>getXhr</code> function to return true:</p>

<p>(Note: 25 Oct 2012 - Syntax updated per Chris' comment below)</p>

<p>```js
require.config({
  config: {</p>

<pre><code>text: {
  useXhr: function (url, protocol, hostname, port) {
    // allow cross-domain requests
    // remote server allows CORS
    return true;
  }
}
</code></pre>

<p>  }
});
```</p>

<p>Now you should be able to ask for various and sundry things across domains and continue enjoy the RequireJs goodness -- now multiplied:</p>

<p><code>js
require('text!http://anotherDomain/my.html', function (my) {
  // have fun!
});
</code></p>
]]></content>
  </entry>
  
</feed>
