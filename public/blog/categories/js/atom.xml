<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: js | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/js/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-02-25T19:40:01-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sinon Spies vs. Stubs]]></title>
    <link href="http://jaketrent.com/post/sinon-spies-vs-stubs/"/>
    <updated>2015-02-25T07:35:00-07:00</updated>
    <id>http://jaketrent.com/post/sinon-spies-vs-stubs</id>
    <content type="html"><![CDATA[<p><a href="http://sinonjs.org/">Sinon</a> provides spies, stubs, and mocks.  They're all useful as fakes in tests.  They come with essential differences for what they're helpful in doing and how they work.</p>

<p><img src="http://i.imgur.com/yuKcrP9.jpg" alt="spies vs stubs" /></p>

<!--more-->


<h2>Why Use Fakes?</h2>

<p>In a unit test, you might want to avoid having to test the unit's dependencies.  This is especially true in <a href="http://en.wikipedia.org/wiki/White-box_testing">white-box testing</a>.  In this case, test fakes are going to be very helpful.  Sinon provides several fakes, notably spies, stubs, and mocks.  Let's compare and contrast the three:</p>

<h2>Sinon Spies</h2>

<p>Spies sound like what they do -- they watch your functions and report back on how they are called.  They generally avoid the violence and mayhem of a Hollywood spy, but depending on your application, this could vary.</p>

<p>They don't change the functionality of your application.  They simply report what they see.  The <a href="http://sinonjs.org/docs/#spies-api">sinon API for spies</a> is fairly large, but it essentially centers around the <code>called</code> attribute (of which there are many variations).</p>

<p>I first setup that I want to spy on something.  Then I call my subject under test (src code).  Then I verify with the spy what was actually called and stop spying.  That might look like this in a test:</p>

<p>```js
describe("#fight", function () {
  it("calls prayForStrength for fight success", function () {</p>

<pre><code>sinon.spy(subject.strengthDep, "prayForStrength");
subject.fight();
subject.strengthDep.called.should.be.true;
subject.strengthDep.restore();
</code></pre>

<p>  });
});
```</p>

<p><em>Note: this example is in <a href="http://mochajs.org/">mocha</a> using a <a href="https://www.npmjs.com/package/should">should.js</a> assertion style</em></p>

<p>The dependency's <code>prayForStrength</code> method is referred to by name in a string to setup the spy.  When <code>fight</code> is called here, <code>strengthDep.prayForStrength</code> will be called as normal -- but there will be someone watching.  Finally, we call <code>restore</code> on the function we spied on so that all spies are called off.  If you want to do more than watch as dependencies work as described, you might want to use a stub.</p>

<h2>Sinon Stubs</h2>

<p>Stubs are more hands-on than spies (though they sound more useless, don't they).  With a stub, you will actually change how functions are called in your test.  You don't want to change the subject under test, thus changing the accuracy of your test.  But you may want to test several ways that dependencies of your unit could be expected to act.</p>

<p>For instance, if you had a function that returned a boolean that your code used to do different things, you might want to use a stub in two different tests to verify conditions when returning different values (ie, guarantee one run of <code>true</code> and one of <code>false</code> return).</p>

<p>To continue the <code>fight</code> example from above, let's assume that if <code>prayForStrength</code> returns true, we are guaranteed to win the fight for the orphans (ie, <code>fight()</code> should return <code>true</code>).  That might look like this:</p>

<p>```js
describe("#fight", function () {
  it("always wins when prayForStrength is true", function () {</p>

<pre><code>sinon.stub(subject.strengthDep, "prayForStrength", function () { return true; });
subject.fight().should.be.true;
subject.strengthDep.restore();
</code></pre>

<p>  });
});
```</p>

<p>Notice that we use a different <code>sinon.stub</code> API.  For the 3rd parameter, we're supplying our own version of <code>prayForStrength</code>.  For our test, all we care about is the return value, so that's all we supply.  We're not testing this dependency.  We're instead testing how our subject <code>fight</code>s in a certain circumstance.  There are many ways you can use <a href="http://sinonjs.org/docs/#stubs">sinon stubs</a> to control how functions are called.  Also note that you can still use the <code>called</code> verifications with stubs.  But if you do verify a stub was called, you may want to use a mock.</p>

<h2>Sinon Mocks</h2>

<p><a href="http://sinonjs.org/docs/#mocks">Mocks</a> take the attributes of spies and stubs, smashes them together and changes the style a bit.  A mock will both observe the calling of functions and verify that they were called in some specific way.  And all this setup happens <em>previous</em> to calling your subject under test.  After the call, mocks are simply asked if all went to plan.</p>

<p>So the previous test could be rewritten to use a mock:</p>

<p>```js
describe("#fight", function () {
  it("always wins when prayForStrength is true", function () {</p>

<pre><code>var mock = sinon.mock(subject.strengthDep)
mock.expects("prayForStrength").returns(true);
subject.fight().should.be.true;
mock.verify();
mock.restore();
</code></pre>

<p>  });
});
```</p>

<p>The <code>expects</code> and <code>returns</code> line is where the combo magic happens.  <code>expects</code> is verifying a call (like <code>spies</code> can), and <code>returns</code> is specifying functionality (like <code>stubs</code> can).  The <code>verify</code> call is the line that will fail (essentially the mock assertion) if things in the subject didn't go exactly according to plan.</p>

<h2>Spies vs. Stubs vs. Mocks</h2>

<p>So when should I use spies or stubs or mocks?  As with most art, there are many ways to accomplish what you want.  Much of your choice will depend on your own style and what you become proficient in.</p>

<p>Some basic rules might be:</p>

<ul>
<li><strong><em>Use Spies</em></strong> - if you simply want to watch and verify somethings happens in your test case.</li>
<li><strong><em>Use Stubs</em></strong> - if you simply want to specify how something will work to help your test case.</li>
<li><strong><em>Use Mocks</em></strong> - if you want to both of the above on a single dependency in your test case.</li>
</ul>


<p>When do you find yourself most often using spies vs. stubs vs. mocks?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test React-Router Previous Params for Component Update]]></title>
    <link href="http://jaketrent.com/post/test-react-router-params-component-update/"/>
    <updated>2015-02-09T15:39:00-07:00</updated>
    <id>http://jaketrent.com/post/test-react-router-params-component-update</id>
    <content type="html"><![CDATA[<p>Once upon a time, react-router transferred params and query params from the url via props into components.  It doesn't happen this way any more.  So, let's say you have a need in your component like overriding <code>shouldComponentUpdate</code> in your component which only has access to <code>this.props</code> and <code>this.state</code>.   How can you use the url data to affect the component re-render or not?</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react" /></p>

<!--more-->


<h2>Why control rendering with the url?</h2>

<p>There are two instances that come to mind when considering the scenarios that it might be needful to control the update of your component based on the url:</p>

<ol>
<li><p><strong>Avoid re-render</strong>: Of course, if the component we're talking about is a page-level component, you'll most likely always be wanting to re-render as the url changes.  But, if you're a little widget component that cares about the url, you might not need to always re-render on url change.</p></li>
<li><p><strong>Trigger re-render when it might not otherwise happen</strong>: For whatever reason, you may have already needed to implement <code>shouldComponentUpdate</code> in your component.  This function returns true or false to flag a "should" or "should not" re-render.  You'll need to access url state and likely previous url state in this method to make re-renders happen that otherwise wouldn't if you had no logic in this function for it.</p></li>
</ol>


<p>Of course, beyond these re-render scenarios, there are many other situations in which knowing previous and current states in the url could come in handy.</p>

<h2>React-Router in shouldComponentUpdate</h2>

<p><code>shouldComponentUpdate</code> determines if component should re-render.  It's called whenever <code>this.props</code> or <code>this.state</code> changes.  It has access to incoming props and state via the function parameters.</p>

<p>React-router gives your component access to params and query params by requiring you to mix in the <code>State</code> param from react-router.  Then you have access to new functions, <code>this.getParams()</code> and <code>this.getQuery()</code>.  If you only need to know current url state, this is enough.  If you want to compare current url state to previous url state, you'll have to save the parts that you care about.  We'll do that in <code>this.state</code>.</p>

<p>Let's say that we want to trigger a redraw on changes to a <code>range</code> query parameter.  The component might, in part, look like this:</p>

<p>```
var { State } = require('react-router')</p>

<p>module.exports = React.createClass({</p>

<p>  mixins: [ State ],</p>

<p>  getInitialState() {</p>

<pre><code>range: nul
</code></pre>

<p>  },</p>

<p>  componentWillReceiveProps() {</p>

<pre><code>this.setState({
  range: this.getQuery().range
})
</code></pre>

<p>  },</p>

<p>  componentWillMount() {</p>

<pre><code>this.setState({
  range: this.getQuery().range
})
</code></pre>

<p>  }</p>

<p>  shouldComponentUpdate() {</p>

<pre><code>return this.state.range !== nextState.range
</code></pre>

<p>  }</p>

<p>  // ...</p>

<p>})
```</p>

<p>When the url params change, <code>componentWillReceiveProps</code> is called.  But this is not called on the first render, thus we implement <code>componentWillMount</code>.  Both these functions save the <code>range</code> from the url to the component state.  Now, as <code>shouldComponentUpdate</code> is called on future <code>this.props</code> and <code>this.state</code> changes, current and next <code>range</code> values can be compared and used in "should re-render" calculation.</p>

<p>What other ways have you found to accomplish this tracking of previous state in the url?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-Router with Flux]]></title>
    <link href="http://jaketrent.com/post/react-router-with-flux/"/>
    <updated>2015-01-15T09:21:00-07:00</updated>
    <id>http://jaketrent.com/post/react-router-with-flux</id>
    <content type="html"><![CDATA[<p>react-router provides great route handling with route params and query params.  Flux provides a pattern for building React apps, including a pattern from providing data to your components.  Here's a straightforward way to make route changes trigger data changes in your components.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react" /></p>

<!--more-->


<p>Note: Code here reflects usage of react-router 0.11.x.</p>

<p>It is often the case that we'll need to trigger data changes in a react component in our Flux app because of a route transition.  A prime example of this would be on an object show page, where the details of a particular object are being shown.  In our example, let's say that we're showing the details of a book, such as title, author, and description.</p>

<p>The route to our book detail page is likely defined as:</p>

<p><code>js routes.js
// ...
&lt;Route name="book" path="/books/:id" handler={require('./books-show')} /&gt;
</code></p>

<p>The handler is just a controller-component that defines the view.  It might look simply like:</p>

<p>```js books-show.js
const React = require('react')
const {State} = require('react-router')</p>

<p>const BooksStore = require('./books-store')</p>

<p>module.exports = React.createClass({</p>

<p>  displayName: 'BooksShow',</p>

<p>  mixins: [ State ],</p>

<p>  getInitialState() {</p>

<pre><code>return this.getStateFromStores()
</code></pre>

<p>  },</p>

<p>  getStateFromStores() {</p>

<pre><code>return {
  book: BooksStore.find({ id: this.getParams().id })
}
</code></pre>

<p>  },</p>

<p>  componentDidMount() {</p>

<pre><code>BooksStore.addChangeListener(this._onChange)
</code></pre>

<p>  },</p>

<p>  componentWillUnmount() {</p>

<pre><code>BooksStore.removeChangeListener(this._onChange)
</code></pre>

<p>  },</p>

<p>  _onChange: function() {</p>

<pre><code>this.setState(this.getStateFromStores())
</code></pre>

<p>  },</p>

<p>  render() {</p>

<pre><code>return (
  &lt;ul&gt;
    &lt;li&gt;{this.state.book.title}&lt;/li&gt;
    &lt;li&gt;{this.state.book.author}&lt;/li&gt;
    &lt;li&gt;{this.state.book.description}&lt;/li&gt;
  &lt;/ul&gt;
)
</code></pre>

<p>  }</p>

<p>})
```</p>

<p>Note that the view component references a <code>BooksStore</code> for getting its initial state.  The state of <code>book</code> will also be updated as the <code>BooksStore</code> emits that its data has changed and <code>this._onChange</code> is called.</p>

<p>Every time a route transitions, react-router has a <code>Router.run</code> callback that will also run in order to render the matching route.  This will also be a great place to put our action to signal to our Flux app that routes are transitioning and therefore other stuff like data in the display might need to change as well.</p>

<p><code>js
Router.run(routes, (Handler, state) =&gt; {
  React.render(&lt;Handler /&gt;, document.body)
  BooksAction.transition(state.params)
})
</code></p>

<p><strong>Important note</strong>: Make sure the transition action is called after <code>React.render</code> so that the change emission will be detected after render, otherwise you'll be one route transition behind.</p>

<p>The <code>BooksAction.transition</code> definition is something very simple -- something that can trigger events on the dispatcher:</p>

<p>```js books-actions.js
exports.transition = () => {
  AppDispatcher.handleViewAction({</p>

<pre><code>type: ActionTypes.TRANSITION
</code></pre>

<p>  })
}
```</p>

<p>The final connection is in the store, where the dispatched action can be listened for an then trigger the store event, updating the component views:</p>

<p>```js books-store.js
var BooksStore = merge(EventEmitter.prototype, {
  find(filter) {</p>

<pre><code>// ...
</code></pre>

<p>  }
})</p>

<p>BooksStore.dispatchToken = AppDispatcher.register((payload) => {
  var action = payload.action
  switch(action.type) {</p>

<pre><code>// ...

case ActionTypes.TRANSITION:
  BooksStore.emitChange()
  break
</code></pre>

<p>  }
})</p>

<p>module.exports = BooksStore</p>

<p>```</p>

<p>At this point, all the route transitions should trigger data changes in views.  Visiting the url <code>/books/1</code> and then the url <code>/books/2</code> should display different data on screen according to which book id was in the route.  <code>Router.Link</code> should work correctly, usable instead of buttons with actions being triggered on click.</p>

<p>react-router and Flux make for a great combo in this way, right?  What adjustments would you make?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[D3 Class Operations]]></title>
    <link href="http://jaketrent.com/post/d3-class-operations/"/>
    <updated>2014-12-24T10:58:00-07:00</updated>
    <id>http://jaketrent.com/post/d3-class-operations</id>
    <content type="html"><![CDATA[<p>D3 has operations for class name manipulation that you're used to from jQuery.  These include addClass, removeClass, hasClass, and toggleClass.  They just go by different names.</p>

<p><img src="http://i.imgur.com/94JQ8N8.jpg" alt="d3 class names" /></p>

<!--more-->


<h2>selection.classed</h2>

<p>The magic all comes in the form of the <code>selection.classed</code> method from d3.  It is going to be the api that is used to accomplish all the operations listed below.  From the <a href="https://github.com/mbostock/d3/wiki/Selections#classed">docs</a>:</p>

<blockquote><p>This operator is a convenience routine for setting the "class" attribute; it understands that the "class" attribute is a set of tokens separated by spaces. Under the hood, it will use the classList if available, for convenient adding, removing and toggling of CSS classes.</p></blockquote>

<p>It knows how to handle one or many classes on an element, and it will be performant.</p>

<p>Also note that this method is only available on a selection.</p>

<h2>d3 addClass</h2>

<p>To add a class, the second parameter to <code>classed</code> must be true, as in this code:</p>

<p><code>js
d3.selectAll(".bar")
 .classed("my-selector", true);
</code></p>

<h2>d3 removeClass</h2>

<p>To remove a class, the second parameter to <code>classed</code> must be false.</p>

<p><code>js
d3.selectAll(".bar")
  .classed("my-selector", false);
</code></p>

<h2>d3 hasClass</h2>

<p>To check for the existence of a class, just leave off the second parameter and pass the class name you're querying for.  This will return true if it exists, false if it does not.</p>

<p><code>js
d3.selectAll(".bar")
 .classed("my-selector");
</code></p>

<p>This will return true if any element in the selection has the class.  Use <code>d3.select</code> for single element selection.</p>

<h2>d3 toggleClass</h2>

<p>To flip a class to the opposite state  -- remove it if it exists already, add it if it does not yet exist -- you can do one of the following.</p>

<p>For a single element, the code might look like this:</p>

<p><code>js
var oneBar = d3.select(".bar")
oneBar.classed("my-selector", !oneBar.classed("my-selector"));
</code></p>

<p>For multiple elements, one will want to pass in a callback.  The callback function takes as parameters <code>d</code>, the datum, <code>i</code>, the index in the selection, and <code>this</code> is the current DOM element.</p>

<p>It's also important to note that the <a href="https://github.com/mbostock/d3/wiki/Selections#classed">docs</a> inform us that:</p>

<blockquote><p>The function's return value is then used to assign or unassign the specified class on each element.</p></blockquote>

<p>The code for toggling multiple elements in a selection at once might look like this:</p>

<p>```js
d3.selectAll("bar")
  .classed("my-selector", function (d, i) {</p>

<pre><code>return !d3.select(this).classed("my-selector");
</code></pre>

<p>  });
```</p>

<p>Here's a <a href="http://jsbin.com/qeyawa/1/edit?html,js,output">jsbin</a> that provides some toggle functionality.  Ees for fun.</p>

<p><a class="jsbin-embed" href="http://jsbin.com/qeyawa/1/embed?output">d3 toggleClass</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<h2>Bonus: A note on single active classes</h2>

<p>Here's a fun tip for that oft-encountered situation where you want a single element in a selection to have a class, like an <code>active</code> class, and the rest of the selection should not:</p>

<p>Make sure that you detect the active class in the selection previous to the clearing of the active classes.</p>

<p>A sample of what that might look like could be:</p>

<p>```js
d3.selectAll(".bar").on("click", function () {
  var activeClass = "active";
  var alreadyIsActive = d3.select(this).classed(activeClass);
  svg.selectAll(".reports-chart__bar")</p>

<pre><code>.classed(activeClass, false);
</code></pre>

<p>  d3.select(this).classed(activeClass, !alreadyIsActive);
});
```</p>

<p>Now, unleash the power of your creativity!  Kazaam!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Send Props to Children in React]]></title>
    <link href="http://jaketrent.com/post/send-props-to-children-react/"/>
    <updated>2014-08-12T16:55:00-06:00</updated>
    <id>http://jaketrent.com/post/send-props-to-children-react</id>
    <content type="html"><![CDATA[<p>In React, you're always making components.  Sometimes components are standalone.  Other times, you'll have components that can nest children components.  Sometimes you'll want to send properties to the children components from the parent as often as a doting parent wants to send packages to a child missionary.  It's possible, it's simple, and it's not documented super well.  Here's one method.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="React" /></p>

<!--more-->


<h2>Children Components</h2>

<p>When parent components are rendered, they have access to a special property, <code>this.props.children</code>.  It's like an Angular <code>ng-transclude</code> or an Ember <code>yield</code>.  Children components are generally rendered something like this:</p>

<p>```js
React.createClass({
  render: function () {</p>

<pre><code>return (
  &lt;div id="iAmParentHearMeRoar"&gt;
    {this.props.children}
  &lt;/div&gt;
)
</code></pre>

<p>  }
})
```</p>

<p>The generic example above shows simply how to render children, <code>props</code> untouched, within a parent component.  Sometimes, however, a parent wants to bequeath its children with extra properties.  How will we make that happen?</p>

<h2>Setting Child Props</h2>

<p><code>props</code> are meant to be immutable.  But, in order for us to send <code>props</code> values to our children, we're going to essentially loop through our children and set props on them as a part of our parent <code>render</code> function.</p>

<p>Deep breath.  It's ok.  The children that we'll loop through aren't mounted component instances.  They are, instead, <a href="http://facebook.github.io/react/blog/2014/07/17/react-v0.11.html#descriptors">descriptors</a>.  These descriptors have all the <code>props</code> attributes that we've declared should be put on the components, but they haven't been rendered yet.  Because of this, we can change props, and it's ok.  We're not mutating what has rendered.  The data still hasn't flowed to the children.  We're still effectively still riffing on the logic of what the children components should really be when they're eventually mounted.</p>

<h2>Looping on Children Components</h2>

<p><code>this.props.children</code> is a funny property.  It's special in more ways than one.  The things that might trip us up in looping is that even though it sounds like a plural thing, meaning an array, sometimes it's a singular object.  To help avoid potential problems, React gives us a helper, <code>React.Children</code>.  It has a few functions for array iteration, such as <code>map</code> and <code>forEach</code> that help account for the potential forms of <code>this.props.children</code>.</p>

<h2>Functional Modifications</h2>

<p>Immutable data is a big part of functional programming.  This means that when we 'mutate' the props, we want to mutate on a clone of the child component without affecting the original.  There's an input, there's an output, and the input is untouched.  Once we have our cloned children components as we want them, we'll render those instead.  React offers another great helper for cloning components and setting properties in a single function, <code>React.addons.cloneWithProps</code>.  Note that in order to use this function, you need to <code>require('react/addons')</code>.</p>

<h2>Checking Child Type</h2>

<p>It's a generally-useful thing to be able to tell what the React class type of a component object is.  It's an applicable skill in terms of looping through child components because we might not want to modify the properties of all types of children.  Each React component class has a <code>type</code> attribute accessible via <code>MyComponent.type</code>.  This attribute is also available on component descriptors.</p>

<h2>A Child CheckOption Example</h2>

<p>To bring this all together and illustrate the concepts, let's say we created a <code>RadioGroup</code> component that could take one or many <code>RadioOption</code> child components.  In raw html, which is what our component will eventually render, <code>input</code>s with type <code>checkbox</code> need to all have the same <code>name</code> attribute value to work well as toggles within the group.  But this is something that React can help us not have to duplicate.  We'll instead put a <code>name</code> property on the parent <code>RadioGroup</code> and have it transfer it as a property on all its children.  The implementation might look like this:</p>

<p>```js
/<em>* @jsx React.DOM </em>/</p>

<p>var React = require('react/addons')</p>

<p>var RadioOption = React.createClass({
  render: function () {</p>

<pre><code>return (
  &lt;label&gt;
    &lt;input type="radio" value={this.props.value} name={this.props.name} /&gt;
    {this.props.label}
  &lt;/label&gt;
)
</code></pre>

<p>  }
})</p>

<p>var RadioGroup = React.createClass({
  renderChildren: function () {</p>

<pre><code>return React.Children.map(this.props.children, function (child) {
  if (child.type === RadioOption.type)
    return React.addons.cloneWithProps(child, {
      name: this.props.name
    })
  else
    return child
}.bind(this))
</code></pre>

<p>  },
  render: function () {</p>

<pre><code>return (
  &lt;div class="radio-group"&gt;
    {this.renderChildren()}
  &lt;/div&gt;
)
</code></pre>

<p>  }
})</p>

<p>var WhereImUsingRadioGroups = React.createClass({
  render: function () {</p>

<pre><code>return (
  &lt;RadioGroup name="blizzard-games"&gt;
    &lt;RadioOption label="Warcraft 2" value="wc2" /&gt;
    &lt;RadioOption label="Warcraft 3" value="wc3" /&gt;
    &lt;RadioOption label="Starcraft 1" value="sc1" /&gt;
    &lt;RadioOption label="Starcraft 2" value="sc2" /&gt;
  &lt;/RadioGroup&gt;
)
</code></pre>

<p>  }
})
```</p>

<p>In this example, where the parent <code>RadioGroup</code> has the <code>name</code> prop, it will be given to each of the children so their <code>name</code> prop will match and the radio group will work as expected.  Thus, the hearts of the children are turned toward their fathers.</p>

<p>Is there a better way to do this?  How have you been sending <code>props</code> to children?</p>
]]></content>
  </entry>
  
</feed>
