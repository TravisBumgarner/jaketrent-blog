<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: js | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/js/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2013-09-21T11:42:29-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Import Erb Into Karma]]></title>
    <link href="http://jaketrent.com/post/import-erb-into-karma/"/>
    <updated>2013-09-20T16:59:00-06:00</updated>
    <id>http://jaketrent.com/post/import-erb-into-karma</id>
    <content type="html"><![CDATA[<p>Rails asset pipeline allows you to use erb helpers in your CoffeeScript.  You'll still need to bring get these files into Karma runner.  It's really easy.  You just need to get to know your Karma config options.</p>

<p><img src="http://i.imgur.com/i5fJT6j.png" alt="erb files in Karma runner" /></p>

<!--more-->


<h2>erb in JavaScripts</h2>

<p>Why in the world would you want to use erb helpers inside your script files?  You might not.  I definitely think this should be a limited practice.  In some cases, it can be very helpful.  For instance, if you use Ruby/Rails (via <a href="https://github.com/rumblelabs/asset_sync"><code>asset_sync</code></a>) to upload your static assets to an external server, such as S3, you can help your scripts know where static assets live after upload.</p>

<p>So your script might use the <code>asset_path</code> helper and end up looking something like this:</p>

<p>```coffeescript app.coffee.erb
angular.module('app', []).config ($routeProvider) -></p>

<p>  $routeProvider</p>

<pre><code>.when '/admin',
  controller: 'AdminIndexCtrl'
  templateUrl: "&lt;%= asset_path('admin/index.html') %&gt;"
</code></pre>

<p>```</p>

<h2>Import erb Files into Karma</h2>

<p>Well, now you have an <code>app.coffee.erb</code> file.  You need to get it into <a href="http://karma-runner.github.io">Karma runner</a>.  Normally <code>*.coffee</code> files will be brought straight in and compiled automatically by the runner as needed.  In this case, however, the Karma defaults won't recognize the <code>.coffee.erb</code> file as a CoffeeScript file need compilation.</p>

<p>To tell Karma to process your erb file as a CoffeeScript file, add this to your config:</p>

<p>```coffeescript karma.conf.coffee
module.exports = (config) ->
  config.set</p>

<pre><code># ...
preprocessors:
  '**/*.coffee.erb': ['coffee']
  '**/*.coffee': ['coffee']
</code></pre>

<p>```</p>

<p>That's it.  That's the key to getting your Erb files processed into JavaScript and ready for Karma to use.</p>

<p>Now, what are your thoughts on putting your CoffeeScripts through the erb filter of the asset pipeline at all?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Mixins]]></title>
    <link href="http://jaketrent.com/post/javascript-mixins/"/>
    <updated>2013-09-06T10:37:00-06:00</updated>
    <id>http://jaketrent.com/post/javascript-mixins</id>
    <content type="html"><![CDATA[<p>JavaScript makes mixins inherently easy.  Mixins are a native feature of the language without calling it that.  Here are a few methods for making this happen.</p>

<p><img src="http://i.imgur.com/XemDUw8.jpg" alt="JavaScript mixins" /></p>

<!--more-->


<h2>Attach a Property</h2>

<p>You can attach a property to a Javascript object at any time.  You don't need to monkey patch it.  It doesn't need to be packaged up in a very special format.  You just shove stuff onto the object.  Here's an example:</p>

<p>```javascript
var MyModel = function () {
  doOneThing: function () { console.log('doing it right'); }
};</p>

<p>var model = new MyModel();
model.doItRight = function () { console.log('everybody will be dancing'); };</p>

<p>model.doOneThing(); // => 'doing it right'
model.doItRight();  // => 'everybody will be dancing'
```</p>

<p>A function is defined.  It is instantiated.  Later, a new property, <code>doItRight</code> function, is added to it.  Both functions now magically work on the original model instance.  We could have attached to <code>MyModel.prototype</code> and had the <code>doItRight</code> function attached to all future instantiations of the function as well.</p>

<h2>Use Extend</h2>

<p>There are a couple great libraries that provide wholesale extension of object properties, just like mixins in other languages.  <a href="http://api.jquery.com/jQuery.extend/">jQuery</a> and <a href="http://underscorejs.org/#extend">Underscore</a> provide <code>$.extend</code> and <code>_.extend</code> respectively.  They are great utilities that make object extension quick and painless.  Here's an example using Underscore:</p>

<p>```javascript
var utilities = {
  workWater: function () { console.log('pay $75 for water'); }
};
var otherUtilities = {
  electrifyTheCompany: function () { console.log('pay $75 for electric slides'); }
};
var utilityConglomerate = _.extend({}, utilities, otherUtilities)</p>

<p>utilityConglomerate.workWater() // => 'pay $75 for water'
utilityConglomerate.electrifyTheCompany() // => 'pay $75 for electric slides'
```</p>

<h2>Handle Per-instance State</h2>

<p>Notice that the above methods are very good at attaching functions.  The functions in these examples have no shared state.  The scenarios that we've made up so far haven't required per-instance state as specified by the mixin.  Recently I had a need for all of these things.  I was making a library called <a href="http://octanner.github.io/angular-models/">angular-models</a>.</p>

<p>I wanted to be able to assign what I called <code>AttributesMixin</code> to any function (Model <code>class</code>es, written in CoffeeScript).  To simplify the story, we have a <code>set</code> API that assign values to an internal <code>_attributes</code> object and a <code>get</code> to retrieve them.  These functions were to be assigned to the prototype of the function, but the <code>_attributes</code> were to be assigned to the object instance only, clean for each new object.</p>

<p>We invented our own convention, where each mixin would optionally implement its own <code>dependencies</code> function.  Each of the <code>Model</code>s knew how to extend itself with a given mixin.  This custom extend function was called <code>@include</code>.  As mixins were included, the <code>dependencies</code> function reference was saved (in an array called <code>_dependencyFns</code>) and then called in the <code>Model</code> superclass constructor.  So, each <code>Model</code> subclass is required to call the super constructor to get this functionality.</p>

<p>In the case of <code>AttributesMixin</code>, it looks as simple as this:</p>

<p>```coffeescript attributes-mixin.coffee
AttributesMixin =
  dependencies: -></p>

<pre><code>@_attributes = {}
</code></pre>

<p>  get: -> # ...
  set: -> # ...
```</p>

<p>The <code>Model</code> can include like this:</p>

<p>```coffeescript my-model.coffee
class MyModel extends Model
  @include AttributesMixin
  constructor: -></p>

<pre><code>super
</code></pre>

<p>```</p>

<p>And the <code>Model</code> constructor includes a snippet something like this:</p>

<p>```coffeescript model.coffee
class Model
  constructor: -></p>

<pre><code>fn.apply @ for fn in @_dependencyFns if @_dependencyFns?
</code></pre>

<p>```</p>

<p>For a more accurate, in-depth look at the code, see the <a href="https://github.com/octanner/angular-models">Github repo for angular-models</a>.</p>

<p>Do you use any of these methods to mixin functionality to your JavaScript objects?  What others?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Create a Bower Package]]></title>
    <link href="http://jaketrent.com/post/how-to-create-a-bower-package/"/>
    <updated>2013-09-05T07:04:00-06:00</updated>
    <id>http://jaketrent.com/post/how-to-create-a-bower-package</id>
    <content type="html"><![CDATA[<p>Bower is a client-side or browser package manager.  It will handle your 3rd-party packages that are registered with the service.  To make it more useful, you can package up some of your own code and create a component to install with Bower.</p>

<p><img src="http://i.imgur.com/t4XxrHn.jpg" alt="Bower" /></p>

<!--more-->


<h2>Prepare your Package</h2>

<p>To prepare your code to be a Bower package, you must install the Bower CLI:</p>

<p><code>bash
$ npm install -g bower
</code></p>

<p>If you haven't upgraded Bower lately, you might want to, as the basic config files have changed recently, and the CLI has improved.  This command would do the trick:</p>

<p><code>bash
npm update -g bower
</code></p>

<p>Now let's generate the basic config file, <code>bower.json</code>, by running:</p>

<p><code>bash
$ cd your_project_dir
$ bower init
</code></p>

<p>You will be prompted to select a name, version, etc. for your project.</p>

<h2>Add Your Package to the Registry</h2>

<p>There is a Bower registry at <code>http://bower.herokuapp.com</code> that is used as a central lookup for the Bower components that are available.  This allows searching for packages by name, for instance:</p>

<p><code>bash
$ bower search angular-models
</code></p>

<p>Now the only step left is to add a reference to our package in the registry, for instance:</p>

<p><code>bash
$ bower register angular-models git://github.com/octanner/angular-models.git
</code></p>

<p>That's it!  It's that easy.</p>

<h2>Potential Errors</h2>

<p>When giving a URL to your git repo, use the <code>git</code> protocol URL specifically.  Otherwise on old versions of Bower you'll get an <a href="https://github.com/bower/bower/issues/66">error</a>:</p>

<p><code>bash
bower error Incorrect format
</code></p>

<p>The newer versions will give a much more helpful message:</p>

<p><code>bash
bower EINVFORMAT The registry only accepts URLs starting with git://
</code></p>

<p>And don't worry about name overwriting.  Bower will catch that too with an error response:</p>

<p><code>bash
bower EDUPLICATE Duplicate package
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Angular Directive With Isolate Scope]]></title>
    <link href="http://jaketrent.com/post/test-angular-directive-isolate-scope/"/>
    <updated>2013-08-21T07:46:00-06:00</updated>
    <id>http://jaketrent.com/post/test-angular-directive-isolate-scope</id>
    <content type="html"><![CDATA[<p>Directives with isolate scope do not inherit their scope from their parent.  Thus, the pattern to test them is slightly different.</p>

<p><img src="http://i.imgur.com/wVBKD.png" alt="Angular Isolate Scope Testing" /></p>

<!--more-->


<p>When testing a directive, you'll often want to setup some fixture element to attach your directive to.  This will act as the DOM that you will compile with scope.  At that point, the variables that you attached to scope will be available within the directive under test.</p>

<p>For example, if I had a directive called <code>AccountList</code> with isolate scope:</p>

<p>```coffeescript account-list.coffee
angular.module('app').directive 'AccountList', ->
  restrict: 'EA'
  replace: true
  scope:</p>

<pre><code>accounts: '='
</code></pre>

<p>  # etc ...
```</p>

<p>Then I would setup my test something like this:</p>

<p>```coffeescript account-list.spec.coffee
describe 'AccountList', -></p>

<p>  elm = null</p>

<p>  beforeEach inject ($rootScope, $compile) -></p>

<pre><code>accounts = []
for num in [1..5]
  accounts.push createFakeAccount()
$rootScope.accounts = accounts

elm = angular.element """
  &lt;account-list accounts="accounts"&gt;&lt;/account-list&gt;
"""

e = $compile(elm)($rootScope)
e.scope().$digest()
</code></pre>

<p>  # actual specs, using elm ...
```</p>

<p>A few points:</p>

<ul>
<li><code>inject()</code> comes from <code>angular-mock</code>.  It is currently only supported in Jasmine.</li>
<li>Before each test of the <code>AccountList</code> directive, a set of 5 accounts will be put in scope so the directive, presumably, has something to display.</li>
<li><code>$rootScope</code> is going to be the only scope that you can get to easily from your tests.  You can attach variables to it directly as above or call <code>$rootScope.$new()</code> to generate a new scope if you'd like.</li>
<li>We initially <code>$compile</code> the fixture element, passing in <code>$rootScope</code>.</li>
<li>To get Angular to actually act internally on the variables that we've passed into the directive and put them on scope, we must call the important line of code: <code>e.scope().$digest()</code>.</li>
</ul>


<p>Now you should be ready to rock and roll with your tests.  Isolate scopes can be tricky.  Testing them, a bit tricky as well.</p>

<p>Do you know a better way?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spies with Sinon and Chai]]></title>
    <link href="http://jaketrent.com/post/spies-sinon-chai/"/>
    <updated>2013-08-19T08:21:00-06:00</updated>
    <id>http://jaketrent.com/post/spies-sinon-chai</id>
    <content type="html"><![CDATA[<p>Spies will help you verify calls to methods without actually calling them.  <a href="http://sinonjs.org/">Sinon</a> is a library that provides spies.  <a href="http://chaijs.com/">Chai</a> will provide assertions appropriate to spying.</p>

<p><img src="http://i.imgur.com/yuKcrP9.jpg" alt="Sinon-chai Spies" /></p>

<!--more-->


<h2>Install Dependencies</h2>

<p>You'll need 3 dependencies in dev mode for running your tests:</p>

<p><code>
npm install sinon chai sinon-chai --save-dev
</code></p>

<p>Now make sure that you import these testing tools into your test environment.  I'm using <a href="http://karma-runner.github.io/0.10/index.html">Karma Runner</a>, so my <code>files</code> array has these 3 lines:</p>

<p><code>javascript
'node_modules/sinon/pkg/sinon.js',
'node_modules/chai/chai.js',
'node_modules/sinon-chai/lib/sinon-chai.js',
</code></p>

<p>Make sure that you are including the packaged version of each of these files.  For instance, the <code>sinon/lib</code> files are not built together, so you'll likely import some subset of needed files; it won't error out, but it won't provide working spies like we're wanting (so use the <code>pkg</code> directory files).</p>

<h2>Spying</h2>

<p>We spy because we care.  We don't want certain methods to be called.  In this case, we're testing Angularjs code.  We don't want our event broadcast to actually happen because we don't care about testing the listeners to that event.  We just want to know that the broadcast happens.  We can test listeners separately in their own unit test.</p>

<p>I found that following the "Getting Started" example on the Sinonjs page didn't lead me to create a spy that worked.  I went spelunking and found a working example on a random tech blog (a la this one).  So, here's this advice:</p>

<ul>
<li><code>sinon.spy</code> api takes the object with the function as a 1st parameter and the string name of the function that you're wanting to spy on as the 2nd parameter.</li>
<li><code>sinon.spy</code> will return a reference to the spy.  You can use that reference to do assertions on or you can use the spied on function itself (ie, <code>$rootScope.$broadcast</code>)</li>
<li>Use <a href="https://github.com/domenic/sinon-chai"><code>sinon-chai</code></a>.  It provides better assertions and works with <code>chai</code>.</li>
</ul>


<p>```coffeescript model.spec.coffee
assert = chai.assert
expect = chai.expect
should = chai.should()</p>

<p>model = null
$rootScope = null
$httpBackend = null</p>

<p>beforeEach module 'app'</p>

<p>beforeEach inject (<em>Model</em>, <em>$rootScope</em>, <em>$httpBackend</em>) ->
  model = new <em>Model</em>
  $rootScope = <em>$rootScope</em>
  $httpBackend = <em>$httpBackend</em></p>

<p>it 'broadcasts model:fetched event w/ model', ->
  spy = sinon.spy($rootScope, '$broadcast')
  model.fetch()
  $httpBackend.flush()
  spy.should.have.been.calledWith 'model:fetched', model
```</p>

<p>Most of that code is setup.  And most of that setup is related to <a href="http://angularjs.org/">Angularjs</a>.  If that doesn't apply to you, ignore it.  It's just there to give a more full picture of the environment.</p>

<p>The interesting part is all in the final <code>it</code> function call.  The code under test is <code>model.fetch()</code>, which is called.  Internal to that function, there is a <code>$rootScope.$broadcast</code> call that we're spying on that we're asserting is called with 2 parameters: 'model:fetched' string and the model itself.</p>

<p>As with most testing environments, it's fairly simple once you discover the pattern.  What do you think of this one?  Does it work for you?</p>
]]></content>
  </entry>
  
</feed>
