<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: js | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/js/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-03-03T08:36:32-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[List Npm Scripts]]></title>
    <link href="http://jaketrent.com/post/list-npm-scripts/"/>
    <updated>2015-03-02T07:44:00-07:00</updated>
    <id>http://jaketrent.com/post/list-npm-scripts</id>
    <content type="html"><![CDATA[<p>Tools for storing and then later easily running scripts alias names are awesome.  Npm is one of those tools.  Rake is another.  Rake has a cool feature of allowing you to list the scripts available to you.  Npm has not -- until now.</p>

<p><img src="http://i.imgur.com/ZDCd9u1.png" alt="npm" /></p>

<!--more-->


<h2>Npm Scripts</h2>

<p>You can specify scripts in your <code>package.json</code> for later use.  They go in the <code>scripts</code> attribute:</p>

<p>```json package.json
{
  "scripts": {</p>

<pre><code>"start": "node server.js",
"dist": "webpack -p"
</code></pre>

<p>  }
}
```</p>

<p>To run these scripts, you use the <a href="https://docs.npmjs.com/cli/run-script"><code>npm run</code></a> command.  For example, type <code>npm run build</code> to actually execute the <code>webpack -p</code> command in your terminal.  <code>start</code> and <code>test</code> are specially commands to npm and do not require <code>run</code>.  Instead, you can use <code>npm start</code>.</p>

<h2>Npm List Scripts</h2>

<p>In Rake, you run <code>rake -T</code> in your terminal and all the available scripts for your project are displayed.  This allows you to see the what's potentially helpful.  You can't be expected to remember all of them, especially months later, right?</p>

<p>I certainly was having a hard time remembering all of my scripts and getting tired of typing <code>cat package.json</code>.  It didn't feel as cool as the <code>rake -T</code> experience.  I wrote a library called <a href="https://www.npmjs.com/package/npm-ls-scripts"><code>npm-ls-scripts</code></a>.  To install, run:</p>

<p><code>
npm install npm-ls-scripts -g
</code></p>

<p>I like installing this package globally because then the CLI binary is available globally -- it does seem applicable to all projects.  You could instead include it under project <code>devDependencies</code> if you'd like.</p>

<p>If installed globally, you can then run it with:</p>

<p><code>
ls-scripts
</code></p>

<p>If I was to run this in the above project, it would print:</p>

<p>```</p>

<h2>NPM - ls scripts</h2>

<p>start - node server.js</p>

<h2>dist - webpack -p</h2>

<p>```</p>

<p>This prints the exact code that can be executed for each script.  If I would like to add some prose around any or all of the available scripts, I can do so by adding more config data to my <code>package.json</code> that will print when I run <code>ls-scripts</code>:</p>

<p>```json package.json
{
  "config": {</p>

<pre><code>"scripts: {
   "dist": "Builds project for distribution"
}
</code></pre>

<p>  }
}
```</p>

<p>Now if I were to run the <code>ls-scripts</code> command, I would see:</p>

<p>```</p>

<h2>NPM - ls scripts</h2>

<p>start - node server.js</p>

<h2>dist - Builds project for distribution</h2>

<p>```</p>

<p>Cool, right?  Complete with Shakespearean prose.</p>

<h2>New: Npm Run</h2>

<p>After I had developed the above <code>npm-ls-scripts</code> tool, Npm built this feature natively into the core tool -- finally!  Now, to list available scripts, the command is intuitively to leave off the target script and instead simply type:</p>

<p><code>
npm run
</code></p>

<p>On the above example, this would yield:</p>

<p>```
Available scripts in the package:
  start</p>

<pre><code>node server.js
</code></pre>

<p>  dist</p>

<pre><code>webpack -p
</code></pre>

<p>```</p>

<p>So, they work about the same, and now it's built in!  What other cool features could you imagine this having?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test React componentWillReceiveProps]]></title>
    <link href="http://jaketrent.com/post/test-react-componentwillreceiveprops/"/>
    <updated>2015-02-26T08:34:00-07:00</updated>
    <id>http://jaketrent.com/post/test-react-componentwillreceiveprops</id>
    <content type="html"><![CDATA[<p>Testing React Components has been easier and more enjoyable than any previous UI unit testing I've done in the past.  Components that have interesting things happen in lifecycle methods have a little more setup to get tested.  Components that use the <code>componentWillReceiveProps</code> method are in this category.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react" /></p>

<!--more-->


<h2>React Test Setup</h2>

<p>Not all lifecycle methods require as much setup in a test as <code>componentWillReceiveProps</code>.  This is because:</p>

<ul>
<li>This method is concerned with <strong><em>changing</em></strong> props.</li>
<li>Changing props directly on a React Component (even under test) is against the React code of conduct</li>
</ul>


<p>So, we need something that is legal to change... <code>state</code>!  We need to not modify our subject under test and simply pass it new <code>props</code>.</p>

<p>My solution is to create a React Component specifically for the test.  This Component will be a parent to the subject under test, on which we can set <code>state</code>.  We'll design it so that this state is transferred to the child Component under test.</p>

<h2>React Component using <code>componentWillReceiveProps</code></h2>

<p>You might have a React Component to test that looks like this:</p>

<p>```js
var ComponentToTest = React.createClass({
  getInitialProps() {</p>

<pre><code>return {
  myProp: "blank"
};
</code></pre>

<p>  },
  getInitialState() {</p>

<pre><code>return {
  modified: "still blank"
};
</code></pre>

<p>  },
  componentWillReceiveProps(nextProps) {</p>

<pre><code>this.setState({
  modified: nextProps.myProp + "IsSoModified"
});
</code></pre>

<p>  },
  render() {</p>

<pre><code>return &lt;div class="displayed"&gt;{this.state.modified}&lt;/div&gt;
</code></pre>

<p>  }
});
```</p>

<p>There is nothing particularly interesting about this subject beyond the fact that it uses <code>componentWillReceiveProps</code>.  When new props are received, internal state is modified.  In real life, more interesting things like data fetching or complex calculations might be done here and then stored in state.  We simply are matching the scenario of needing to verify something when <code>componentWillReceiveProps</code> is called.</p>

<h2>A Parent Test Component</h2>

<p>The test to exercise <code>componentWillReceiveProps</code> on the above Component might look like this:</p>

<p>```js
var React = require("react/addons");
var TestUtils = React.addons.TestUtils;</p>

<p>it("displays a modified state upon changing props", function () {
  var TestParent = React.createFactory(React.createClass({</p>

<pre><code>getInitialState() {
  return { testState: "init" };
},
render() {
  return &lt;ComponentToTest ref="sot" myProp={this.state.testState} /&gt;
}
</code></pre>

<p>  }));</p>

<p>  var parent = TestUtils.renderIntoDocument(TestParent());
  parent.refs.sot.props.myProp.should.eql("init");</p>

<p>  parent.setState({</p>

<pre><code>testState: "somethingElse"
</code></pre>

<p>  });</p>

<p>  parent.refs.sot.props.myProp.should.eql("somethingElse");
  parent.refs.sot.state.modified.should.eql("somethingElseIsSoModified"); // assert #1
  var child = TestUtils.scryRenderedDOMComponentsWithClass(parent, "displayed")[0];
  child.getDOMNode().innerText.should.eql("somethingElseIsSoModified");  // assert #2
});
```</p>

<p>The <code>TestParent</code> component is created specifically for this test.  It renders the Component under test.  It sets a <code>ref</code> attribute to it for easy access.  Once we render the parent, the initial state was sent as the prop to the child Component.  As soon as we <code>setState</code> on the parent, a new prop is sent to the child, triggering <code>componentWillReceiveProps</code>.</p>

<p>Finally, I've included two assertion styles.  Again, there are going to be more interesting things that you're asserting here in real life.  In this case I'm verifying that state that renders directly to the UI is set in our lifecycle method.  I can interrogate the state directly.  Here, we reach into the child Component state for assertion method #1.  That may sound bad, but remember that <code>TestParent</code> was created only in the context of this test anyway, so the level we're reaching through to grab child state is just test code.  Assertion method #2 is to go to the DOM to verify final output from the state change.</p>

<p>There is definitely more setup here to make this happen.  I feel like usually testing a React Component doesn't require this much test code.</p>

<h2><code>componentWillReceiveProps</code> in Action</h2>

<p>Here is a Component that uses <code>componentWillReceiveProps</code> to make a simple display change:</p>

<p><a class="jsbin-embed" href="http://jsbin.com/munaxuguta/12/embed?js,output">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>You can also check out this <a href="http://jsbin.com/buwoqod/22/edit?js,output">slightly modified jsbin</a> which does the test assertion.</p>

<p>What methods have you used to test Components that use either <code>componentWillReceiveProps</code> or other interesting lifecycle methods?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sinon Spies vs. Stubs]]></title>
    <link href="http://jaketrent.com/post/sinon-spies-vs-stubs/"/>
    <updated>2015-02-25T07:35:00-07:00</updated>
    <id>http://jaketrent.com/post/sinon-spies-vs-stubs</id>
    <content type="html"><![CDATA[<p><a href="http://sinonjs.org/">Sinon</a> provides spies, stubs, and mocks.  They're all useful as fakes in tests.  They come with essential differences for what they're helpful in doing and how they work.</p>

<p><img src="http://i.imgur.com/yuKcrP9.jpg" alt="spies vs stubs" /></p>

<!--more-->


<h2>Why Use Fakes?</h2>

<p>In a unit test, you might want to avoid having to test the unit's dependencies.  This is especially true in <a href="http://en.wikipedia.org/wiki/White-box_testing">white-box testing</a>.  In this case, test fakes are going to be very helpful.  Sinon provides several fakes, notably spies, stubs, and mocks.  Let's compare and contrast the three:</p>

<h2>Sinon Spies</h2>

<p>Spies sound like what they do -- they watch your functions and report back on how they are called.  They generally avoid the violence and mayhem of a Hollywood spy, but depending on your application, this could vary.</p>

<p>They don't change the functionality of your application.  They simply report what they see.  The <a href="http://sinonjs.org/docs/#spies-api">sinon API for spies</a> is fairly large, but it essentially centers around the <code>called</code> attribute (of which there are many variations).</p>

<p>I first setup that I want to spy on something.  Then I call my subject under test (src code).  Then I verify with the spy what was actually called and stop spying.  That might look like this in a test:</p>

<p>```js
describe("#fight", function () {
  it("calls prayForStrength for fight success", function () {</p>

<pre><code>sinon.spy(subject.strengthDep, "prayForStrength");
subject.fight();
subject.strengthDep.called.should.be.true;
subject.strengthDep.restore();
</code></pre>

<p>  });
});
```</p>

<p><em>Note: this example is in <a href="http://mochajs.org/">mocha</a> using a <a href="https://www.npmjs.com/package/should">should.js</a> assertion style</em></p>

<p>The dependency's <code>prayForStrength</code> method is referred to by name in a string to setup the spy.  When <code>fight</code> is called here, <code>strengthDep.prayForStrength</code> will be called as normal -- but there will be someone watching.  Finally, we call <code>restore</code> on the function we spied on so that all spies are called off.  If you want to do more than watch as dependencies work as described, you might want to use a stub.</p>

<h2>Sinon Stubs</h2>

<p>Stubs are more hands-on than spies (though they sound more useless, don't they).  With a stub, you will actually change how functions are called in your test.  You don't want to change the subject under test, thus changing the accuracy of your test.  But you may want to test several ways that dependencies of your unit could be expected to act.</p>

<p>For instance, if you had a function that returned a boolean that your code used to do different things, you might want to use a stub in two different tests to verify conditions when returning different values (ie, guarantee one run of <code>true</code> and one of <code>false</code> return).</p>

<p>To continue the <code>fight</code> example from above, let's assume that if <code>prayForStrength</code> returns true, we are guaranteed to win the fight for the orphans (ie, <code>fight()</code> should return <code>true</code>).  That might look like this:</p>

<p>```js
describe("#fight", function () {
  it("always wins when prayForStrength is true", function () {</p>

<pre><code>sinon.stub(subject.strengthDep, "prayForStrength", function () { return true; });
subject.fight().should.be.true;
subject.strengthDep.restore();
</code></pre>

<p>  });
});
```</p>

<p>Notice that we use a different <code>sinon.stub</code> API.  For the 3rd parameter, we're supplying our own version of <code>prayForStrength</code>.  For our test, all we care about is the return value, so that's all we supply.  We're not testing this dependency.  We're instead testing how our subject <code>fight</code>s in a certain circumstance.  There are many ways you can use <a href="http://sinonjs.org/docs/#stubs">sinon stubs</a> to control how functions are called.  Also note that you can still use the <code>called</code> verifications with stubs.  But if you do verify a stub was called, you may want to use a mock.</p>

<h2>Sinon Mocks</h2>

<p><a href="http://sinonjs.org/docs/#mocks">Mocks</a> take the attributes of spies and stubs, smashes them together and changes the style a bit.  A mock will both observe the calling of functions and verify that they were called in some specific way.  And all this setup happens <em>previous</em> to calling your subject under test.  After the call, mocks are simply asked if all went to plan.</p>

<p>So the previous test could be rewritten to use a mock:</p>

<p>```js
describe("#fight", function () {
  it("always wins when prayForStrength is true", function () {</p>

<pre><code>var mock = sinon.mock(subject.strengthDep)
mock.expects("prayForStrength").returns(true);
subject.fight().should.be.true;
mock.verify();
mock.restore();
</code></pre>

<p>  });
});
```</p>

<p>The <code>expects</code> and <code>returns</code> line is where the combo magic happens.  <code>expects</code> is verifying a call (like <code>spies</code> can), and <code>returns</code> is specifying functionality (like <code>stubs</code> can).  The <code>verify</code> call is the line that will fail (essentially the mock assertion) if things in the subject didn't go exactly according to plan.</p>

<h2>Spies vs. Stubs vs. Mocks</h2>

<p>So when should I use spies or stubs or mocks?  As with most art, there are many ways to accomplish what you want.  Much of your choice will depend on your own style and what you become proficient in.</p>

<p>Some basic rules might be:</p>

<ul>
<li><strong><em>Use Spies</em></strong> - if you simply want to watch and verify somethings happens in your test case.</li>
<li><strong><em>Use Stubs</em></strong> - if you simply want to specify how something will work to help your test case.</li>
<li><strong><em>Use Mocks</em></strong> - if you want to both of the above on a single dependency in your test case.</li>
</ul>


<p>When do you find yourself most often using spies vs. stubs vs. mocks?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test React-Router Previous Params for Component Update]]></title>
    <link href="http://jaketrent.com/post/test-react-router-params-component-update/"/>
    <updated>2015-02-09T15:39:00-07:00</updated>
    <id>http://jaketrent.com/post/test-react-router-params-component-update</id>
    <content type="html"><![CDATA[<p>Once upon a time, react-router transferred params and query params from the url via props into components.  It doesn't happen this way any more.  So, let's say you have a need in your component like overriding <code>shouldComponentUpdate</code> in your component which only has access to <code>this.props</code> and <code>this.state</code>.   How can you use the url data to affect the component re-render or not?</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react" /></p>

<!--more-->


<h2>Why control rendering with the url?</h2>

<p>There are two instances that come to mind when considering the scenarios that it might be needful to control the update of your component based on the url:</p>

<ol>
<li><p><strong>Avoid re-render</strong>: Of course, if the component we're talking about is a page-level component, you'll most likely always be wanting to re-render as the url changes.  But, if you're a little widget component that cares about the url, you might not need to always re-render on url change.</p></li>
<li><p><strong>Trigger re-render when it might not otherwise happen</strong>: For whatever reason, you may have already needed to implement <code>shouldComponentUpdate</code> in your component.  This function returns true or false to flag a "should" or "should not" re-render.  You'll need to access url state and likely previous url state in this method to make re-renders happen that otherwise wouldn't if you had no logic in this function for it.</p></li>
</ol>


<p>Of course, beyond these re-render scenarios, there are many other situations in which knowing previous and current states in the url could come in handy.</p>

<h2>React-Router in shouldComponentUpdate</h2>

<p><code>shouldComponentUpdate</code> determines if component should re-render.  It's called whenever <code>this.props</code> or <code>this.state</code> changes.  It has access to incoming props and state via the function parameters.</p>

<p>React-router gives your component access to params and query params by requiring you to mix in the <code>State</code> param from react-router.  Then you have access to new functions, <code>this.getParams()</code> and <code>this.getQuery()</code>.  If you only need to know current url state, this is enough.  If you want to compare current url state to previous url state, you'll have to save the parts that you care about.  We'll do that in <code>this.state</code>.</p>

<p>Let's say that we want to trigger a redraw on changes to a <code>range</code> query parameter.  The component might, in part, look like this:</p>

<p>```
var { State } = require('react-router')</p>

<p>module.exports = React.createClass({</p>

<p>  mixins: [ State ],</p>

<p>  getInitialState() {</p>

<pre><code>range: nul
</code></pre>

<p>  },</p>

<p>  componentWillReceiveProps() {</p>

<pre><code>this.setState({
  range: this.getQuery().range
})
</code></pre>

<p>  },</p>

<p>  componentWillMount() {</p>

<pre><code>this.setState({
  range: this.getQuery().range
})
</code></pre>

<p>  }</p>

<p>  shouldComponentUpdate() {</p>

<pre><code>return this.state.range !== nextState.range
</code></pre>

<p>  }</p>

<p>  // ...</p>

<p>})
```</p>

<p>When the url params change, <code>componentWillReceiveProps</code> is called.  But this is not called on the first render, thus we implement <code>componentWillMount</code>.  Both these functions save the <code>range</code> from the url to the component state.  Now, as <code>shouldComponentUpdate</code> is called on future <code>this.props</code> and <code>this.state</code> changes, current and next <code>range</code> values can be compared and used in "should re-render" calculation.</p>

<p>What other ways have you found to accomplish this tracking of previous state in the url?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-Router with Flux]]></title>
    <link href="http://jaketrent.com/post/react-router-with-flux/"/>
    <updated>2015-01-15T09:21:00-07:00</updated>
    <id>http://jaketrent.com/post/react-router-with-flux</id>
    <content type="html"><![CDATA[<p>react-router provides great route handling with route params and query params.  Flux provides a pattern for building React apps, including a pattern from providing data to your components.  Here's a straightforward way to make route changes trigger data changes in your components.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react" /></p>

<!--more-->


<p>Note: Code here reflects usage of react-router 0.11.x.</p>

<p>It is often the case that we'll need to trigger data changes in a react component in our Flux app because of a route transition.  A prime example of this would be on an object show page, where the details of a particular object are being shown.  In our example, let's say that we're showing the details of a book, such as title, author, and description.</p>

<p>The route to our book detail page is likely defined as:</p>

<p><code>js routes.js
// ...
&lt;Route name="book" path="/books/:id" handler={require('./books-show')} /&gt;
</code></p>

<p>The handler is just a controller-component that defines the view.  It might look simply like:</p>

<p>```js books-show.js
const React = require('react')
const {State} = require('react-router')</p>

<p>const BooksStore = require('./books-store')</p>

<p>module.exports = React.createClass({</p>

<p>  displayName: 'BooksShow',</p>

<p>  mixins: [ State ],</p>

<p>  getInitialState() {</p>

<pre><code>return this.getStateFromStores()
</code></pre>

<p>  },</p>

<p>  getStateFromStores() {</p>

<pre><code>return {
  book: BooksStore.find({ id: this.getParams().id })
}
</code></pre>

<p>  },</p>

<p>  componentDidMount() {</p>

<pre><code>BooksStore.addChangeListener(this._onChange)
</code></pre>

<p>  },</p>

<p>  componentWillUnmount() {</p>

<pre><code>BooksStore.removeChangeListener(this._onChange)
</code></pre>

<p>  },</p>

<p>  _onChange: function() {</p>

<pre><code>this.setState(this.getStateFromStores())
</code></pre>

<p>  },</p>

<p>  render() {</p>

<pre><code>return (
  &lt;ul&gt;
    &lt;li&gt;{this.state.book.title}&lt;/li&gt;
    &lt;li&gt;{this.state.book.author}&lt;/li&gt;
    &lt;li&gt;{this.state.book.description}&lt;/li&gt;
  &lt;/ul&gt;
)
</code></pre>

<p>  }</p>

<p>})
```</p>

<p>Note that the view component references a <code>BooksStore</code> for getting its initial state.  The state of <code>book</code> will also be updated as the <code>BooksStore</code> emits that its data has changed and <code>this._onChange</code> is called.</p>

<p>Every time a route transitions, react-router has a <code>Router.run</code> callback that will also run in order to render the matching route.  This will also be a great place to put our action to signal to our Flux app that routes are transitioning and therefore other stuff like data in the display might need to change as well.</p>

<p><code>js
Router.run(routes, (Handler, state) =&gt; {
  React.render(&lt;Handler /&gt;, document.body)
  BooksAction.transition(state.params)
})
</code></p>

<p><strong>Important note</strong>: Make sure the transition action is called after <code>React.render</code> so that the change emission will be detected after render, otherwise you'll be one route transition behind.</p>

<p>The <code>BooksAction.transition</code> definition is something very simple -- something that can trigger events on the dispatcher:</p>

<p>```js books-actions.js
exports.transition = () => {
  AppDispatcher.handleViewAction({</p>

<pre><code>type: ActionTypes.TRANSITION
</code></pre>

<p>  })
}
```</p>

<p>The final connection is in the store, where the dispatched action can be listened for an then trigger the store event, updating the component views:</p>

<p>```js books-store.js
var BooksStore = merge(EventEmitter.prototype, {
  find(filter) {</p>

<pre><code>// ...
</code></pre>

<p>  }
})</p>

<p>BooksStore.dispatchToken = AppDispatcher.register((payload) => {
  var action = payload.action
  switch(action.type) {</p>

<pre><code>// ...

case ActionTypes.TRANSITION:
  BooksStore.emitChange()
  break
</code></pre>

<p>  }
})</p>

<p>module.exports = BooksStore</p>

<p>```</p>

<p>At this point, all the route transitions should trigger data changes in views.  Visiting the url <code>/books/1</code> and then the url <code>/books/2</code> should display different data on screen according to which book id was in the route.  <code>Router.Link</code> should work correctly, usable instead of buttons with actions being triggered on click.</p>

<p>react-router and Flux make for a great combo in this way, right?  What adjustments would you make?</p>
]]></content>
  </entry>
  
</feed>
