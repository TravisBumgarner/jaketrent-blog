<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: js | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/js/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2013-06-20T08:05:37-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ngStyle Background]]></title>
    <link href="http://jaketrent.com/post/ngstyle-background/"/>
    <updated>2013-06-19T07:08:00-06:00</updated>
    <id>http://jaketrent.com/post/ngstyle-background</id>
    <content type="html"><![CDATA[<p><code>ngStyle</code> is the directive used to set inline style attributes with AngularJs.  Most of the time, it's straightforward to use.  <code>background</code> css attributes can be just slightly trickier.</p>

<p><img src="http://i.imgur.com/wVBKD.png" alt="AngularJs" /></p>

<!--more-->


<h2>ngStyle Objects</h2>

<p>The <code>ngStyle</code> directive requires an object for input.  The object key is the css attribute name.  The resultant value for the key is the value of the css attribute.</p>

<p><code>ngStyle</code> is obviously used to set dynamic styles, because static styles are more easily and efficient set using the standard html <code>style</code> attribute.</p>

<h2>A Dynamic Style Example</h2>

<p>So let's setup a controller that sets a dynamic color based on something as useful as the time.  Useful, right?</p>

<p>```coffeescript colorCtrl.coffee
angular.module('colorly').controller 'colorCtrl', ($scope) ->
  $scope.getColor = -></p>

<pre><code>if new Date().getTime() % 2 is 0 then "red" else "blue"
</code></pre>

<p>```</p>

<p>We could use this <code>getColor</code> function in our app:</p>

<p>```haml app.jade
html(ng-app="colorly")
  head</p>

<pre><code>//- ... include Angular, etc
</code></pre>

<p>  body(ng-controller="colorly")</p>

<pre><code>p(ng-style="{ color: getColor() }")
  | The text will be one of two colors
</code></pre>

<p>```</p>

<h2>A Background Example</h2>

<p>If we have a dynamic value that needs to go in a css <code>background</code> or <code>background-image</code> attribute, it can be just a bit more tricky to specify.</p>

<p>Let's say we have a <code>getImage()</code> function in our controller.  This function returns a string formatted similar to this: <code>url(icons/pen.png)</code>.  If we do, the <code>ngStyle</code> declaration is specified the exact same way as before:</p>

<p><code>haml
ng-style="{ 'background-image': getImage() }"
</code></p>

<p>Make sure to put quotes around the <code>background-image</code> key name.  Remember, this must be formatted as a valid Javascript object key.</p>

<h2>Another Background Example</h2>

<p>That example was easy.  Often, however, you don't have data stored in your models that's formatted like <code>url(icons/pen.png)</code>.  Instead you often have a field that represents the image path only.  In this case, you must do some JavaScript inside your <code>ngStyle</code> declaration:</p>

<p>```coffeescript colorCtrl.coffee
angular.module('colorly').controller 'colorCtrl', ($scope) ->
  $scope.tool =</p>

<pre><code>name: 'Pen'
icon: 'icons/pen.png'
</code></pre>

<p>```</p>

<p><code>haml
ng-style="{ 'background-image': 'url(' + tool.icon + ')' }"
</code></p>

<p>Remember that it's just Javascript, and you'll setup the string concatenation to work just fine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongoose Population]]></title>
    <link href="http://jaketrent.com/post/mongoose-population/"/>
    <updated>2013-06-18T07:39:00-06:00</updated>
    <id>http://jaketrent.com/post/mongoose-population</id>
    <content type="html"><![CDATA[<p><a href="http://mongoosejs.com">Mongoose</a> is an object modeler for <a href="http://mongodb.org">MongoDb</a>.  It has a particularly great feature, called <a href="http://mongoosejs.com/docs/populate.html">population</a>.  Population allows you to include other objects in a specified object.  It makes the process a lot easier and more automatic.</p>

<p><img src="http://i.imgur.com/pezEyw7.jpg" alt="Mongoose" /></p>

<!--more-->


<h2>Document Design</h2>

<p>Document databases provide a lot of flexibility in how data is modeled.  Just as the name suggests, data will often mimic real-world documents.  MongoDb isn't a document database per se, but it has enough flexibility to be treated as one.  Mongoose population can help.</p>

<p>A document is often optimized for reads.  All the data is included, such as it would be on a real-world piece of paper.</p>

<p>In Mongo, data is divided into collections.  Mongoose helps define discrete schemas for data in each.  This separates and makes data fields explicit.  This helps with data organization, storage, and writing.  Population helps bring data from different collections back together again easily.  From the <a href="http://mongoosejs.com/docs/populate.html">docs</a>:</p>

<blockquote><p>Population is the process of automatically replacing the specified paths in the document with document(s) from other collection(s).</p></blockquote>

<p>So, let's try it out with a couple examples.</p>

<h2>Data Definition</h2>

<p>Mongo will add a primary surrogate key to each object, called <a href="http://docs.mongodb.org/manual/reference/object-id/">ObjectId</a>, referenced as <code>_id</code> in the data.  This will be the key used to refer to objects in other collections.  If I wanted to model players in leagues -- foosball leagues of course --  I might create schemas like this:</p>

<p>```coffeescript player.coffee
mongoose = require 'mongoose'
Schema = mongoose.Schema</p>

<p>playerSchema = new mongoose.Schema
  display_name: String
  leagues: [</p>

<pre><code>type: Schema.Types.ObjectId
ref: 'League'
</code></pre>

<p>  ]</p>

<p>Player = mongoose.model 'Player', playerSchema
```</p>

<p>```coffeescript league.coffee
mongoose = require 'mongoose'
Schema = mongoose.Schema</p>

<p>leagueSchema = new mongoose.Schema
  display_name: String
  created_by:</p>

<pre><code>type: Schema.Types.ObjectId
ref: 'Player'
</code></pre>

<p>  players: [</p>

<pre><code>type: Schema.Types.ObjectId
ref: 'Player'
</code></pre>

<p>  ]</p>

<p>League = mongoose.model 'League', leagueSchema
```</p>

<p>A few points of interest:</p>

<ul>
<li>Since we are using <code>_id</code> to refer to other objects, we use the <code>ObjectId</code> type in the Mongoose definition.  You can use other fields.  Just make sure the type matches.</li>
<li>The <code>ref</code> attribute must match <em>exactly</em> the model name in your model definition.  Otherwise you'll get something like this little beauty: <code>MissingSchemaError: Schema hasn't been registered for model "Player".</code>.</li>
<li>Note that <code>League.players</code> is an array.  Just surround the field definition in square brackets to get this functionality.</li>
</ul>


<h2>Data Read</h2>

<p>Reading data is where Mongoose population really shines.  This is the magic that makes reads of documents very straightforward, easy, and fast.  The magic is in the <code>populate()</code> function.</p>

<h3>Populate One Field</h3>

<p>If I want to populate a single field in the query for an object, I specify the name of that field in a string to the <code>populate</code> function:</p>

<p><code>coffeescript
Player
  .findOne({ _id: 'abc123' })
  .populate('leagues')
  .exec (err, player) -&gt; #...
</code></p>

<p><code>leagues</code> will be populated with an array of full <code>League</code> objects when the resulting json returned, just like magic.</p>

<h3>Populate Multiple Fields</h3>

<p>Populating multiple referenced objects is similarly easy:</p>

<p><code>coffeescript
League
  .find()
  .populate('created_by players')
  .exec (err, league) -&gt; #...
</code></p>

<p>Just separate the field names in your <code>populate</code> parameter with spaces.  This query will return an array of <code>League</code> with the <code>created_by</code> and <code>player</code> fields populated with the associated <code>Player</code> objects.</p>

<h3>Populate Partial Objects</h3>

<p>Populating objects like this can quickly bloat your payload size.  To limit included objects to only a subset of fields, you can specify exactly what parts you want populated.  For instance, if my client UI only needed to show a list of leagues that a player belongs to, I could ask for just the <code>display_name</code> of the included <code>League</code> object by using a 2nd parameter:</p>

<p><code>coffeescript
Player
  .findOne({ _id: 'abc123' })
  .populate('leagues', 'display_name')
  .exec (err, player) -&gt; #...
</code></p>

<p>For listing multiple parts, separate the attribute names with spaces.</p>

<h3>Forget to Populate</h3>

<p>You might get so used to having objects populated for some of your queries that you might wonder why they're not populated in your latest query.  You probably just forgot to call <code>populate()</code> in your query.  You must do this explicitly to get the inclusions you desire.  Otherwise, you the data you query will just include the <code>_id</code> values.</p>

<h3>Explicitly Exclude Field</h3>

<p>It might not be that you forgot to populate, but that on some queries you don't want to populate.  In these cases, you might not want to be sending around unneeded <code>_id</code> values, especially if they make up a large portion of your data size.  You can explicitly exclude such fields.  For instance, if you wanted all <code>Player</code> models but weren't going to populate <code>leagues</code>, you might query:</p>

<p><code>coffeescript
Player
  .find()
  .select('-leagues')
  .exect (err, players) -&gt; #...
</code></p>

<p>Note the <code>-</code> sign in the <code>select</code> clause.  This removes the field from the results.</p>

<h2>Data Write</h2>

<p>When you go to read the data, it's quick, easy, and automatic.  But that's because some work was done previously to reference the correct objects and make sure these references are saved.  Therefore, the naturally more work-intensive part of the population story is the data writing.</p>

<p>When we write to our example models, we need to save the proper references.  For instance, when a new <code>League</code> is created, let's say it automatically needs a <code>created_by</code> <code>Player</code> reference saved and the creating <code>Player</code> will automatically join the league:</p>

<p>```coffeescript
league =
  display_name: myLeagueName
  created_by: currentPlayer._id</p>

<p>League.create league, (err, league) ->
  if err?</p>

<pre><code># ... do smart things that are never shown in a tutorial
</code></pre>

<p>  else</p>

<pre><code>Player.update { _id: currentPlayer._id },
  $push:
    leagues: league._id
, (err, numberAffected, raw) -&gt;
  if err?
    # you know...
  else
    res.json league
</code></pre>

<p>```</p>

<p>A few points of interest:</p>

<ul>
<li>Lowercase <code>league</code> is just the json to populate a <code>League</code> model.  <code>league</code> is also the shadowed variable name in the <code>League.create</code> callback.</li>
<li><code>currentPlayer</code> is just an imagined <code>Player</code> reference that has an <code>_id</code> that you will use to associate <code>Player</code> to this <code>League</code>.</li>
<li><a href="http://docs.mongodb.org/manual/reference/operator/push/"><code>$push</code></a> is a special <code>update</code> attribute that appends new elements to a model's array.</li>
</ul>


<p>Depending on how complex your model relationships become, you may opt for a difference code strategy besides nesting callbacks.  Don't like your pyramid of doom?  Try the awesome <a href="https://github.com/caolan/async">async.js</a>.</p>

<p>I don't know if Mongoose population is going to change your life, but I was very happy when I found this feature.  I had been doing junk like this manually.  What are some other great use cases that you've found?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember Parent Templates]]></title>
    <link href="http://jaketrent.com/post/ember-parent-templates/"/>
    <updated>2013-05-29T07:02:00-06:00</updated>
    <id>http://jaketrent.com/post/ember-parent-templates</id>
    <content type="html"><![CDATA[<p><a href="http://emberjs.com">Ember</a>'s convention of template hierarchy is very specific.  Learn it once, and you'll know it every time.</p>

<p><img src="http://i.imgur.com/x5HT4FN.jpg" alt="Ember and Handlebars" /></p>

<!--more-->


<p><strong>Note:</strong> Code examples use <a href="http://emblemjs.com/">Emblem</a> templates and <a href="http://coffeescript.org">CoffeeScript</a>.  Vanilla Handlebars and JavaScript would work just as well.</p>

<h2>Outlets</h2>

<p>Ember templates make use of a special helper called <code>outlet</code>.  You can have one main, unnamed outlet or many named outlets.  The main thing to remember is that a child template will always render inside its parent's outlet -- so always put outlets in templates that have children.</p>

<h2>Application Template</h2>

<p>There is a top-most template that all of your templates will render inside of.  This is called the application template.  It is specified in one of two ways.  If you are including your templates as script tags, simply create a script tag that doesn't have a <code>data-template-name</code> or <code>id</code> attribute, a la:</p>

<p>```html</p>

<script type="x-emblem">
  h1 My Application
  == outlet
</script>


<p>```</p>

<p>If you are <a href="/post/precompile-ember-templates">precompiling your Ember templates</a>, which you should, you have a directory for templates.  You will put your file, called <code>application.emblem</code> in the root of that directory.  The contents of <code>templates/application.emblem</code> would be the same:</p>

<p><code>jade
h1 My Application
== outlet
</code></p>

<h2>Route Templates</h2>

<p>If you have a top-level route, it will have a top-level template.  Your route's template will have only the application template as its parent.  So, your about route:</p>

<p><code>coffeescript
App.Router.map -&gt;
  @route 'about'
</code></p>

<p>Will have an about template at <code>templates/about.emblem</code> and you could define a route as <code>AboutRoute</code>.  It will render inside of <code>application.emblem</code>'s outlet.</p>

<h2>Resource Templates</h2>

<p>Resources are interesting because you can nest other routes inside them.  Nesting routes will also result in nesting templates.  If I defined a <code>league</code> resource with a nested route for creating new leagues, it might look something like this:</p>

<p>```coffeescript
App.Router.map ->
  @resouce 'league', -></p>

<pre><code>@route 'new'
</code></pre>

<p>```</p>

<p>There are two leaf routes (and thus templates) that are created here:</p>

<ul>
<li><code>LeagueIndexRoute</code>, which uses <code>templates/league/index.emblem</code></li>
<li><code>LeagueNewRoute</code>, which uses <code>templates/league/new.emblem</code></li>
</ul>


<p>Note that you create a <code>league</code> directory inside your <code>templates</code> directory for nesting these templates.  Precompiled templates will be created at:</p>

<ul>
<li><code>Ember.TEMPLATES["league/index"]</code></li>
<li><code>Ember.TEMPLATES["league/new"]</code></li>
</ul>


<p>If you wanted to use the <code>linkTo</code> helper in a template to link to these routes, you would use this syntax:</p>

<p><code>jade
linkTo 'league.index' | List Leagues
linkTo 'league.new' | New League
</code></p>

<p>And now as far as templates, there is <em>one more</em> that we're missing.  There is a root league template that these two league leaf templates render inside of.  It should live at <code>templates/league.emblem</code>.  This template would be useful for showing UI elements that are common to all league resource things.  In the case where there is no such need, this template will probably only contain a single outlet:</p>

<p><code>jade
== outlet
</code></p>

<p>So the final template hierarchy for <code>league.new</code>, for example, is <code>application.emblem &gt; league.emblem &gt; league/new.emblem</code>.</p>

<p>There is a bit of a chatter on the Githubs about whether the root resource template is good form or not.  As in, why would you create a file that contains nothing but an empty outlet?  Couldn't the framework infer that if it was missing?</p>

<h2>Children Need All Parents</h2>

<p>Create all parents in your template chain, from the application template to the leaves.  The worst thing that can happen if you don't is that nothing will render at all, and no error messages will be displayed (pretty bad and unhelpful).</p>

<p>Most of the time, Ember will try to be helpful and give you a console warning:</p>

<blockquote><p>WARNING: The immediate parent route ('a') did not render into the main outlet and the default 'into' option ('p') may not be expected</p></blockquote>

<p>In other words: You're trying to render a child template that either doesn't have a parent template it needs or the parent template does not specify a main outlet.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Precompile Ember Templates]]></title>
    <link href="http://jaketrent.com/post/precompile-ember-templates/"/>
    <updated>2013-05-21T07:54:00-06:00</updated>
    <id>http://jaketrent.com/post/precompile-ember-templates</id>
    <content type="html"><![CDATA[<p><a href="http://emberjs.com">Ember</a> makes use of the wonderful <a href="http://handlebarsjs.com">Handlebars</a> templates.  These templates, in order to be performant, must be precompiled.  Based on the Ember docs, it's not abundantly clear how this is to happen.  Here's a solution that works well.</p>

<p><img src="http://i.imgur.com/x5HT4FN.jpg" alt="Ember and Handlebars" /></p>

<!--more-->


<h2>Ember Docs for Precompilation</h2>

<p>Every official Ember doc will put templates in a <code>script</code> tag with the <code>type="text/x-handlebars"</code>.  But this is never how you'd write any serious (-ly awesome) app in production.  <a href="http://emberjs.com/guides/templates/handlebars-basics/">The docs</a> say:</p>

<blockquote><p>"If you are using build tools to manage your application's assets, most will know how to precompile Handlebars templates and make them available to Ember.js."</p></blockquote>

<p>Which tools?  Why would I want to precompile?  How <em>are</em> they made available to Ember?  Read, Ember journeyman, read on...</p>

<h2>Grunt</h2>

<p>We'd love for this precompilation to happen previous to the running of your app.  Again, this is in hopes of increased performance.  <a href="http://gruntjs.com">Grunt</a> is a great little Nodejs-based tool for build-level tasks.</p>

<h2>Emblem</h2>

<p>Grunt comes with a variety of plugins.  We're going to use one called <a href="https://github.com/wordofchristian/grunt-emblem/">grunt-emblem</a>.  <a href="http://emblemjs.com/">Emblem</a> is a fantastic templating syntax layered on top of Handlebars (still a dependency).  Its syntax looks very similar to Haml or Ruby Slim or Jade.  It may well be the most flexible of all of them, and it simplifies some Ember helper syntax very nicely.</p>

<h2>Versions Matching</h2>

<p>As I've said before, <a href="/post/match-ember-handlebars-version/">matching Ember dependency version can be a pain</a>.  With precompilation, you have one more dependency to match.  Now not only do you care about the version of Handlebars that Ember uses at runtime, but you care about the version of Handlebars that is used to precompile your templates.  If the precompile Handlebars version doesn't match the runtime Handlebars version, your app will die at runtime.  <code>grunt-emblem</code> helps immensely with this.</p>

<h2>grunt-emblem</h2>

<p>I haven't found another Handlebars precompile plugin that helps as much as <code>grunt-emblem</code>.  It solves the precompile version problem by letting you utilize the actual runtime Handlebars as the precompile Handlebars script.</p>

<p>It is also nice in that it puts the precompiled templates into the collection that Ember expects to find templates in, namely <code>Ember.TEMPLATES</code>.  As you can find on the <a href="https://github.com/wordofchristian/grunt-emblem/"><code>grunt-emblem</code> Github page</a>, your grunt config will look something like the following:</p>

<p>```coffeescript
matchdep = require 'matchdep'</p>

<p>module.exports = (grunt) ->
  grunt.initConfig</p>

<pre><code>watch:
  ember_templates:
    files: ['app/views/templates/**/*.emblem']
    tasks: ['emblem', 'livereload']

emblem:
  compile:
    files:
      "app/static/templates/ember_templates.js": ["app/views/templates/**/*.emblem"]
    options:
      root: "app/views/templates/"
      dependencies:
        jquery: "app/static/js/components/jquery/jquery.js"
        ember: "app/static/js/components/ember/ember.js"
        emblem: "app/static/js/components/emblem/dist/emblem.js"
        handlebars: "app/static/js/components/handlebars/handlebars.js"
</code></pre>

<p>  matchdep.filterDev('grunt-*').forEach grunt.loadNpmTasks</p>

<p>  grunt.renameTask 'regarde', 'watch'</p>

<p>  grunt.registerTask 'dev', [ 'livereload-start', 'watch' ]</p>

<p>```</p>

<p>This particular config has a couple other niceties.  Let me enumerate the awesome:</p>

<ul>
<li>Line 6 - Not only can we precompile the templates, but we'll precompile on the fly, whenever <code>.emblem</code> files are change in the specified directories.</li>
<li>Line 8 and 14 - We're precompiling <code>.emblem</code> templates, but this plugin can do regular Handlebars syntax as well</li>
<li>Line 16 - <code>root</code> is the substring that will be stripped out of your template name.  For instance, you don't want your template to be called <code>app/views/templates/home</code>.  Your home route in Ember will want your template called <code>home</code>.  <code>root</code> to the rescue -- bam!</li>
<li>Line 17 - These <code>dependencies</code> are the libraries that you use at runtime and that Handlebars needs at compile time.  As I said, this plugin simply rocks because of the ability to specify your own Handlebars script.</li>
<li>Line 23 - Remember how you used to have a whole list of npm tasks registered.  This little beaut will load all <code>grunt-*</code> dependencies.</li>
<li>Line 25 - <code>regarde</code> is a cool name, but I understand what <code>watch</code> means a bit better. Rename it.</li>
</ul>


<p>This setup requires the following dependencies:</p>

<p><code>
npm install matchdep grunt grunt-regarde grunt-contrib-livereload grunt-emblem --save-dev
</code></p>

<p>So now, seriously, go write some Emblem templates.  So fun, so precompiled.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Match Ember and Handlebars Versions]]></title>
    <link href="http://jaketrent.com/post/match-ember-handlebars-version/"/>
    <updated>2013-05-21T07:38:00-06:00</updated>
    <id>http://jaketrent.com/post/match-ember-handlebars-version</id>
    <content type="html"><![CDATA[<p><a href="http://emberjs.com">Ember</a> is very specific about what version of <a href="http://handlebarsjs.com">Handlebars</a> it requires.  This is probably good, but it's also a pain to work with as different versions of the two libraries are released independently.  There are a few good tools to help us out.</p>

<p><img src="http://i.imgur.com/x5HT4FN.jpg" alt="Ember and Handlebars" /></p>

<!--more-->


<h2>Released Independently</h2>

<p>In a prime example, recently there was a new version of Handlebars released: <code>1.0.0-rc.4</code>.  Ember happens to be on version <code>1.0.0-rc.3</code>.  That version has a hard dependency on Handlebars <code>1.0.0-rc.3</code>.  In other words, the latest Ember code relies on an older version of Handlebars.</p>

<h2>Bower</h2>

<p>If you include these 3rd party libraries in your source code under a <code>lib</code> directory or something of that nature, you <em>always</em> have plenty of work to do.  Naturally, you just copy in the exact versions of the scripts that are needed.</p>

<p>Hopefully you're trying to make use of a mostly awesome tool, <a href="http://bower.io">Bower</a>.  It helps you manage these 3rd party libraries in a way similar to npm.  You provide a descriptor of your project's dependencies, <code>component.json</code>.  And you install things similarly via the <code>bower</code> cli.</p>

<h2>Specify a Bower Version</h2>

<p>If I run:</p>

<p><code>
bower install handlebars --save
</code></p>

<p>It saves a dependency in my <code>components.json</code> for Handlebars for the latest version it could find.  This won't do for us.  We need to specify the versions.</p>

<p>Our strategy will be: take the latest version of Ember and then specifically match the Handlbars version.  Finally, we should type:</p>

<p><code>
bower install ember --save
bower install handlebars#1.0.0-rc.3
</code></p>

<p>As of this writing, that is the version of handlebars that is required.  Bower will recognize any semver git tag name or branch name after the hash <code>#</code> sign.</p>

<p>I like our version strategy for a project that is under active development in that it keeps us on the latest Ember.  But, if you're on a project that's been built to an Ember version and not deployed for a long time, you may want to make a very specific dependency out of Ember as well, so the two are guaranteed in sync for future deploys.</p>
]]></content>
  </entry>
  
</feed>
