<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-01-22T12:54:41-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Set Cookie on Rack Mock Request]]></title>
    <link href="http://jaketrent.com/post/set-cookie-on-rack-mock-request/"/>
    <updated>2015-01-21T10:58:00-07:00</updated>
    <id>http://jaketrent.com/post/set-cookie-on-rack-mock-request</id>
    <content type="html"><![CDATA[<p>Rack apps are generally straightforward to test because of their very basic public interface.  But where do we put specific things, in this case, a cookie for the request, on that <code>env</code> argument it takes?  Here's one way.</p>

<p><img src="http://i.imgur.com/044x6s6.jpg" alt="rack mock request" /></p>

<!--more-->


<h1>env</h1>

<p>The <code>env</code> argument that is sent to <code>#call</code> in a Rack app is an variable that represents the <a href="http://www.rubydoc.info/github/rack/rack/master/file/SPEC#The_Environment">environment of the request</a>.  It is a hash of CGI-like headers: request method, query params, http headers -- that sort of thing.</p>

<p>The <code>HTTP_*</code> keys on the hash will be <a href="https://tools.ietf.org/html/rfc3875#section-4.1.18">read as request headers from the environment</a>.</p>

<h1>Rack MockRequest Cookies</h1>

<p>Rack provides a great little <code>Rack::MockRequest</code> helper object in its library that will help us test our app.  This object has a class method called <code>env_for</code> which allows for quick construction of an <code>env</code> var that is a request to a specified url.</p>

<p>On the returned <code>env</code> we will continue to make modifications before passing it to our Rack app.  We'll add our cookie header with a key of <code>HTTP_COOKIE</code>.  The value will be of the format <code>cookieName=cookieValue</code>.  We can handle multiple cookies by separating the cookies with <code>;</code>.</p>

<p>Let's say we're testing a token authentication middleware with rspec.  Our spec may look something like this:</p>

<p><code>ruby
it "accepts an cookie token in the request" do
  middleware = # ... instantiate rack middleware
  env = Rack::MockRequest.env_for("/protected")
  env["HTTP_COOKIE"] = "AUTH_COOKIE=123"
  status, _, _ = middleware.call(env)
  expect(status).to eq(200)
end
</code></p>

<p>Then in our Rack app source, we can code for the availability of a cookie on the request.  It might look like:</p>

<p>```ruby</p>

<h1>...</h1>

<p>def call(env)
  request = Rack::Request.new(env)
  token = request.cookies["AUTH_TOKEN"]
  # ...
end
```</p>

<p>Is this the easiest or best way to set cookies on requests when testing Rack apps?  What do you do?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pagination Headers with Kaminari]]></title>
    <link href="http://jaketrent.com/post/pagination-headers-with-kaminari/"/>
    <updated>2015-01-15T14:07:00-07:00</updated>
    <id>http://jaketrent.com/post/pagination-headers-with-kaminari</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/amatsuda/kaminari">Kaminari</a> provides easy pagination in a rails app.  It's great to use.  We'll make it better by adding a little function to your controllers to provide useful pagination headers.</p>

<p><img src="http://i.imgur.com/XOUecnw.jpg" alt="kaminari pagination" /></p>

<!--more-->


<h2>Pagination from Kaminari</h2>

<p>Installation is easy with an addition to your <code>Gemfile</code>:</p>

<p><code>
gem 'kaminari'
</code></p>

<p>and an install:</p>

<p><code>
bundle install
</code></p>

<p>Now, you have a magical <code>page</code> method available on your models.  It works like a charm right out of the box.</p>

<p>Let's say that I have a <code>germs_controller.rb</code> (because it's a great time of year for that), where I have a list of germs that I want to paginate.  I could easily request <code>/api/v1/germs?page=2</code> and get the second page with this code in the controller:</p>

<p>```ruby germs_controller.rb
module Api
  module V1</p>

<pre><code>class GermsController &lt; ApplicationController
  def index
    @germs = Germ.page params[:page]
    render json: @germs
  end
end
</code></pre>

<p>  end
end
```</p>

<p>If you want to control the default page size, you can do that in the initializers:</p>

<p><code>ruby kaminari_config.rb
Kaminari.configure do |config|
  config.default_per_page = 20
end
</code></p>

<h2>Pagination Headers</h2>

<p>There's another feature that we want to add, and that's pagination headers.  These are going to be HTTP headers that come back in the response that indicate to clients where the relative pages are located in our API.  For instance, we asked for page 2, but where might one request the previous and next pages, 1 and 3?</p>

<p>Putting the pagination info into the header follows a pattern used in the <a href="https://developer.github.com/guides/traversing-with-pagination/">github api</a>.</p>

<p>We'll add a function to our <code>ApplicationController</code> to helps us out:</p>

<p>```ruby application_controller.rb
class ApplicationController &lt; ActionController::API</p>

<p>  protected</p>

<p>  def set_pagination_header(name, options = {})</p>

<pre><code>scope = instance_variable_get("@#{name}")
request_params = request.query_parameters
url_without_params = request.original_url.slice(0..(request.original_url.index("?")-1)) unless request_params.empty?
url_without_params ||= request.original_url

page = {}
page[:first] = 1 if scope.total_pages &gt; 1 &amp;&amp; !scope.first_page?
page[:last] = scope.total_pages  if scope.total_pages &gt; 1 &amp;&amp; !scope.last_page?
page[:next] = scope.current_page + 1 unless scope.last_page?
page[:prev] = scope.current_page - 1 unless scope.first_page?

pagination_links = []
page.each do |k, v|
  new_request_hash= request_params.merge({:page =&gt; v})
  pagination_links &lt;&lt; "&lt;#{url_without_params}?#{new_request_hash.to_param}&gt;; rel=\"#{k}\""
end
headers["Link"] = pagination_links.join(", ")
</code></pre>

<p>  end
end
```</p>

<p>This code will provide a <code>Link</code> header in the HTTP response.  Its value might look something like this:</p>

<p><code>text Link
&lt;http://myapi.com/api/v1/germs?page=1&gt;; rel="prev", &lt;http://myapi.com/api/v1/germs?page=3&gt;; rel="next"
</code></p>

<p>The values of <code>first</code>, <code>last</code>, <code>next</code>, etc are populated from calls to <a href="http://www.rubydoc.info/github/amatsuda/kaminari/Kaminari/PageScopeMethods">Kaminari methods</a> such as <code>first_page?</code>.</p>

<p>In order to have this header set on a response, we need to add it to a callback in our controller:</p>

<p>```ruby germs_controller.rb
module Api
  module V1</p>

<pre><code>class GermsController &lt; ApplicationController

  after_filter only: [:index] { set_pagination_header(:germs) }

  def index
    @germs = Germ.page params[:page]
    render json: @germs
  end

end
</code></pre>

<p>  end
end
```</p>

<p>Now, a fresh request to <code>/api/v1/germs</code> with or without the <code>page</code> query parameter should return back the <code>Link</code> header in the HTTP response which your client can use to traverse the other pages of data available in your API.</p>

<p>So, there's one way to get pagination info from Kaminari into your HTTP headers.  What would you improve?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A JSON API Errors Serializer in Rails]]></title>
    <link href="http://jaketrent.com/post/jsonapi-errors-serializer-in-rails/"/>
    <updated>2014-12-04T10:11:00-07:00</updated>
    <id>http://jaketrent.com/post/jsonapi-errors-serializer-in-rails</id>
    <content type="html"><![CDATA[<p>The default serialization of error states in Rails might not be what you want for your app.  In that case, it'd be worth knowing how to write a custom serialization format for your needs.  In my case, I am trying to match the <a href="http://jsonapi.org/format/#errors">JSON API format for errors</a>.  Here's a potential implementation...</p>

<p><img src="http://i.imgur.com/XOUecnw.jpg" alt="Rails jsonapi errors" /></p>

<!--more-->


<h2>JSON API Errors Format</h2>

<p>JSON API is cool because it is a standard format for REST APIs to serialize data.  It would be even cooler if it was well-established and it was standardized more than it currently is.  As it is, it's a standard that seems to fluctuate a fair bit.  Nevertheless, it has many worthy ideas and might be worth using as a format on your app.</p>

<p>The <a href="http://jsonapi.org/format/#errors">errors format</a> specifically asks for JSON that looks something like this:</p>

<p>```json
{
  "errors": [</p>

<pre><code>{
  "id": "name",
  "title": "Name cannot be empty"
} // ...
</code></pre>

<p>  ]
}
```</p>

<p>There must be an <code>errors</code> root attribute.  Its value is an array.  That array has individual errors that may include a number of different attributes.  Here, I have highlighted just two -- <code>id</code>, a unique id of the problem and <code>title</code>, the human-readable error message.</p>

<h2>Rails Default Error Serialization</h2>

<p>A common place for errors to be reported are in the HTTP responses for requests to the resources in your REST API.  For instance, in your model for your resource -- in this case, let's say it's a book -- you may have some validation rules for what constitutes a well-formed book.  That model might look like:</p>

<p><code>ruby book.rb
class Book &lt; ActiveRecord::Base
  validates :title, presence: true
end
</code></p>

<p>Thus, if I try to create a new book without a title, I should get some sort of error.  And indeed, I do.  If I have a <code>books_controller.rb</code> that looks like this:</p>

<p>```ruby books_controller.rb
class BooksController &lt; ApplicationController
  def create</p>

<pre><code>book = Book.new(book_params)
if book.save
  render json: book
else
  render json: book.errors  # Allowing default serialization
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def book_params</p>

<pre><code>params.permit(:title)
</code></pre>

<p>  end
end
```</p>

<p>By default, Rails 4 will return an error serialization that looks like this:</p>

<p>```json
{
  "title": [</p>

<pre><code>"can't be blank"
</code></pre>

<p>  ]
}
```</p>

<h2>Custom Error Serializer in Rails</h2>

<p>But I wrote a client that doesn't consume errors in the default Rails format, so I want a custom error serialization format -- specifically one to match the JSON API specs.</p>

<p>On the line in <code>books_controller.rb</code> that was returning <code>book.errors</code>, now we'll introduce a new function to call:</p>

<p><code>ruby
render: json: ErrorSerializer.serialize(book.errors)
</code></p>

<p>We're going to write the serializer method in a separate file, <code>error_serializer.rb</code>, so it can be used in many controllers.  To gain access to it in our controller, we need to include the line:</p>

<p><code>ruby
include ErrorSerializer
</code></p>

<p>The contents of your <code>error_serializer.rb</code> can be whatever fits your use case.  For my simple JSON API implementation, it looks like:</p>

<p>```ruby error_serializer.rb
module ErrorSerializer</p>

<p>  def ErrorSerializer.serialize(errors)</p>

<pre><code>return if errors.nil?

json = {}
new_hash = errors.to_hash(true).map do |k, v|
  v.map do |msg|
    { id: k, title: msg }
  end
end.flatten
json[:errors] = new_hash
json
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Note the format includes an <code>errors</code> root attribute and an <code>id</code> and <code>title</code> for each error object.</p>

<p>Now, the errors serialization format from the API in the case of an error appears like:</p>

<p>```json
{
  "errors": [</p>

<pre><code>{
  "id": "title",
  "title": "Title can't be blank"
}
</code></pre>

<p>  ]
}
```</p>

<p>Just what we wanted.</p>

<p>I'm sure there are better places to put your error serialization logic, ways to call it, or great libraries you've worked with that do a similar thing.  Any suggestions?  Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Permit Array in Rails Strong Parameters]]></title>
    <link href="http://jaketrent.com/post/permit-array-rails-strong-parameters/"/>
    <updated>2014-01-22T11:19:00-07:00</updated>
    <id>http://jaketrent.com/post/permit-array-rails-strong-parameters</id>
    <content type="html"><![CDATA[<p>Rails 4 introduced the pattern of strong parameters at the controller layer.  As a best practice, you will explicitly list the parameters that an endpoint should accept in payloads.  Arrays are specified just slightly different.</p>

<p><img src="http://i.imgur.com/XOUecnw.jpg" alt="Rails" /></p>

<!--more-->


<h2>Strong Parameters</h2>

<p>You don't want those blackhats to update any field they want on your poor models.  Raise the shields -- strong parameters!  In ye olden days, <code>attr_accessible</code> could add some protection to your models.  Since Rails 4, it has been best practice to move this responsibility to the controller.  At that layer, you can make adjustments and allowances on a per-endpoint basis (eg, admin functionality has more power over a particular model than the layman user).</p>

<p>So, create a private function in your controller where you can filter your params for your model.  It might look like:</p>

<p>```ruby
private</p>

<p>def luchador_params
  params.require(:luchador).permit(:favorite_move, :weight)
end
```</p>

<p>You have two main methods to use:</p>

<ul>
<li><code>require</code> - ensures that the parameter is present (as in this root <code>luchador</code> key)</li>
<li><code>permit</code> - whitelist filters the parameters to the set specified</li>
</ul>


<h2>Arrays in <code>permit</code></h2>

<p>The most standard use case for <code>permit</code> is to pass it a collection of :symbols.  These keys must represent scalar values (string, number, that sort) only.  But what about arrays?  They're represented differently by an empty array:</p>

<p><code>ruby
params.require(:luchador).permit(:favorite_move, :weight, wins: [])
</code></p>

<p>But wait -- one more problem, and I don't like the answer here.  My client might send back a <code>nil</code> instead of an array (ie, when the luchador has no <code>wins</code>).  If this happens, cue ugly error:</p>

<p><code>text
Unpermitted parameter: wins
</code></p>

<p>To fix, default to empty array:</p>

<p><code>ruby
params[:luchador][:wins] ||= []
params.require(:luchador).permit(:favorite_move, :weight, wins: [])
</code></p>

<p>What have you done that looks better?  Please! :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Define Methods Dynamically in Ruby]]></title>
    <link href="http://jaketrent.com/post/define-dynamic-methods-ruby/"/>
    <updated>2013-11-26T07:28:00-07:00</updated>
    <id>http://jaketrent.com/post/define-dynamic-methods-ruby</id>
    <content type="html"><![CDATA[<p>In Ruby, it's common to see new methods defined dynamically or on the fly for your class.  And who doesn't want to have a piece of that metaprogramming?</p>

<p><img src="http://i.imgur.com/Z7WWtL0.jpg" alt="Ruby" /></p>

<!--more-->


<h2>An Example</h2>

<p>For example, I just finished an <a href="/post/exercism-review/">exercism code exercise</a> where I felt like there was a fair bit of code duplication.  I had a bunch of convenience functions that would show the conversion of a time in earth time to a time specific to a planet.  So, the API required something that looked something like this:</p>

<p>```ruby
class SpaceAge</p>

<p>  def on_earth</p>

<pre><code>seconds_on_planet :earth
</code></pre>

<p>  end</p>

<p>  def on_mercury</p>

<pre><code>seconds_on_planet :mercury
</code></pre>

<p>  end</p>

<p>  def on_venus</p>

<pre><code>seconds_on_planet :venus
</code></pre>

<p>  end</p>

<p>  # ...
end
```</p>

<p>Feeling that this might be an excessive number of similarly pattern methods, I considered ways that the API might stay in tact but the effort of maintenance of these many functions might be decreased.</p>

<h2><code>define_method</code></h2>

<p>We could collapse these methods quite a bit in the visual code by defining them dynamically, using <code>define_method</code>:</p>

<p>```ruby
class SpaceAge
  def self.on_planets(*planets)</p>

<pre><code>planets.each do |planet|
  define_method "on_#{planet}" do
    seconds_on_planet planet
  end
end
</code></pre>

<p>  end</p>

<p>  on_planets :earth, :mercury, :venus, :mars, :jupiter, :saturn, :uranus, :neptune
end
```</p>

<p>The exact same code would be generated.  It's better! But it's worse!  It's actually less readable than before.  <code>on_planets</code> as a new helper API might be nice.  But, we're not currently using this anywhere else.  The code is probably more maintainable, but it's also more stiff.  Previously, each of the methods was separate and therefore separately modifiable and customizable.  Now, there's one implementation of an "on_#{planet}" method.  This could be easier/harder to deal with, depending.  I think the readability is better because of the smaller amount of code, but the readability is worse because of the increased complexity and eye parsing required.  In the end, for my code, I stayed with the original solution for its 5-star readability.</p>

<p>But the ability to define methods dynamically is super awesome.  When do you find yourself using this super power?</p>
]]></content>
  </entry>
  
</feed>
