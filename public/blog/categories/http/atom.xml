<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: http | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/http/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2014-03-10T20:25:31-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Read Request Body in Spring Bean]]></title>
    <link href="http://jaketrent.com/post/http-request-body-spring/"/>
    <updated>2012-11-27T14:10:00-07:00</updated>
    <id>http://jaketrent.com/post/http-request-body-spring</id>
    <content type="html"><![CDATA[<p>Spring is a great addition to your Java stack.  It helps you access the request for inside your Spring beans easily.  Maybe I'm doing it wrong, but reading the request body seems blasted verbose after that.  It takes a surprising amount of code.</p>

<p><img src="http://i.imgur.com/w8Ezm.jpg" alt="Happy Spring" /></p>

<!--more-->


<h2>Access the Request</h2>

<p>Spring's bread and butter, of course, is inversion of control.  So, to get to the request object itself is no big deal.  Just inject it (canonical packages shown forâ€¦ fun, mostly):</p>

<p>{% codeblock lang:java %}
  @javax.inject.Inject
  javax.servlet.http.HttpServletRequest req;
{% endcodeblock %}</p>

<p>And now for the pile of non-abstracted code.</p>

<h2>Parse the Body</h2>

<p>Number one, the body is accessed from the <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html"><code>HttpServletRequest</code></a> object it a place that wasn't obvious to me: <code>request.getReader()</code>.  Heads up, we've got a BufferedReader here.  Hey, at least we don't get a stream that we have to wrap in more than one reader!</p>

<p>{% codeblock lang:java %}</p>

<pre><code>private String getBody() {
  String body = "";
  if (req.getMethod().equals("POST") )
  {
    StringBuilder sb = new StringBuilder();
    BufferedReader bufferedReader = null;

    try {
      bufferedReader =  req.getReader();
      char[] charBuffer = new char[128];
      int bytesRead;
      while ((bytesRead = bufferedReader.read(charBuffer)) != -1) {
        sb.append(charBuffer, 0, bytesRead);
      }
    } catch (IOException ex) {
      // swallow silently -- can't get body, won't
    } finally {
      if (bufferedReader != null) {
        try {
          bufferedReader.close();
        } catch (IOException ex) {
          // swallow silently -- can't get body, won't
        }
      }
    }
    body = sb.toString();
  }
  return body;
}
</code></pre>

<p>{% endcodeblock %}</p>

<p>The code.  There is to much.  Let me sum up.  There's only going to be a body if you are doing a post.  Otherwise, don't worry about it.  If there is data, pull it into a string.  Everything else is for (not) handling errors.</p>

<p>There's a bit there.  It's not the worst.  But after getting used to <a href="http://expressjs.com/api.html#req.body">Express' bodyParser</a>, it was hard to see this.</p>
]]></content>
  </entry>
  
</feed>
