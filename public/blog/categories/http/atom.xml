<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: http | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/http/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-12-15T09:53:49-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Expose HTTP Headers in CORS]]></title>
    <link href="http://jaketrent.com/post/expose-http-headers-in-cors/"/>
    <updated>2014-09-15T09:42:00-06:00</updated>
    <id>http://jaketrent.com/post/expose-http-headers-in-cors</id>
    <content type="html"><![CDATA[<p>For APIs, it seems more and more data is making its way into the HTTP headers.  Recently, whilst adding a <code>Link</code> header, for paging data, into the HTTP response, I realized that my browser code couldn't see it.  Who was the culprit?  CORS, of course.</p>

<p><img src="http://i.imgur.com/JAce7py.jpg" alt="Cors" /></p>

<!--more-->


<h2>Headers in Browser</h2>

<p>It was just another day, and I was developing in my browser of choice, Chrome, known, in part, for its unequaled developer tools.  The <code>Link</code> header that I had added onto my HTTP responses for my API were viewable from the Network tab.  It looked good.  The browser could see it, curl could even see it.</p>

<p>In the browser client code, I was using <code>superagent</code>, but the code failed to see it.  I'd run:</p>

<p><code>js
var request = require('superagent')
request.get('myApi').end(function (err, res) {
  res.xhr.getResponseHeader('Link') // nothing
  res.headers.link // nothing
})
</code></p>

<p>And the header was not coming through.  I ran the same command in the console, <code>res.xhr.getResponseHeader('Link')</code>, and got the error response:</p>

<p><code>
Refused to get unsafe header ‘Link’
</code></p>

<p>These are a classic CORS symptoms.</p>

<h2>CORS Spec</h2>

<p>Well, a few great <a href="http://blog.import.io/tech-blog/exposing-headers-over-cors-with-access-control-expose-headers">google results</a> later, I ended up at the <a href="http://www.w3.org/TR/cors/#simple-response-header">CORS spec</a>, which drones on that only simple headers are allowable in CORS requests by default.  These headers include:</p>

<ul>
<li>Cache-Control</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Pragma</li>
</ul>


<p><code>Link</code> is definitely not on that list.  So, how to add it?</p>

<h2>Access-Control-Expose-Headers in rack-cors</h2>

<p>Like the other CORS headers, the <code>Access-Control-</code> prefix is present.  The one you're looking for is <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS"><code>Access-Control-Expose-Headers</code></a>.  It is a comma-separated list of header names. You can add this header manually to your response, or depending on the library you're using, it might be added differently.</p>

<p>I was using <code>rack-cors</code>.  Thus, my addition ended up looking something like:</p>

<p>```ruby config/application.rb</p>

<h1>...</h1>

<p>config.middleware.use Rack::Cors do
  allow do</p>

<pre><code>origins '*'
resource '*', :headers =&gt; :any, :methods =&gt; [:get, :post, :put, :delete, :options], :expose =&gt; ['Link']
</code></pre>

<p>  end
end
```</p>

<p>Can you see that the <code>expose</code> key was the key for me?  Once that was added, the browser let the client code read the link, and all was safe and well.</p>

<h2>Bonus:</h2>

<p>As a bonus, here's a great client library for consuming a <a href="https://developer.github.com/v3/#link-header">GitHub API-style</a> <code>Link</code> header, called <a href="https://www.npmjs.org/package/parse-link-header">parse-link-header</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Read Request Body in Spring Bean]]></title>
    <link href="http://jaketrent.com/post/http-request-body-spring/"/>
    <updated>2012-11-27T14:10:00-07:00</updated>
    <id>http://jaketrent.com/post/http-request-body-spring</id>
    <content type="html"><![CDATA[<p>Spring is a great addition to your Java stack.  It helps you access the request for inside your Spring beans easily.  Maybe I'm doing it wrong, but reading the request body seems blasted verbose after that.  It takes a surprising amount of code.</p>

<p><img src="http://i.imgur.com/w8Ezm.jpg" alt="Happy Spring" /></p>

<!--more-->


<h2>Access the Request</h2>

<p>Spring's bread and butter, of course, is inversion of control.  So, to get to the request object itself is no big deal.  Just inject it (canonical packages shown for… fun, mostly):</p>

<p>{% codeblock lang:java %}
  @javax.inject.Inject
  javax.servlet.http.HttpServletRequest req;
{% endcodeblock %}</p>

<p>And now for the pile of non-abstracted code.</p>

<h2>Parse the Body</h2>

<p>Number one, the body is accessed from the <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html"><code>HttpServletRequest</code></a> object it a place that wasn't obvious to me: <code>request.getReader()</code>.  Heads up, we've got a BufferedReader here.  Hey, at least we don't get a stream that we have to wrap in more than one reader!</p>

<p>{% codeblock lang:java %}</p>

<pre><code>private String getBody() {
  String body = "";
  if (req.getMethod().equals("POST") )
  {
    StringBuilder sb = new StringBuilder();
    BufferedReader bufferedReader = null;

    try {
      bufferedReader =  req.getReader();
      char[] charBuffer = new char[128];
      int bytesRead;
      while ((bytesRead = bufferedReader.read(charBuffer)) != -1) {
        sb.append(charBuffer, 0, bytesRead);
      }
    } catch (IOException ex) {
      // swallow silently -- can't get body, won't
    } finally {
      if (bufferedReader != null) {
        try {
          bufferedReader.close();
        } catch (IOException ex) {
          // swallow silently -- can't get body, won't
        }
      }
    }
    body = sb.toString();
  }
  return body;
}
</code></pre>

<p>{% endcodeblock %}</p>

<p>The code.  There is to much.  Let me sum up.  There's only going to be a body if you are doing a post.  Otherwise, don't worry about it.  If there is data, pull it into a string.  Everything else is for (not) handling errors.</p>

<p>There's a bit there.  It's not the worst.  But after getting used to <a href="http://expressjs.com/api.html#req.body">Express' bodyParser</a>, it was hard to see this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serve a Directory]]></title>
    <link href="http://jaketrent.com/post/serve-directory/"/>
    <updated>2012-06-06T14:14:00-06:00</updated>
    <id>http://jaketrent.com/post/serve-directory</id>
    <content type="html"><![CDATA[<p>Don't you hate developing a blasted simple webpage that does some asynchronous requests that gets you into cross-origin policy trouble.  If you just read a <code>.html</code> file off the file system, this will bite you.  But, it's easy to get around.  Just host your .html file on a simple http server.  And it's easy to make that happen.  Here's one way.</p>

<!--more-->


<h2>Attacked by Snakes</h2>

<p>First, Verify you have python installed:</p>

<p>```bash</p>

<blockquote><p>python --version
Python 2.7.3
```</p></blockquote>

<h2>'Tis a Gift to Be Simple</h2>

<p>Then navigate to the directory that you'd like to serve up and type:</p>

<p><code>bash
python -m SimpleHTTPServer 5000
</code></p>

<p>Where "5000" is the port you'd like to serve it on.  (Defaults to 80.)  Then point your browser to:</p>

<pre><code>http://localhost:5000
</code></pre>

<p>And rock your local dev.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XQuery Browser Language Detection]]></title>
    <link href="http://jaketrent.com/post/xquery-browser-language-detection/"/>
    <updated>2011-05-06T14:07:00-06:00</updated>
    <id>http://jaketrent.com/post/xquery-browser-language-detection</id>
    <content type="html"><![CDATA[<p>If you've created an internationalized website lately, you've probably implemented some sort of language chooser widget in your site ui to allow your users to indicate which language they would like to see content displayed in.  What I often forget is that the user may have already made this indication previous to visiting your site, and you might be like to think about respecting their previously indicated preference.</p>

<!--more-->


<p>Within the browser, a user can store their preferred language.  The w3c has a <a href="http://www.w3.org/International/questions/qa-lang-priorities#changing">nice browser list</a> to give some terse instructions on how to set your language in your browser.</p>

<p>Your app might read the browser preference differently, but at least one component is consistent.  Your browser is going to pass an <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">HTTP header</a> called "Accept-Language" to your app.  In a recent app, I read this using XQuery:</p>

<p><code>
xdmp:get-request-header("Accept-Language")
</code>
That's going to return a string something like this one, which is mine:</p>

<p><code>
en-US,en;q=0.8
</code></p>

<p>This is a comma-delimited list of 2-letter <a href="http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">language codes &lt;http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes><code>_ and 2-letter</code>locale codes</a>, informally "language-locale".</p>

<p>The "q=#" describes the quality of the language.  The higher, the quality, the more preferred.  Notice that in my header, "en-US", American English, does not have a "q=" attribute.  The lack of "q=" indicates a default, actually the highest preference, of 1.0.</p>

<p>There's also a Content-Language header, that I suppose you could use if you were making a differentiation for what language the actual content was using compared to the site chrome.  But, as far as I can tell, this is used less.  Even less by myself.  (Never.)</p>

<p>Here's a full XQuery implementation for MarkLogic that will read the header and parse out the preferred language.  In my implementation, I don't care about the locale, so I'm paying attention only to the language code.  The regex used is an adjustment of <a href="http://www.thefutureoftheweb.com/blog/use-accept-language-header">this original php regex</a>:</p>

<p>```
xquery version "1.0-ml";</p>

<p>declare option xdmp:mapping "false";</p>

<p>declare function local:get-browser-lang() as xs:string? {
  let $header := xdmp:get-request-header("Accept-Language")
  return if (fn:exists($header)) then</p>

<pre><code>local:get-top-hit-lang($header)
</code></pre>

<p>  else</p>

<pre><code>()
</code></pre>

<p>};</p>

<p>declare private function local:get-top-hit-lang($header as xs:string) as xs:string? {
  let $langs :=</p>

<pre><code>for $entry in fn:tokenize(local:parse-header($header), ",")
let $data := fn:tokenize($entry, "q=")
let $quality := $data[2]
order by
  if (fn:exists($quality) and fn:string-length($quality) gt 0) then
    xs:float($quality)
  else
    xs:float(1.0)
  descending
return $data[1]
</code></pre>

<p>  return $langs[1]
};</p>

<p>declare private function local:parse-header($header as xs:string) as xs:string {
  let $regex := "(([a-z]{1,8})(-[a-z]{1,8})?)\s<em>(;\s</em>q\s<em>=\s</em>(1|0.[0-9]+))?"
  let $flags := "i"
  let $format := "$2q=$5"
  return fn:replace(fn:lower-case($header), $regex, $format)
};</p>

<p>local:get-browser-lang()
```</p>

<p>This implementation just takes the top language, no matter what.  You might want to check to see if your site actually supports the language before picking from the browser preference.  While you're looping through the list of acceptable languages in get-top-hit-lang(), you could add a where clause to check for support.</p>

<p>Do you find that the sites you visit respect this header?</p>

<h2>Update</h2>

<p>Here's an updated version of the code that respects secondary language selections as well (not just first choice):</p>

<p>```
xquery version "1.0-ml";</p>

<p>declare option xdmp:mapping "false";</p>

<p>declare function local:get-browser-lang() as xs:string? {
  let $header := xdmp:get-request-header("Accept-Language")
  return if (fn:exists($header)) then</p>

<pre><code>local:get-top-supported-lang(local:get-browser-langs($header), ("en", "es", "it"))
</code></pre>

<p>  else</p>

<pre><code>()
</code></pre>

<p>};</p>

<p>declare function local:get-top-supported-lang($ordered-langs as xs:string<em>, $translations as xs:string</em>) as xs:string? {
  if (fn:empty($ordered-langs)) then</p>

<pre><code>()
</code></pre>

<p>  else</p>

<pre><code>let $lang := $ordered-langs[1]
return if ($lang = $translations) then
  $lang
else
  local:get-top-supported-lang(fn:subsequence($ordered-langs, 2), $translations)
</code></pre>

<p>};</p>

<p>declare private function local:get-browser-langs($header as xs:string) as xs:string* {
  let $langs :=</p>

<pre><code>for $entry in fn:tokenize(local:parse-header($header), ",")
let $data := fn:tokenize($entry, "q=")
let $quality := $data[2]
order by
  if (fn:exists($quality) and fn:string-length($quality) gt 0) then
</code></pre>

<p>  xs:float($quality)</p>

<pre><code>  else
</code></pre>

<p>  xs:float(1.0)</p>

<pre><code>  descending
return $data[1]
</code></pre>

<p>  return $langs
};</p>

<p>declare private function local:parse-header($header as xs:string) as xs:string {
  let $regex := "(([a-z]{1,8})(-[a-z]{1,8})?)\s<em>(;\s</em>q\s<em>=\s</em>(1|0.[0-9]+))?"
  let $flags := "i"
  let $format := "$2q=$5"
  return fn:replace(fn:lower-case($header), $regex, $format)
};</p>

<p>local:get-browser-lang()
```</p>
]]></content>
  </entry>
  
</feed>
