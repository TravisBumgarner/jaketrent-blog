<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: easymock | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/easymock/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-05-03T08:11:00-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[EasyMock Cause-Effect Exception Mapping]]></title>
    <link href="http://jaketrent.com/post/easymock-cause-effect-exception-mapping/"/>
    <updated>2009-07-06T09:36:00-06:00</updated>
    <id>http://jaketrent.com/post/easymock-cause-effect-exception-mapping</id>
    <content type="html"><![CDATA[<p>EasyMock is a great tool for separating external dependencies from unit tests.  There is a learning curve to learning the mock method of testing, and unfortunately, EasyMock does not give very good prompts when you do something wrong.  The exception messages are actually quite cryptic.  This article is meant to be a crude mapping of exception output and the behavior that might have caused it.  At least, this is a log of many of my experiences with EasyMock and how I usually get into the messes I do.  It is quite possible that the same exception output could be had via different behavior.  It's also important to note that I'm not trying to show how to create meaningful tests here (I don't even show full tests half the time), only help figure out how mysterious EasyMock exceptions were thrown.  These experiences were documented on EasyMock 2.2 and 2.4.</p>

<!--more-->


<h3>Argument Matcher</h3>

<h4>Exception</h4>

<p>```java
java.lang.IllegalStateException: 2 matchers expected, 1 recorded.
  at org.easymock.internal.ExpectedInvocation.createMissingMatchers(ExpectedInvocation.java:41)
  at org.easymock.internal.ExpectedInvocation.(ExpectedInvocation.java:33)
  at org.easymock.internal.ExpectedInvocation.(ExpectedInvocation.java:26)
  at org.easymock.internal.RecordState.invoke(RecordState.java:64)
  at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:24)
  at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:45)
  at $Proxy0.findFoos(Unknown Source)
  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</p>

<pre><code>...
</code></pre>

<p>```</p>

<h4>Behavior</h4>

<p>Sometimes you don't know the exact instance of the objects that will be passed as arguments into methods on external dependencies.  Thus, the mocked call on that method will be different than normal.  EasyMock provides a method, EasyMock.isA().  From the JavaDoc, this method "Expects an object implementing the given class."  Essentially, it looks for type (class) instead of instance (object) when setting up the EasyMock.expect().  This is useful when you don't have the actual instance of a method parameter from the context of your test, like a local variable.</p>

<p>So, if I was testing a method like this:</p>

<p>```java
public class BeingTested {
   void doSomething(Integer code) {</p>

<pre><code>  StringBuilder sb = new StringBuilder()
  externalService.serviceCall(sb, code);
</code></pre>

<p>   }
}</p>

<p>interface ExternalService {
   void serviceCall(StringBuilder sb, Integer code);
}
```</p>

<p>And tried to test it like this:</p>

<p><code>java
@Test
public void testDoSomething() {
   /* ... */
   externalService.serviceCall(isA(StringBuilder.class), 123);
   expectLastCall();
   /* ... */
   tested.doSomething(123);
   /* ... */
}
</code></p>

<p>I will inevitably get the above exception.</p>

<h4>Explanation</h4>

<p>So, now to get rid of this nasty exception.  Use of isA() either implies that you really don't care what the exact instance of the method parameter is or you use it to get around another constraint on your code.  Either way, EasyMock, through this wonderful exception, is trying to tell you that <strong>if you're going to use isA() for one of the method parameters, it must be used on all!</strong>  Thus, to keep your StringBuilder isA() call, you must add one for Integer in this example.</p>

<p><code>java
externalService.serviceCall(isA(StringBuilder.class), isA(Integer.class));
</code></p>

<h3>Behavior Definition</h3>

<h4>Exception</h4>

<p><code>java
java.lang.IllegalStateException: missing behavior definition for the preceeding method call getIsInitialized()
  at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:30)
  at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:61)
...
</code></p>

<h4>Behavior</h4>

<p>If I was testing a method like this:</p>

<p>```java
public class SomethingElse {
   void doSomething() {</p>

<pre><code>  externalService.checkSomething();
</code></pre>

<p>   }
}</p>

<p>interface ExternalService {
   int checkSomething();
}
```</p>

<p>And tried to test it like this:</p>

<p><code>java
@Test
public void testDoSomething() {
   /* ... */
   expect(externalService.checkSomething());
   /* ... */
   tested.doSomething();
   /* ... */
}
</code></p>

<p>I just may get the above exception.</p>

<h4>Explanation</h4>

<p>The issue is that you've only half-told EasyMock what you expect to happen.  Because the checkSomething() method has a return type other than void, when need to explicitly tell EasyMock what to expect as the return value.  That is done by using the andReturn() method.</p>

<p><code>java
expect(externalService.checkSomething()).andReturn(0);
</code></p>

<h3>Mock methods use Mocks</h3>

<h4>Exception</h4>

<p>Here's an exception that may very well be thrown in many instances by EasyMock.  It might not be very helpful there; it certainly wasn't here.</p>

<p><code>java
org.easymock.internal.RuntimeExceptionWrapper
  at org.easymock.classextension.internal.ClassExtensionHelper.getControl(ClassExtensionHelper.java:52)
  at org.easymock.classextension.EasyMock.replay(EasyMock.java:117)
...
</code></p>

<h3>Behavior</h3>

<p>When you're using EasyMock, there are several steps that you need to take in setting up your mock scenario.  And we all know that the more steps a process takes, the more prone it is to error.  Well, as the user of the EasyMock API, I make errors all the time.  For instance, as I'm evolving my test, deciding that some objects will be mocked one moment and not mocked the next, the test changes but sometimes I forget to adjust the multi-step EasyMock setup process at every step.  For instance, I had a test:</p>

<p><code>java
@Test
public void testSomething() {
   Something something = createMock(Something.class);
   Else else = createMock(Else.class);
   /* ... expects ... */
   replay(something, else);
   /* ... */
   verify(something, else);   
}
</code></p>

<p>And I refactor it to be:</p>

<p><code>java
@Test
public void testSomething() {
   Something something = createMock(Something.class);
   Else else = new Else();
   /* ... expects ... */
   replay(something, else);
   /* ... */
   verify(something, else);   
}
</code></p>

<h4>Explanation</h4>

<p>I changed the Else class to not be a mock object for the test.  But, I forgot to remove the reference to else from the replay() and verify() methods  (statically imported EasyMock methods).  So, this RuntimeExceptionWrapper exception makes no sense, but I have had it thrown many times for this reason.  To fix it, remove the non-mocks from the mock-related methods.</p>

<p><code>java
@Test
public void testSomething() {
   Something something = createMock(Something.class);
   Else else = new Else();
   /* ... expects ... */
   replay(something);
   /* ... */
   verify(something);   
}
</code></p>

<h3>Last Call for Mocks</h3>

<h4>Exception</h4>

<p>Again, I believe I may have seen this exception in more than one type of situation.  This is just one.</p>

<p><code>java
java.lang.IllegalStateException: no last call on a mock available
  at org.easymock.EasyMock.getControlForLastCall(EasyMock.java:174)
  at org.easymock.EasyMock.expectLastCall(EasyMock.java:167)
  ...
</code></p>

<h4>Behavior</h4>

<p>I use IntelliJ IDEA, which I love for many reasons.  One of them is it's robust refactoring toolset.  For instance, Ctrl-Alt-V, by default, is the introduce variable shortcut.  So, you select the expression that returns some value, introduce variable, and voila, that return value is stored in a nice local variable for you (or there are other options to refactor into fields, constants, parameters, and such.  End shameless plug.  Anywho, EasyMock scenarios value ordering of method calls.  This can become problematic if you're not careful to maintain its delicate order needs (which a refactoring tool, for instance, knows nothing about).</p>

<p>If I start with this as a part of a test:</p>

<p><code>java
someObj.doSomething();
expectLastCall().andThrow(new Exception());
</code></p>

<p>And then somehow came to this, let's assume for the sake of a refactor:</p>

<p><code>java
someObj.doSomething();
Exception e = new Exception();
expectLastCall().andThrow(e);
</code></p>

<p>You will get the above exception.</p>

<h4>Explanation</h4>

<p>Simply, the problem is that something has been interjected in between the method call and the expect.  Because these things are syntatically separate with the void return type methods, this becomes a possible pitfall.  To fix, put the two together, keep the ordering correct.</p>

<p><code>java
Exception e = new Exception();
someObj.doSomething();
expectLastCall().andThrow(e);
</code></p>

<h3>Throws like a girl</h3>

<h4>Exception</h4>

<p><code>java
java.lang.IllegalArgumentException: last method called on mock cannot throw com.lowagie.text.DocumentException
  at org.easymock.internal.MocksControl.andThrow(MocksControl.java:137)
   ...
</code></p>

<h4>Behavior</h4>

<p>When I'm trying to test the catch blocks in my code, often times I will simulate an exception being thrown with the mock andThrow() method.  If I start with a class like this:</p>

<p>```java
public class Something {
   void doSomething() {</p>

<pre><code>  try {
     externalService.callService();
  } catch (Exception e) { 
     // log 
  }
</code></pre>

<p>   }
}</p>

<p>interface ExternalService {
   void callService();
}
```</p>

<p>And do a test like this:</p>

<p><code>java
@Test
public void testDoSomething() {
   /* ... */
   externalService.callService();
   expectLastCall().andThrow(new Exception());
   /* ... */
}
</code></p>

<p>You are likely to get the above problematic exception.</p>

<h4>Explanation</h4>

<p>Sure you catch the exception; sure you want to check your catch block logic (lame here); but andThrow() needs to know that it's doing the right thing.  Expectations in mocks are really quite flexible and allow us to make the code do things it might not otherwise do through simulated conditions in a test.  But, EasyMock will not do the impossible.  And in this case, it knows that if you're expecting a checked exception to be thrown, it must be declared as thrown, which it is not.  So, to fix this, your code must actually declare that it throws Exception.  Of course, only do this if it makes sense.  And, if it doesn't, why are you testing it anyway?</p>

<p>For interface and implementing class:</p>

<p><code>java
void callService() throws Exception;
</code></p>

<h3>Half-Mocked Expectations</h3>

<h4>Exception</h4>

<p>This exception is very similar to that mentioned in the "<a href="#mocksusemocks">Mock methods use Mocks</a>" section above.</p>

<p><code>java
java.lang.IllegalStateException: void method cannot return a value
  at org.easymock.internal.MocksControl.andReturn(MocksControl.java:128)
   ...
</code></p>

<h4>Behavior</h4>

<p>It is convenient and more unit-like to test one method in a class that calls other methods in that class but not test the other method at that point.  Thus, we half-mock the class, mocking the "external" methods, the ones not being tested in this particular test, but not mocking the method being tested.  Did I mention how useful this is?  Let's try it.</p>

<p>Start with this code:</p>

<p>```java
public class TestMe {
   void doTestNow() {</p>

<pre><code>  /* ... */
  doTestLater();
</code></pre>

<p>   }
}
```</p>

<p>And this test:</p>

<p><code>java
@Test
public void testDoTestNow() throws NoSuchMethodException {
   Method doTestLater = TestMe.class.getDeclaredMethod("doTestLater");
   TestMe me = createMock(TestMe.class, doTestLater);
   /* ... */
   me.doTestLater();
   expectLastCall();
   replay(me);
   me.doTestNow();
   verify(me);
}
</code></p>

<p>When we instantiate TestMe, it looks like a mock, but when we pass in var-arg java.lang.reflect.Method parameters, only those specified methods are mocked.  This works, is cool, and allows the doTestNow() method to be tested independent of the doTestLater() method and its test.  Now, let us pretend that we change our test to not want to mock calls to methods on TestMe, and instead of doing this:</p>

<p><code>java
TestMe me = createMock(TestMe.class, doTestLater);
</code></p>

<p>We do this:</p>

<p><code>java
TestMe me = new TestMe();
</code></p>

<p>We will get the icky exception shown above.</p>

<h4>Explanation</h4>

<p>The first thing we tried to do worked, but the reason we got the exception that we're decrypting is because we made the refactor to the test, making the TestMe instance totally non-mocked, but we left the expectLastCall() on the me.doTestLater() call.  Simply remove that expectation and you're good to go again.  Just remember, now you're actually calling into the body of doTestLater().</p>

<p>Well, that's it for this current round into the EasyMock foray.  But, I'm sure to continue to make mistakes using this helpful, yet often-problematic tool that is EasyMock.  If you have any cause-effect mappings related EasyMock that might help, let us know.</p>
]]></content>
  </entry>
  
</feed>
