<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ember | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/ember/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2017-01-24T07:53:25-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Broccoli Ember Emblem]]></title>
    <link href="http://jaketrent.com/post/broccoli-ember-emblem/"/>
    <updated>2014-05-30T07:18:00-06:00</updated>
    <id>http://jaketrent.com/post/broccoli-ember-emblem</id>
    <content type="html"><![CDATA[<p>Make broccoli compile your emblem templates so they're ready for your ember app.</p>

<p><img src="http://i.imgur.com/85v8PQP.png" alt="Broccoli Ember Emblem" /></p>

<!--more-->


<h2>The Libraries</h2>

<p><a href="https://www.npmjs.org/package/broccoli">Broccoli</a> builds your assets quickly.  It makes heavy use of caching so it only has to rebuild affected subtrees when files change.  <a href="http://emblemjs.com/">Emblem</a> is a significant whitespace version of <a href="http://handlebarsjs.com/">Handlebars</a> templates, similar in style to <a href="http://slim-lang.com/">Slim</a> or <a href="http://jade-lang.com/">Jade</a>.  <a href="http://emberjs.com/">Ember</a> is a MVC framework for building browser apps.</p>

<p>Put them all together, and you have something that will help you compile your templates quickly for your browser app.  The <a href="https://github.com/jaketrent/broccoli-ember-emblem">broccoli-ember-emblem</a> plugin for Broccoli will do just that.</p>

<h2>Install</h2>

<p>To use the library, you'll need broccoli installed first.  Then, you'll install the plugin via npm:</p>

<p><code>
npm install --save-dev broccoli-ember-emblem
</code></p>

<h2>Usage</h2>

<p>You'll setup the plugin in your app's <code>Brocfile.js</code>.  That setup might look something like this:</p>

<p>```js
var emblem = require('broccoli-ember-emblem')
var mergeTrees = require('broccoli-merge-trees')
var pickFiles = require('broccoli-static-compiler')</p>

<p>function preprocess (tree) {
  tree = emblem(tree, {</p>

<pre><code>stripPathFromName: 'tmpl/'
</code></pre>

<p>  })
  return tree
}</p>

<p>var tmplTree = 'client/tmpl'
tmplTree = pickFiles(tmplTree, {
  srcDir: '/',
  destDir: '/tmpl'
})
tmplTree = preprocess(tmplTree)</p>

<p>module.exports = mergeTrees([ /<em> other trees, </em>/ tmplTree ])
```</p>

<p>Note a few things:</p>

<ul>
<li>I'm using another plugin, <code>broccoli-static-compiler</code> to move files around in the broccoli build directories.  This is to be able to identify separate trees that both use similar file filters (eg, *.js for both src scripts and templates).</li>
<li>I'm using the one option for the <code>broccoli-ember-emblem</code> plugin, <code>stripPathFromName</code>, which allows me to remove the path name from the template name in output.  For example, if I have a file at <code>tmpl/application.emblem</code>, I want the template name in ember to be <code>application</code>, not <code>tmpl/application</code>.</li>
<li>Final output is merged into a single tree via another plugin, <code>broccoli-merge-trees</code>.</li>
</ul>


<h2>Output</h2>

<p>Broccoli will take care of finding all of your template files.  It will use directories and filenames as the input for template names.  As a few examples, here is input and output as it might happen in the above configuration:</p>

<ul>
<li>File: <code>client/tmpl/application.emblem</code> becomes: <code>Ember.TEMPLATES['application']</code></li>
<li>File: <code>client/tmpl/components/song.emblem</code> becomes: <code>Ember.TEMPLATES['components/song']</code></li>
</ul>


<p>Notice that Ember requires all templates to be registered on the <code>Ember.TEMPLATES</code> object.  Later, at app runtime, they are looked up on that object by name.</p>

<p>So, use the plugin and win.  How does your template compilation for Ember/Emblem differ?  What other features do you wish were supported here?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Convert App From EmberFire to Fireplace]]></title>
    <link href="http://jaketrent.com/post/convert-app-from-emberfire-to-fireplace/"/>
    <updated>2014-03-17T16:17:00-06:00</updated>
    <id>http://jaketrent.com/post/convert-app-from-emberfire-to-fireplace</id>
    <content type="html"><![CDATA[<p>There are a few changes required to convert your Ember app from using EmberFire to Fireplace.  Here are a few that I found to be required.  There are probably more.</p>

<p><img src="http://i.imgur.com/1Jg69Pf.jpg" alt="Firebase" /></p>

<!--more-->


<h2>Your Options</h2>

<p><a href="https://github.com/firebase/emberFire">EmberFire</a> and <a href="https://github.com/rlivsey/fireplace">Fireplace</a> both provide an API for you to integrate your Ember app with a <a href="https://www.firebase.com/">Firebase</a> backend.  You don't need either library; they provide a more high-level API and help handle some of the nitty gritties of making Ember data-binding work with your socket traffic.  You can just use the <a href="https://www.firebase.com/docs/javascript/firebase/index.html">Firebase JavaScript API</a>.</p>

<p>I was using EmberFire with ember-data first.  It worked pretty well.  I ran into a few hiccups where it seemed like model relationships weren't working quite right in a couple places, but I worked around it for my simple app.  Fireplace was recommended to me as a good option instead of EmberFire.  From those that know more about this than I do, Fireplace was described as "the thing that ember-data should have been," and way more capable than EmberFire.  As far as I can tell, they look very similar.  But, if you should want to switch, here are the basic changes:</p>

<h2>Changes Required</h2>

<h3>Set the Store</h3>

<p>Instead of setting up an adapter for Firebase to work with Ember data, you want to define a store on your app.  That might look like this:</p>

<p><code>coffeescript
App.Store = FP.Store.extend
  firebaseRoot: 'https://myfirebase.firebaseio.com'
</code></p>

<p>Note that the store is of type <code>FP.Store</code> instead of <code>DS.Store</code>.</p>

<h3>Remove ember-data</h3>

<p>Now that you have another store set, you want to make sure you remove ember-data so it doesn't try to interact with it.  If you forget, you will get an error at runtime:</p>

<p><code>
Uncaught Error: Assertion Failed: The initializer 'store' has already been registered
</code></p>

<h3>Add ember-inflector</h3>

<p>Ember-data comes bundled with ember-inflector.  But, now that ember-data is gone, we need to fetch this library separately.  This is the library responsible for inferring types in your models based on property names.  To get it, you'll need the <a href="https://github.com/stefanpenner/ember-inflector">ember-inflector source</a>.  You'll notice that there isn't a nice package built for you.  Instead, you'll have to build it with Ruby tools.</p>

<p>To make your own version from source, follow these steps:</p>

<p><code>
git clone git@github.com:stefanpenner/ember-inflector.git
rake bundle
rake dist
cp dist/modules/ember-inflector.js your_project_dir
</code></p>

<p>For convenience, at the risk of being out-dated, I've uploaded the version that I built as of 17 Mar 2014 to a <a href="https://gist.github.com/jaketrent/9621891">gist of ember-inflector at 32e30eb</a>.`</p>

<h3>Change Model Definitions</h3>

<p>Your models will need to change, but not by much.  <code>DS.Model</code> becomes <code>FP.Model</code>.  <code>DS.attr</code> becomes <code>FP.attr</code>.  The changes are pretty much one-to-one in requiring just a namespace change.</p>

<h3>Optionally Change Finds</h3>

<p>Where you use ember-data's <code>model.find</code> function, you may want to change to use Fireplace's <code>model.fetch</code>.  <code>fetch</code>, in this case will return a promise where <code>find</code> does not.</p>

<h3>Change Deletes</h3>

<p>Beyond the above, only API that broke for me was ember-data's <code>model.destroyRecord</code>.  It seems on that this is the different, because <code>save</code> and <code>createRecord</code> remain the same.  But, for the delete, the API becomes simply <code>model.delete</code>.</p>

<h3>Other Changes</h3>

<p>The app I converted was quite simple, so I'm thinking that there will be other changes required.  What have you run into?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Detecting Window Closing in Ember]]></title>
    <link href="http://jaketrent.com/post/ember-window-beforeunload/"/>
    <updated>2014-03-17T08:04:00-06:00</updated>
    <id>http://jaketrent.com/post/ember-window-beforeunload</id>
    <content type="html"><![CDATA[<p>In a long-running app such as you might build in Ember, it can be useful to detect when the window is closing.  This is easily detected with JavaScript, and there are easy places to put the code in your Ember app.</p>

<p><img src="http://i.imgur.com/85v8PQP.png" alt="Ember beforeunload" /></p>

<!--more-->


<h2>beforeunload</h2>

<p>The <code>window</code> event that you want to listen for is <code>beforeunload</code>.  You might bind to the event like so:</p>

<p><code>coffeescript
$(window).bind 'beforeunload', -&gt;
  'Are you sure you want to close this window?'
</code></p>

<p>Return a string from the function.  This string will be displayed in a browser-native confirm-style dialogue.</p>

<h2>beforeunload in Ember</h2>

<p>Now, if your app is controlled by Ember, you're likely going to want it to handle bindings such as this from within Ember.  There are several places you might want to put this code.  Your decision will depend on the needs of your app.  You can put it in a route or controller.  The scope of that route or controller should match the scope for which you want the <code>beforeunload</code> event to be caught.  In other words, if you want <code>beforeunload</code> to be caught for the entire app, put the listener in <code>ApplicationRoute</code> (or <code>ApplicationController</code>).  Or if you wanted a more limited scope, put the listener in a more specific route.</p>

<p>For instance, if you wanted to save a blog post when the user closes a tab, you might implement something like this:</p>

<p>```coffeescript
App.BlogEditController = Ember.ObjectController.extend
  saveBeforeClose: (-></p>

<pre><code>$(window).bind 'beforeunload', =&gt;
  @get('model').save()
  'Are you sure you want to leave unsaved work?'
</code></pre>

<p>  ).on 'init'
```</p>

<h2>In Practice</h2>

<p>In practice, the UX for this kind of feature can be tricky.  If someone closes a tab, odds are they meant to and don't want to be bothered with a confirm dialogue asking them to reiterate their decision.  On the other hand, maybe the didn't realize the implications of closing out the app, such as in the case of unsaved work, and they become very grateful for the reminder to stay and save something.</p>

<p>In the case of the last example, it would be cool if we could detect the window closing, save the work automatically, and let the user close the tab as they indicated without interruption.  For asynchronous actions such as network requests, this is problematic.  The request will not finish before the browser has trashed the whole window.  In cases such as this, you will need to synchronize your requests to block before finishing execution of the <code>beforeunload</code> event callback.</p>

<p>So, does this work for you?  How might you make it better?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Developing an Ember Edge Review]]></title>
    <link href="http://jaketrent.com/post/developing-an-ember-edge-review/"/>
    <updated>2014-01-23T11:19:00-07:00</updated>
    <id>http://jaketrent.com/post/developing-an-ember-edge-review</id>
    <content type="html"><![CDATA[<p>The latest book on The List at <a href="http://emberwatch.com/books">emberwatch</a> is <a href="http://bleedingedgepress.com/our-books/developing-an-ember-edge/">Developing an Ember Edge</a>.  It's a great intro book to Ember.js.</p>

<p><img src="http://i.imgur.com/85v8PQP.png" alt="Developing an Ember Edge" /></p>

<!--more-->


<p>The book is published by Bleeding Edge Press.  Pretty awesome name.  It is written by Jamie White, Matthew Beale, Christopher Sansone, Wesley Workman, and Bradley Priest, quite the host of authors.  It turns out to be a very timely read for me.  The code in the book even uses some of ember-data 1.0 beta 3.  As of this writing, that's almost the bleeding edge.</p>

<p>I would compare the book to the <a href="http://emberjs.com/guides/">Ember.js official guides</a>.  It's introductory.  It definitely favors a breadth approach.  For me, but a wee Ember babe, it brings to light some interesting details about the Ember internals or at least the approach of the framework.</p>

<h2>Format</h2>

<p>I read the book in digital form as a pdf.  I love the digitalness, but I wonder if it wouldn't have had a bit more editorial review if printed.  Perhaps this is what Bleeding Edge Press means.  The code in the snippets was all smashed to the left, destroying most indentation reading assistance.  The code bits were also a smaller font size than the prose which made the switch between the two slightly awkward to my over-taxed eyes.  By the end of the book, I wasn't surprised when I found a typo.  There were a lot but not too many.  For someone of lesser OCD, it probably would've largely gone unnoticed.  Of course, considering the engineer audience of the book, maybe that doesn't exist.</p>

<h2>The Zen of Ember</h2>

<p>The book content is really good.  I felt like it helped me piece together why things are organized in Ember as they are.  I learned more of what the pieces are by themselves and how they're meant to interact together.  The authors were also kind to point out where some of the rough edges were in terms of design (or potential misdesign by app authors) and api changes.</p>

<p>I liked the mostly-breadth approach to the writing.  The book was good for a newb and remained pretty short.  Perhaps that's because there's not too much there as a general subject without bloating this book into an API reference book. [whew]  The book struck a good balance of being technical, readable, and giving good insight into the practical use of the framework.</p>

<h2>Ember Trackr</h2>

<p>The first half of the book covers the concepts and layers of Ember, approaching mvc in general, objects, application, routes, handlebars, views, controllers, components, and models.  This takes 54 pages.  The other half(+) shows the development of a ticket tracking app.</p>

<p>The development process shown is thorough, even including the tool install, project file layout, and ui styling.  The TDD of the app in total was awesome.  It's really step by step.  Sometimes this was a little painful, but you definitely don't miss anything.  The screenshots of test runners in terminals and the app in browser windows could have been cropped for easier reading with less vertical blank space.  The testing walkthrough was really great.  They even worked through a few "unexpected" errors as one might actually encounter them.</p>

<p>The app dev portion could probably have been cut short.  About the time they start into the user management screens, we probably could have called it good.  But, they do introduce some good, new concepts in the app dev section of the book.  For instance, he covers a little on containers and <code>Ember.run</code> as it relates to testing.</p>

<p>I'm glad I read the book.  It was helpful to my slingshot into the Ember atmosphere.  Boom!  Go get it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember Dynamic Classes]]></title>
    <link href="http://jaketrent.com/post/ember-dynamic-classes/"/>
    <updated>2013-08-02T13:02:00-06:00</updated>
    <id>http://jaketrent.com/post/ember-dynamic-classes</id>
    <content type="html"><![CDATA[<p>In Ember, your state is separated from the UI inside models.  But, often you want the state of your models to be represented visually in the UI via dynamic class names.  Make it happen with <code>Ember.View</code>s.</p>

<p><img src="http://i.imgur.com/85v8PQP.png" alt="Dynamic Classes with Ember Views" /></p>

<!--more-->


<h2>Use an Ember.View</h2>

<p>A view will function as the translation layer between the state of your models and the DOM.  It will provide the logic to observe the properties within your model and expose it as a class name on the associated DOM element.</p>

<p>If I have a model with state:</p>

<p><code>coffeescript my-model.coffee
App.MyModel = App.Model.extend
  hasSomeState: true
</code></p>

<h2>Use classNameBindings</h2>

<p>Based on that state, I want to add a <code>has-some-state</code> class to the UI if it's true, and remove the class if it's false.  The view might look like:</p>

<p>```coffeescript my-model-view.coffee
App.MyModelView = Ember.View.extend
  # ...
  classNameBindings: ['hasSomeState']
  hasSomeState: (-></p>

<pre><code>@get('content').get('hasSomeState')
</code></pre>

<p>  ).property('content.hasSomeState')
```</p>

<p>The <code>hasSomeState</code> function will return a boolean has to whether or not the <code>has-some-state</code> class should be added to the element.</p>

<h2>Bind to Model Properties</h2>

<p>Now use the view in the template, being careful to match the binding of <code>content</code> so the property watching works:</p>

<p><code>haml template-fragment.jade
App.MyModelView contentBinding="this.myModelInstance"
</code></p>

<p>In the example, make sure <code>myModelInstance</code> is available in the scope of your route/controller.</p>

<p>As your model's <code>hasSomeState</code> value is changed internally with the <code>@set</code> function, the view will be notified that it needs to re-run the <code>hasSomeState</code> function, and the UI will update if needed.</p>

<p>What other methods do you utilize in Ember to get dynamic classes?</p>
]]></content>
  </entry>
  
</feed>
