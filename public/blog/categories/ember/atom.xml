<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ember | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/ember/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2013-07-03T08:41:57-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Behavior of CoffeeScript Fat Arrow]]></title>
    <link href="http://jaketrent.com/post/behavior-of-coffeescript-fat-arrow/"/>
    <updated>2013-07-01T07:39:00-06:00</updated>
    <id>http://jaketrent.com/post/behavior-of-coffeescript-fat-arrow</id>
    <content type="html"><![CDATA[<p>In CoffeeScript there are two different types of arrows for defining functions:  arrow (<code>-&gt;</code>) and fat arrow or hash rocket (<code>=&gt;</code>).  Usually, you'll use the regular arrow.  But sometimes you'll want the special behavior of the fat arrow.</p>

<p><img src="http://i.imgur.com/nGd04zX.jpg" alt="CoffeeScript fat arrow" /></p>

<!--more-->


<h2>Function Binding</h2>

<p>In JavaScript, the keyword <code>this</code> within a function refers to the thing that the function is attached to.  Since functions can be invoked in various ways in an average application, what <code>this</code> actually references will change.</p>

<p>For instance, if a function is invoked as a callback in an event handler, <code>this</code> within that handler will likely reference <code>window</code> in JavaScript running within a web browser.  Often, this is not the desired reference.</p>

<p>The solution in vanilla JavaScript is to save a reference to the context the function is defined within and then use that reference in lieu of the <code>this</code> keyword.  My favorite name to save the <code>this</code> reference into is called <code>self</code>.  In JavaScript, that might look like:</p>

<p><code>javascript manual-reference.js
this.myVal = "my val"
var self = this
var myFn = function () {
  console.log(self.myVal); // will print "my val"
}
</code></p>

<h2>CoffeeScript Function Binding</h2>

<p>CoffeeScript understands this basic need and makes the reference saving even easier.  When you use the fat arrow, or hash rocket, it will perform function binding.  It uses a variable called <code>_this</code> automatically.</p>

<h3>CoffeeScript Binding Rules</h3>

<ol>
<li>When a fat arrow is used to bind a function, a <code>_this</code> reference is saved in the same context as the function that was declared.</li>
<li>When properties of <code>this</code> are accessed inside the bound function, they will use the saved <code>_this</code> reference (e.g., <code>@myVal</code> would compile to <code>_this.myVal</code>).</li>
<li>When fat arrows are used to bind functions nested within bound functions, the <code>_this</code> reference from the top-level bound function context is used in the nested bound functions.</li>
<li>The deepest non-bound function context will be used to save a <code>_this</code> reference when a bound function is declared.</li>
</ol>


<h2>When to use Fat Arrow</h2>

<p>Given that, here are the every day rules on when to use the fat arrow:</p>

<ol>
<li>If the context of <code>this</code> in you function could change based on how it was invoked but properties of <code>this</code> need to always reference the context where the function was created, declare the function with a fat arrow.</li>
<li>If nested functions exhibit the same need as in rule #1, declare them with the fat arrow.</li>
<li>Don't bind, then not bind, then bind again in nested functions.  The inner binding will clobber the <code>_this</code> reference and will likely not be what you expect in the outer context (see the last example below).</li>
</ol>


<h2>A Swirl of Examples</h2>

<p>Here are a bunch of examples of bound and non-bound functions.  The first code snippet is the CoffeeScript source.  The second code snippet is the compiled JavaScript.</p>

<h3>No Bound Functions</h3>

<p>Just regular CoffeeScript function declarations.</p>

<p><code>coffeescript non-bound.coffee
myVal: 'my val'
myNonBoundFn: -&gt;
  console.log @myVal
</code></p>

<p>```javascript non-bound.js
({
  myVal: 'my val',
  myNonBoundFn: function() {</p>

<pre><code>return console.log(this.myVal);
</code></pre>

<p>  }
});
```</p>

<h3>Bound Function</h3>

<p>Introduced the fat arrow</p>

<p><code>coffeescript bound.coffee
myVal: 'my val'
myBoundFn: =&gt;
  console.log @myVal
</code></p>

<p>```javascript bound.js
var _this = this;
({
  myVal: 'my val',
  myBoundFn: function() {</p>

<pre><code>return console.log(_this.myVal);
</code></pre>

<p>  }
});
```</p>

<h3>Bound, Non-bound Inner Function</h3>

<p>Notice the inner function is not bound, and defaults back to just referencing <code>this</code>.</p>

<p>```coffeescript non-bound-inner.coffee
myVal: 'my val'
myBoundFn: =>
  myInnerNonBoundFn = -></p>

<pre><code>console.log @myVal
</code></pre>

<p>```</p>

<p>```javascript non-bound-inner.js
var _this = this;
({
  myVal: 'my val',
  myBoundFn: function() {</p>

<pre><code>var myInnerNonBoundFn;
return myInnerNonBoundFn = function() {
  return console.log(this.myVal);
};
</code></pre>

<p>  }
});
```</p>

<h3>Bound Within Bound Functions</h3>

<p>Inner bound function uses top-level <code>_this</code>.</p>

<p>```coffeescript bound-in-bound.coffee
myVal: 'my val'
myBoundFn: =>
  myInnerBoundFn = =></p>

<pre><code>console.log @myVal
</code></pre>

<p>```</p>

<p>```javascript bound-in-bound.js
var _this = this;
({
  myVal: 'my val',
  myBoundFn: function() {</p>

<pre><code>var myInnerBoundFn;
return myInnerBoundFn = function() {
  return console.log(_this.myVal);
};
</code></pre>

<p>  }
});
```</p>

<h3>Bound, Non-bound, then Bound Functions</h3>

<p>When <code>myVeryInnerBoundFn</code> uses the fat arrow inside of <code>myInnerNonBoundFn</code>, which does not, <code>_this = this</code> is generated again.  And when <code>myOtherBoundFn</code> is called, the <code>@what</code> property will be <code>undefined</code>.</p>

<p>```coffeescript clobber-this.coffee
myVal: 'my val'
what: 'is this?'
myBoundFn: =>
  myInnerNonBoundFn = -></p>

<pre><code>myVeryInnerBoundFn = =&gt;
  console.log @myVal
</code></pre>

<p>myOtherBoundFn: =>
  console.log @what
```</p>

<p>```javascript clobber-this.js
var _this = this;
({
  myVal: 'my val',
  what: 'is this?',
  myBoundFn: function() {</p>

<pre><code>var myInnerNonBoundFn;
return myInnerNonBoundFn = function() {
  var myVeryInnerBoundFn,
    _this = this;
  return myVeryInnerBoundFn = function() {
    return console.log(_this.myVal);
  };
};
</code></pre>

<p>  },
  myOtherBoundFn: function() {</p>

<pre><code>return console.log(_this.what);
</code></pre>

<p>  }
});
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Access Model in Ember View]]></title>
    <link href="http://jaketrent.com/post/access-model-in-ember-view/"/>
    <updated>2013-07-01T07:39:00-06:00</updated>
    <id>http://jaketrent.com/post/access-model-in-ember-view</id>
    <content type="html"><![CDATA[<p>Ember Views are used for event handling and creating reusable web components.  To make them useful and interesting, model data needs to make it into and out of the view.  Here is an example of how this works.</p>

<p><img src="http://i.imgur.com/RGKiJ0n.jpg" alt="Access model data in Ember View" /></p>

<!--more-->


<h2>Define Your View</h2>

<p>In our example, I'm making a simple dice rolling game.  I want to use a view to represent the die on the screen and to handle the roll event.  Your custom view must simply extend <code>Ember.View</code>:</p>

<p><code>coffeescript die-view.coffee
App.DieView = Ember.View.extend
  templateName: 'die'
</code></p>

<p>This is about the simplest view definition we could make.  We'll make it a bit cooler later.  For now, the view just knows where to get its markup.  The <code>die</code> template can be any valid template.  Ember, by default, uses Handlebars templates.  I prefer <a href="http://emblemjs.com/">Emblem</a> templates:</p>

<p><code>haml die.emblem
li.die = die
</code></p>

<p>This template will simply print the <code>die</code> object in an <code>li</code> with class of <code>die</code>.  (There are an unusual number of 'die' references are in this example.  This is for purely entertainment reasons, nothing more nefarious. :)</p>

<h2>Render Data in Ember View Template</h2>

<p>Next, you need to get your Ember View referenced in your template markup.  In <a href="http://emblemjs.com/syntax/">Emblem</a>, to reference a view, start the line with a capital letter, specifically the name of your view.  In this view, I list the dice in my game controller <code>rolling</code> array and render each die in the <code>DieView</code></p>

<p>```haml dice.emblem
ul.dice
  each die in this.rolling</p>

<pre><code>App.DieView
</code></pre>

<p>```</p>

<p>Using this code, the parent template <code>dice.emblem</code> passes the <code>die</code> variable to the <code>DieView</code>, where its child template, <code>die.emblem</code> renders <code>die</code> data.</p>

<h2>Pass Data Into Ember View</h2>

<p>To pass the <code>die</code> data from <code>dice.emblem</code> into the <code>DieView</code> to be used programatically, however, you need an extra attribute.  Change <code>dice.emblem</code>, adding <code>contentBinding</code>:</p>

<p>```haml dice.emblem
ul.dice
  each die in this.rolling</p>

<pre><code>App.DieView contentBinding="die"
</code></pre>

<p>```</p>

<p>Now you can access the <code>die</code> data via a special Ember View variable named <code>content</code>.  Why might you want to get to this data programatically in the view code?...</p>

<h2>Passing Data from Ember View to Controller</h2>

<p>You might want to pass it somewhere else.  Remember, Ember Views are meant to take primitive UI events and translate them into semantic events, meaningful to your application.  For example, our view might want to translate a die element <code>click</code> on the DOM into a <code>roll</code> event in the application.  We made the modification to <code>dice.emblem</code> to pass the data in.  Now, let's send it to the controller like this:</p>

<p>```coffeescript die-view.coffee
App.DieView = Ember.View.extend
  templateName: 'die'</p>

<p>  click: (evt) -></p>

<pre><code>@get('controller').send 'roll', @get 'content'
</code></pre>

<p>```</p>

<p>We retrieve the <code>content</code> variable (holding the <code>die</code>), and send it to the controller in scope as a roll event.  The controller now must implement a <code>roll</code> function.  Let's say we have a game controller.  That code might look like this:</p>

<p>```coffeescript game-ctrl.coffee
App.GameController = Ember.ObjectController.extend</p>

<p>  roll: (die) -></p>

<pre><code># roll die and advance game accordingly
</code></pre>

<p>```</p>

<p>If the controller doesn't implement this function, the current Ember Route may implement it in its <code>events</code> object.  If neither the controller or the route implement it, an exception is thrown.</p>

<p>In this way, Ember Views show their worth in collecting events and translating them to meaningful verbs that we can act upon in our application.  They become reusable, allowing us to bind different content to them on different occassions.  Do Ember Views help you in this way?  Is there a better way?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember Parent Templates]]></title>
    <link href="http://jaketrent.com/post/ember-parent-templates/"/>
    <updated>2013-05-29T07:02:00-06:00</updated>
    <id>http://jaketrent.com/post/ember-parent-templates</id>
    <content type="html"><![CDATA[<p><a href="http://emberjs.com">Ember</a>'s convention of template hierarchy is very specific.  Learn it once, and you'll know it every time.</p>

<p><img src="http://i.imgur.com/x5HT4FN.jpg" alt="Ember and Handlebars" /></p>

<!--more-->


<p><strong>Note:</strong> Code examples use <a href="http://emblemjs.com/">Emblem</a> templates and <a href="http://coffeescript.org">CoffeeScript</a>.  Vanilla Handlebars and JavaScript would work just as well.</p>

<h2>Outlets</h2>

<p>Ember templates make use of a special helper called <code>outlet</code>.  You can have one main, unnamed outlet or many named outlets.  The main thing to remember is that a child template will always render inside its parent's outlet -- so always put outlets in templates that have children.</p>

<h2>Application Template</h2>

<p>There is a top-most template that all of your templates will render inside of.  This is called the application template.  It is specified in one of two ways.  If you are including your templates as script tags, simply create a script tag that doesn't have a <code>data-template-name</code> or <code>id</code> attribute, a la:</p>

<p>```html</p>

<script type="x-emblem">
  h1 My Application
  == outlet
</script>


<p>```</p>

<p>If you are <a href="/post/precompile-ember-templates">precompiling your Ember templates</a>, which you should, you have a directory for templates.  You will put your file, called <code>application.emblem</code> in the root of that directory.  The contents of <code>templates/application.emblem</code> would be the same:</p>

<p><code>jade
h1 My Application
== outlet
</code></p>

<h2>Route Templates</h2>

<p>If you have a top-level route, it will have a top-level template.  Your route's template will have only the application template as its parent.  So, your about route:</p>

<p><code>coffeescript
App.Router.map -&gt;
  @route 'about'
</code></p>

<p>Will have an about template at <code>templates/about.emblem</code> and you could define a route as <code>AboutRoute</code>.  It will render inside of <code>application.emblem</code>'s outlet.</p>

<h2>Resource Templates</h2>

<p>Resources are interesting because you can nest other routes inside them.  Nesting routes will also result in nesting templates.  If I defined a <code>league</code> resource with a nested route for creating new leagues, it might look something like this:</p>

<p>```coffeescript
App.Router.map ->
  @resouce 'league', -></p>

<pre><code>@route 'new'
</code></pre>

<p>```</p>

<p>There are two leaf routes (and thus templates) that are created here:</p>

<ul>
<li><code>LeagueIndexRoute</code>, which uses <code>templates/league/index.emblem</code></li>
<li><code>LeagueNewRoute</code>, which uses <code>templates/league/new.emblem</code></li>
</ul>


<p>Note that you create a <code>league</code> directory inside your <code>templates</code> directory for nesting these templates.  Precompiled templates will be created at:</p>

<ul>
<li><code>Ember.TEMPLATES["league/index"]</code></li>
<li><code>Ember.TEMPLATES["league/new"]</code></li>
</ul>


<p>If you wanted to use the <code>linkTo</code> helper in a template to link to these routes, you would use this syntax:</p>

<p><code>jade
linkTo 'league.index' | List Leagues
linkTo 'league.new' | New League
</code></p>

<p>And now as far as templates, there is <em>one more</em> that we're missing.  There is a root league template that these two league leaf templates render inside of.  It should live at <code>templates/league.emblem</code>.  This template would be useful for showing UI elements that are common to all league resource things.  In the case where there is no such need, this template will probably only contain a single outlet:</p>

<p><code>jade
== outlet
</code></p>

<p>So the final template hierarchy for <code>league.new</code>, for example, is <code>application.emblem &gt; league.emblem &gt; league/new.emblem</code>.</p>

<p>There is a bit of a chatter on the Githubs about whether the root resource template is good form or not.  As in, why would you create a file that contains nothing but an empty outlet?  Couldn't the framework infer that if it was missing?</p>

<h2>Children Need All Parents</h2>

<p>Create all parents in your template chain, from the application template to the leaves.  The worst thing that can happen if you don't is that nothing will render at all, and no error messages will be displayed (pretty bad and unhelpful).</p>

<p>Most of the time, Ember will try to be helpful and give you a console warning:</p>

<blockquote><p>WARNING: The immediate parent route ('a') did not render into the main outlet and the default 'into' option ('p') may not be expected</p></blockquote>

<p>In other words: You're trying to render a child template that either doesn't have a parent template it needs or the parent template does not specify a main outlet.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Precompile Ember Templates]]></title>
    <link href="http://jaketrent.com/post/precompile-ember-templates/"/>
    <updated>2013-05-21T07:54:00-06:00</updated>
    <id>http://jaketrent.com/post/precompile-ember-templates</id>
    <content type="html"><![CDATA[<p><a href="http://emberjs.com">Ember</a> makes use of the wonderful <a href="http://handlebarsjs.com">Handlebars</a> templates.  These templates, in order to be performant, must be precompiled.  Based on the Ember docs, it's not abundantly clear how this is to happen.  Here's a solution that works well.</p>

<p><img src="http://i.imgur.com/x5HT4FN.jpg" alt="Ember and Handlebars" /></p>

<!--more-->


<h2>Ember Docs for Precompilation</h2>

<p>Every official Ember doc will put templates in a <code>script</code> tag with the <code>type="text/x-handlebars"</code>.  But this is never how you'd write any serious (-ly awesome) app in production.  <a href="http://emberjs.com/guides/templates/handlebars-basics/">The docs</a> say:</p>

<blockquote><p>"If you are using build tools to manage your application's assets, most will know how to precompile Handlebars templates and make them available to Ember.js."</p></blockquote>

<p>Which tools?  Why would I want to precompile?  How <em>are</em> they made available to Ember?  Read, Ember journeyman, read on...</p>

<h2>Grunt</h2>

<p>We'd love for this precompilation to happen previous to the running of your app.  Again, this is in hopes of increased performance.  <a href="http://gruntjs.com">Grunt</a> is a great little Nodejs-based tool for build-level tasks.</p>

<h2>Emblem</h2>

<p>Grunt comes with a variety of plugins.  We're going to use one called <a href="https://github.com/wordofchristian/grunt-emblem/">grunt-emblem</a>.  <a href="http://emblemjs.com/">Emblem</a> is a fantastic templating syntax layered on top of Handlebars (still a dependency).  Its syntax looks very similar to Haml or Ruby Slim or Jade.  It may well be the most flexible of all of them, and it simplifies some Ember helper syntax very nicely.</p>

<h2>Versions Matching</h2>

<p>As I've said before, <a href="/post/match-ember-handlebars-version/">matching Ember dependency version can be a pain</a>.  With precompilation, you have one more dependency to match.  Now not only do you care about the version of Handlebars that Ember uses at runtime, but you care about the version of Handlebars that is used to precompile your templates.  If the precompile Handlebars version doesn't match the runtime Handlebars version, your app will die at runtime.  <code>grunt-emblem</code> helps immensely with this.</p>

<h2>grunt-emblem</h2>

<p>I haven't found another Handlebars precompile plugin that helps as much as <code>grunt-emblem</code>.  It solves the precompile version problem by letting you utilize the actual runtime Handlebars as the precompile Handlebars script.</p>

<p>It is also nice in that it puts the precompiled templates into the collection that Ember expects to find templates in, namely <code>Ember.TEMPLATES</code>.  As you can find on the <a href="https://github.com/wordofchristian/grunt-emblem/"><code>grunt-emblem</code> Github page</a>, your grunt config will look something like the following:</p>

<p>```coffeescript
matchdep = require 'matchdep'</p>

<p>module.exports = (grunt) ->
  grunt.initConfig</p>

<pre><code>watch:
  ember_templates:
    files: ['app/views/templates/**/*.emblem']
    tasks: ['emblem', 'livereload']

emblem:
  compile:
    files:
      "app/static/templates/ember_templates.js": ["app/views/templates/**/*.emblem"]
    options:
      root: "app/views/templates/"
      dependencies:
        jquery: "app/static/js/components/jquery/jquery.js"
        ember: "app/static/js/components/ember/ember.js"
        emblem: "app/static/js/components/emblem/dist/emblem.js"
        handlebars: "app/static/js/components/handlebars/handlebars.js"
</code></pre>

<p>  matchdep.filterDev('grunt-*').forEach grunt.loadNpmTasks</p>

<p>  grunt.renameTask 'regarde', 'watch'</p>

<p>  grunt.registerTask 'dev', [ 'livereload-start', 'watch' ]</p>

<p>```</p>

<p>This particular config has a couple other niceties.  Let me enumerate the awesome:</p>

<ul>
<li>Line 6 - Not only can we precompile the templates, but we'll precompile on the fly, whenever <code>.emblem</code> files are change in the specified directories.</li>
<li>Line 8 and 14 - We're precompiling <code>.emblem</code> templates, but this plugin can do regular Handlebars syntax as well</li>
<li>Line 16 - <code>root</code> is the substring that will be stripped out of your template name.  For instance, you don't want your template to be called <code>app/views/templates/home</code>.  Your home route in Ember will want your template called <code>home</code>.  <code>root</code> to the rescue -- bam!</li>
<li>Line 17 - These <code>dependencies</code> are the libraries that you use at runtime and that Handlebars needs at compile time.  As I said, this plugin simply rocks because of the ability to specify your own Handlebars script.</li>
<li>Line 23 - Remember how you used to have a whole list of npm tasks registered.  This little beaut will load all <code>grunt-*</code> dependencies.</li>
<li>Line 25 - <code>regarde</code> is a cool name, but I understand what <code>watch</code> means a bit better. Rename it.</li>
</ul>


<p>This setup requires the following dependencies:</p>

<p><code>
npm install matchdep grunt grunt-regarde grunt-contrib-livereload grunt-emblem --save-dev
</code></p>

<p>So now, seriously, go write some Emblem templates.  So fun, so precompiled.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Match Ember and Handlebars Versions]]></title>
    <link href="http://jaketrent.com/post/match-ember-handlebars-version/"/>
    <updated>2013-05-21T07:38:00-06:00</updated>
    <id>http://jaketrent.com/post/match-ember-handlebars-version</id>
    <content type="html"><![CDATA[<p><a href="http://emberjs.com">Ember</a> is very specific about what version of <a href="http://handlebarsjs.com">Handlebars</a> it requires.  This is probably good, but it's also a pain to work with as different versions of the two libraries are released independently.  There are a few good tools to help us out.</p>

<p><img src="http://i.imgur.com/x5HT4FN.jpg" alt="Ember and Handlebars" /></p>

<!--more-->


<h2>Released Independently</h2>

<p>In a prime example, recently there was a new version of Handlebars released: <code>1.0.0-rc.4</code>.  Ember happens to be on version <code>1.0.0-rc.3</code>.  That version has a hard dependency on Handlebars <code>1.0.0-rc.3</code>.  In other words, the latest Ember code relies on an older version of Handlebars.</p>

<h2>Bower</h2>

<p>If you include these 3rd party libraries in your source code under a <code>lib</code> directory or something of that nature, you <em>always</em> have plenty of work to do.  Naturally, you just copy in the exact versions of the scripts that are needed.</p>

<p>Hopefully you're trying to make use of a mostly awesome tool, <a href="http://bower.io">Bower</a>.  It helps you manage these 3rd party libraries in a way similar to npm.  You provide a descriptor of your project's dependencies, <code>component.json</code>.  And you install things similarly via the <code>bower</code> cli.</p>

<h2>Specify a Bower Version</h2>

<p>If I run:</p>

<p><code>
bower install handlebars --save
</code></p>

<p>It saves a dependency in my <code>components.json</code> for Handlebars for the latest version it could find.  This won't do for us.  We need to specify the versions.</p>

<p>Our strategy will be: take the latest version of Ember and then specifically match the Handlbars version.  Finally, we should type:</p>

<p><code>
bower install ember --save
bower install handlebars#1.0.0-rc.3
</code></p>

<p>As of this writing, that is the version of handlebars that is required.  Bower will recognize any semver git tag name or branch name after the hash <code>#</code> sign.</p>

<p>I like our version strategy for a project that is under active development in that it keeps us on the latest Ember.  But, if you're on a project that's been built to an Ember version and not deployed for a long time, you may want to make a very specific dependency out of Ember as well, so the two are guaranteed in sync for future deploys.</p>
]]></content>
  </entry>
  
</feed>
