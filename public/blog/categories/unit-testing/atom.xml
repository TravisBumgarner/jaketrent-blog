<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unit-testing | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/unit-testing/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-01-21T11:25:05-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Set Cookie on Rack Mock Request]]></title>
    <link href="http://jaketrent.com/post/set-cookie-on-rack-mock-request/"/>
    <updated>2015-01-21T10:58:00-07:00</updated>
    <id>http://jaketrent.com/post/set-cookie-on-rack-mock-request</id>
    <content type="html"><![CDATA[<p>Rack apps are generally straightforward to test because of their very basic public interface.  But where do we put specific things, in this case, a cookie for the request, on that <code>env</code> argument it takes?  Here's one way.</p>

<p><img src="http://i.imgur.com/Z7WWtL0.jpg" alt="rack mock request" /></p>

<!--more-->


<h1>env</h1>

<p>The <code>env</code> argument that is sent to <code>#call</code> in a Rack app is an variable that represents the <a href="http://www.rubydoc.info/github/rack/rack/master/file/SPEC#The_Environment">environment of the request</a>.  It is a hash of CGI-like headers: request method, query params, http headers -- that sort of thing.</p>

<p>The <code>HTTP_*</code> keys on the hash will be <a href="https://tools.ietf.org/html/rfc3875#section-4.1.18">read as request headers from the environment</a>.</p>

<h1>Rack MockRequest Cookies</h1>

<p>Rack provides a great little <code>Rack::MockRequest</code> helper object in its library that will help us test our app.  This object has a class method called <code>env_for</code> which allows for quick construction of an <code>env</code> var that is a request to a specified url.</p>

<p>On the returned <code>env</code> we will continue to make modifications before passing it to our Rack app.  We'll add our cookie header with a key of <code>HTTP_COOKIE</code>.  The value will be of the format <code>cookieName=cookieValue</code>.  We can handle multiple cookies by separating the cookies with <code>;</code>.</p>

<p>Let's say we're testing a token authentication middleware with rspec.  Our spec may look something like this:</p>

<p><code>ruby
it "accepts an cookie token in the request" do
  middleware = # ... instantiate rack middleware
  env = Rack::MockRequest.env_for("/protected")
  env["HTTP_COOKIE"] = "AUTH_COOKIE=123"
  status, _, _ = middleware.call(env)
  expect(status).to eq(200)
end
</code></p>

<p>Then in our Rack app source, we can code for the availability of a cookie on the request.  It might look like:</p>

<p>```ruby</p>

<h1>...</h1>

<p>def call(env)
  request = Rack::Request.new(env)
  token = request.cookies["AUTH_TOKEN"]
  # ...
end
```</p>

<p>Is this the easiest or best way to set cookies on requests when testing Rack apps?  What do you do?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Destroy Duplicate Tests]]></title>
    <link href="http://jaketrent.com/post/destroy-duplicate-tests/"/>
    <updated>2014-11-05T16:59:00-07:00</updated>
    <id>http://jaketrent.com/post/destroy-duplicate-tests</id>
    <content type="html"><![CDATA[<p>As soon as we begin to write a test for our code, it is natural for us to think that we are doing a good thing, and often, we are.  Yet, I believe there are times that we’re writing tests when we’re hurting more than helping — and, of course, this is not on purpose.  To clarify, I’m an advocate for testing in general, and this is a short thought on how to make it better.</p>

<p><img src="http://i.imgur.com/ozzuTNQ.png" alt="Double tests are not fine" /></p>

<!--more-->


<p>As soon as we begin to write a test for our code, it is natural for us to think that we are doing a good thing, and often, we are.  Yet, I believe there are times that we’re writing tests when we’re hurting more than helping — and, of course, this is not on purpose.  To clarify, I’m an advocate for testing in general, and this is a short thought on how to make it better.</p>

<h2>Verify It, and Be Done</h2>

<p>One of the main goals of testing is to verify that what you have written is correct.  So, if we’ve met that goal, there’s no need to go around the track one more time and see the checkered flag again.  The second time around produces no extra glory and no extra benefit.</p>

<p>If we cover a section of code many times, it isn’t more helpful than the first time we covered it.  To verify twice isn’t to verify any better.  If the second attempt does happen to verify the same thing in an obviously better way, remove the first attempt and keep the second.</p>

<p>If it’s a variation of a certain case that you’re verifying, that’s different.  Adding new cases based on slight permutations of previous cases can be a good thing.  But covering the exact same thing provides no value.  In fact, multiple verification of code is just a type of debt.  It should be a smell in your test code that alerts you to clean things up.</p>

<h2>The Debt of Duplicate Tests</h2>

<p>If you have multiples of something, it just increases the maintenance over time.  Why would you want to update two tests instead of one?  Now that you have duplicate tests, you also have to keep them in sync.  Of course, if they cover the exact same case, if you change source code to fix the one test, the other will still be broken and be apparent and easy to fix.</p>

<p>The more tests you have, the longer your feedback loop in development or in a continuous build environment will be.  Multiply that extra wait time across your life on the project, and it has the possibility of being a non-trivial product.  Of course we need to wait for the tests that are needful and provide added value, but we shouldn’t wait needlessly.</p>

<p>Sometimes you do see duplicate tests within the same file — for instance, within the same unit.  This might happen when different developers approach the unit at different times to add tests.</p>

<p>I think it’s probably more often the case that duplicate tests are found across test classes -- meaning across the different types of tests.  For instance, a developer might write a unit test that covers a case.  Later, someone else might add an integration test that adds the same case.  Later still, someone else might add a functional test that adds the same case yet again.  All these developers are well-intentioned in adding tests.  They all need to think, communicate, investigate, and coordinate a little more to avoid the duplicate test problem.</p>

<h2>Deleting Duplicate Tests</h2>

<p>When duplicate tests are found, we should delete them.  Again, this might require some thinking.  We might want to consider which of the duplicate cases is the best test and therefore the one to keep.  This consideration might include which test is most stable, runs the fastest, is most readable, best designed, latest, earliest, etc.</p>

<h2>Avoiding Duplicate Tests</h2>

<p>The best scenario would be the one where we avoid duplicate tests.  Teams with clear guidelines will be able to coordinate better.  Useful information might include which classes of tests exist in the project and what each is intended for.  We might describe which kinds of tests we prefer, in which order, for certain kinds of verifications.  Having clean, well-organized tests will also encourage the team to read each others’ tests and familiarize themselves with what’s already written and know where to find existing cases and where to properly categorize new cases.</p>

<p>So have fun testing, and destroy the duplicate tests!  Yay for test doubles, but boo for double tests.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BusterJs with RequireJs/Backbone]]></title>
    <link href="http://jaketrent.com/post/busterjs-requirejsbackbone/"/>
    <updated>2012-07-25T14:42:00-06:00</updated>
    <id>http://jaketrent.com/post/busterjs-requirejsbackbone</id>
    <content type="html"><![CDATA[<p>BusterJs is a still-in-beta library that allows for testing your Javascript.  It's got a wealth of cool features.  The browser capturing is awesome for running your Javascript directly in the browsers you choose from one runner.  You can also execute within Node.  In short, it rocks.  But, how to get this rockin' with your project, specifically your AMD RequireJs with BackboneJs combo project is the lock that must be opened before daily buster love can be had.</p>

<!--more-->


<h2>Install</h2>

<p>Buster is easily installed everywhere (but apparently not in Windows, which I have not tried):</p>

<p>```bash</p>

<blockquote><p>sudo npm install -g buster
```</p></blockquote>

<p>The <a href="http://busterjs.org/docs/getting-started/">buster docs</a> indicate not to use sudo, but I'm reckless.</p>

<h2>Buster Config</h2>

<p>My directory structure looks something like:</p>

<p>```bash
proj/
  src/</p>

<pre><code>static/
  js/      # here are the objects under test
</code></pre>

<p>  test/</p>

<pre><code>tests/     # here are the tests
buster.js  # here is the buster config
</code></pre>

<p>```</p>

<p>My previous experience with setting up <a href="http://rockycode.com/blog/jasmine-unit-testing-requirejs/">Jasmine testing with RequireJs</a> was not entirely straightforward.  BusterJs was not totally straightforward either, but it felt better.  For one, it already has a runner.  I just need to give it some config (<code>buster.js</code>):</p>

<p>```js
var config = module.exports;
config['browser-all'] = {
  autoRun: false,
  environment: 'browser',
  rootPath: '../',
  libs: [</p>

<pre><code>'src/static/js/vendor/require-jquery-2.0.2.js',
'src/static/js/vendor/underscore-1.3.3.js',
'src/static/js/vendor/backbone-0.9.2.js'
</code></pre>

<p>  ],
  sources: [</p>

<pre><code>'src/static/js/**/*.js',
'src/static/js/**/*.handlebars'
</code></pre>

<p>  ],
  tests: ['test/tests/*.js'],
  extensions: [require('buster-amd')]
};
```</p>

<p>A few salient points related to RequireJs / Backbone:</p>

<ul>
<li><code>autoRun</code> - Turning this off allows you to <a href="http://busterjs.org/docs/starting-testrun-manually/">run buster tests manually</a>.  This is important from an AMD perspective, because the objects under test are loaded asynchronously.  Only once they're loaded do we want to kick off the tests.</li>
<li><code>libs</code> - Include the RequireJs, Underscore, and Backbone files here.  <code>libs</code> will put some script tags into the browser, so require will be ready once tests start executing.  They're loaded first and in order (Underscore before Backbone is important).</li>
<li><code>sources</code> - I was having problems with my <a href="http://handlebarsjs.com/">handlebars template</a> loader plugin until I realized that I need to list <em>all</em> sources, including templates, under this attribute.  And don't forget '**' for subfolders.</li>
<li><code>extentions</code> - <a href="https://github.com/busterjs/buster-amd">buster-amd</a> is a buster extension that helps with the AMD module loading.  This will also require a <code>npm install buster-amd</code>.  As the <a href="http://busterjs.org/docs/extensions/">buster-amd docs</a> point out, you still need to list your sources and tests normally so they're available to the buster runner, so don't leave these out thinking they'll be magically available.</li>
</ul>


<p>The <a href="http://busterjs.org/docs/configuration/">other configuration options/details</a> are well documented.</p>

<h2>BusterJs Test Example</h2>

<p>There are a few <a href="https://github.com/trodrigues/buster-amd-example/">simple examples</a> of other busterjs tests that test AMD modules.  Mine looks something like:</p>

<p>```js
buster.spec.expose();
require.config({
  baseUrl: 'src/static/js/',
  paths: {</p>

<pre><code>text: './vendor/text-2.0.0',
/* ... */
</code></pre>

<p>  }
});
```</p>

<pre><code>describe('single backbone dependency', function(run) {
  require(['Widget'], function(widget) {
    run(function() {
      it('should load', function() {
        expect(true).toEqual(true); // nothing but test execution
      });
    });
  });
});
</code></pre>

<p>More from the peanut gallery:</p>

<ul>
<li><code>buster.spec.expose()</code> just pushes main buster functions into the wide-open namespace to be called willy nilly.  Reckless -- again. :)</li>
<li><code>require.config</code> - it saddens me, but I have had to include this within each test file.  Others have <a href="https://groups.google.com/d/msg/busterjs/IZWItTzDT5I/AmX9wN-6oJoJ">commented</a> that they could include this once in the buster.config <code>libs</code>, but it didn't work for me.  I also tried 'testHelpers', without the help they advertise.  Please let me know if it does for you and what kind of pixie dust is required.</li>
<li><code>baseUrl</code> needs to jive with your buster rootPath so that your RequireJs relative paths will match up and work in your app runtime and in the test runtime.</li>
<li><code>run</code> - notice this is called within the require callback manually.</li>
</ul>


<h2>BusterJs Runner</h2>

<p>If you call within the next 15 minutes, the travel-size test runner is included.  Operators are standing by.  Start your test server:</p>

<p>```bash</p>

<blockquote><p>buster server
```</p></blockquote>

<p>That will start a server at localhost:1111.  Head 1+ of your local browsers to that address and capture them as your imprisoned slaves.  They will do your bidding when you run the tests.  Go to your project directory and run:</p>

<p>```bash</p>

<blockquote><p>buster test
```</p></blockquote>

<p>If you've tied it all together, you should see something like:</p>

<p>```bash</p>

<blockquote><p>buster test
Chrome 21.0.1180.49, OS X 10.7 (Lion): .....                                                                          <br/>
1 test cases, 1 tests, 1 assertions, 0 failures, 0 errors, 0 timeouts
Finished in 0.02s
```</p></blockquote>

<p>And now for a few parting tips...</p>

<h2>Mismatched Define Module</h2>

<p>If you happen to include a js file in your 'libs' attribute or another section that's loaded previous to your tests running that includes a <code>define()</code> block, you're going to get stuck with this wonder:</p>

<p><code>bash
Uncaught exception: ./src/static/js/vendor/require-jquery-2.0.2.js:1803 Uncaught Error: Mismatched anonymous define() module: function (module) {
</code></p>

<p>As the <a href="http://requirejs.org/docs/errors.html#mismatch">require docs</a> point out, to avoid this:</p>

<blockquote><p>Be sure to load all scripts that call define() via the RequireJS API.</p></blockquote>

<h2>RequireJs 2.0 shim</h2>

<p>I wasn't able to get the shim setup for getting underscore/backbone loaded and in the correct order.  Instead, I just listed these non-AMD files in the correct order under the 'libs' attribute in buster.config.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test-driven Development on MarkLogic]]></title>
    <link href="http://jaketrent.com/post/test-driven-development-marklogic/"/>
    <updated>2011-10-11T19:46:00-06:00</updated>
    <id>http://jaketrent.com/post/test-driven-development-marklogic</id>
    <content type="html"><![CDATA[<p>Unit testing is a required part of a healthy software development lifecycle and a balanced breakfast.  But test-driven development is a rockin' part of an <em>awesome</em> development lifecycle.  What's the difference?  If you don't test-drive the dev of your MarkLogic XQuery, you may never come back to test again.  Test-driven XQuery development will ease your headaches, put you into the plush seat of a developer with confidence, and rocket you down the road to making all your wildest dreams come true.  Kachow!</p>

<!--more-->


<p>Ok, it may be slightly <em>more</em> magical than that.  But, I don't want to get your hopes up.  Seriously, though, if TDD is fun in, say Java Land (and it still is in MarkLogic land with "the Swede"), then it's a required portion of fun in MarkLogic Land?  Why?  While you might imagine yourself going back and adding tests to your Java project and sometimes you do, if you imagine it and then attempt it in your XQuery project, I believe the likelihood that you shrivel in shame and tears under your desk is much higher than in some other environments.</p>

<p>I the difficulty of the test after development approach is higher in MarkLogic XQuery because of what I've called "camouflaged dependencies" -- essentially, access to the http request and respond and to the database.</p>

<p>You can get access to request fields or headers or anything else dealing with the web context in which the code is executed at any place in your code.  This doesn't mean you have to code like this, but the language doesn't necessarily help you enforce your discipline.  This is where testing before you write the code will help.  Make you functions functional -- pass in parameters and make them the only data access.</p>

<p>You can read the database natively in MarkLogic XQuery.  That means that you can be retrieving data anywhere in your code.  There is an extreme lack of ceremony in making a connection to the database -- it's always there;  they're connected.  This is both refreshing and a shiny nail strip upon which to puncture the tires of your test-driven sports coupe e're you drive it off the lot.  Resist the temptation to read from the database or write to the database save in very determined and specific parts of your app -- parts that you will not actually unit test [gasp] because they'll be doing nothing but saving xmls at given database uris, and MarkLogic already has internal testing for that.</p>

<p>So, respect what you might call your dependencies -- the network and the database -- and be thrilled with the adventure of testing the business logic that you write yourself and need to verify.  And test it first to help keep you on the strait and narrow.  Otherwise, you're "discipline" will crumble under deadlines and in the end it will "just work" -- until it doesn't -- and you won't know why.</p>

<p>Note:
Below are the slides to support a presentation given at an in-house development conference.  It is an evolution of a talk previously given on <a href="">unit testing XQuery on MarkLogic</a> with streamlined principles and skills section and a not-included coding portion surrounding the use of XqTest, our XQuery unit test framework, and its integration in our environment.  Tonight, as I say my prayers, I will continue to hope that someday XqTest will be released from its prison and "the Swede" will see the light of day!</p>

<div style="width:425px" id="__ss_9651897"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/rockycode/testdriven-development-on-marklogic" title="Test-driven Development on MarkLogic" target="_blank">Test-driven Development on MarkLogic</a></strong> <iframe src="http://www.slideshare.net/slideshow/embed_code/9651897" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/rockycode" target="_blank">rockycode</a> </div> </div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unit Testing XQuery on MarkLogic]]></title>
    <link href="http://jaketrent.com/post/unit-testing-xquery-marklogic/"/>
    <updated>2011-04-29T08:50:00-06:00</updated>
    <id>http://jaketrent.com/post/unit-testing-xquery-marklogic</id>
    <content type="html"><![CDATA[<p>Unit testing is a required part of a healthy software development lifecycle.  Business logic in MarkLogic Xquery needs the same insurance of superb testing as any other language.</p>

<p>Principles: Come learn the motivation for unit testing and how test-driven development can increase your productivity writing solid Xquery code in an Agile-coding environment.</p>

<p>Skills: We'll code Xquery examples to learn general skills including the TDD workflow, how to isolate your code for unit testability, and how to test one thing at a time.  In each case, we'll address how to apply these skills specifically to development in the MarkLogic environment.</p>

<p>Tools: We'll also introduce you to in-house-developed tooling for creating unit tests and running them.  This tooling provides an all-Xquery method of creating test functions, annotating them as such so they're runnable in the test runner, isolating certain modules to test, and viewing clear test results.</p>

<p>With a few principles, skills, and tools for unit testing, you can go forward with increased confidence that the Xquery code you write on MarkLogic is more awesome than ever.</p>

<!--more-->


<p>This slide deck is from a presentation at the MarkLogic Users Conference 2011.</p>

<div style="width:510px" id="__ss_7778485"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/rockycode/unit-testing-xquery-on-marklogic" title="Unit Testing XQuery on MarkLogic">Unit Testing XQuery on MarkLogic</a></strong> <iframe src="http://www.slideshare.net/slideshow/embed_code/7778485" width="510" height="426" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/">presentations</a> from <a href="http://www.slideshare.net/rockycode">rockycode</a> </div> </div>


<p>More prose to follow and support these slides soon.</p>
]]></content>
  </entry>
  
</feed>
