<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: reflection | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/reflection/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-05-20T09:33:33-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Expose Fields via Java Reflection]]></title>
    <link href="http://jaketrent.com/post/expose-fields-java-reflection/"/>
    <updated>2009-06-08T13:29:00-06:00</updated>
    <id>http://jaketrent.com/post/expose-fields-java-reflection</id>
    <content type="html"><![CDATA[<p>For unit testing purposes, I often want to set field values in objects so that I can setup for the test conditions.  One of most annoying things about testing is the urge to change code design for just the sake of testing -- especially if it's in a way that is considered less safe, like exposing elements or lessening accessibility.  (This is not to say that trying to test code can reveal certain code smells and prompt refactoring).  I, myself, have a number of setter methods with this comment prepended: "// for test only comments".  Stinkers!  Well, sometimes enough becomes enough.  So, here's a way to set any field on an object w/o exposing it.  This is done via reflection.</p>

<!--more-->


<p>```java
import java.lang.reflect.Field;</p>

<p>/<em>*
 * @author: jtsnake
 * @date: Jun 3, 2009
 </em>/
public class ReflectionUtil {</p>

<p>  /<em>*
   * Gets the value of the field on the given object
   * @param obj the object with the field being examined
   * @param name the name of the field in the object
   * @param &lt; T > will return the field type w/o static casting
   * @return the field value
   * @throws NoSuchFieldException thrown if can't find field
   * @throws IllegalAccessException thrown if the field isn't accessible (shouldn't be a problem w/ setAccessible(true))
   </em>/
  public static &lt; T > T getFieldValue(Object obj, String name) throws NoSuchFieldException, IllegalAccessException {</p>

<pre><code>  Field field = findField(obj.getClass(), name);
  field.setAccessible(true);
  return (T) field.get(obj);
</code></pre>

<p>  }</p>

<p>  /<em>*
   * Set the value of the field on a given object
   * @param obj the object with the field to set value on
   * @param name name of the field in the object
   * @param value the value to set on the field
   * @throws NoSuchFieldException thrown if can't find the field
   * @throws IllegalAccessException thrown if the field isn't accessible (shouldn't be a problem w/ setAccessible(true))
   </em>/
  public static void setFieldValue(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException {</p>

<pre><code>  Field field = findField(obj.getClass(), name);
  field.setAccessible(true);
  field.set(obj, value);
</code></pre>

<p>  }</p>

<p>  /<em>*
   * Helper method to find the field in the class
   * @param clzz class type of the object
   * @param name name of the field
   * @return the java.lang.reflect.Field
   * @throws NoSuchFieldException thrown if method recurses to java.lang.Object w/o finding the field by the given name
   </em>/
  static Field findField(Class clzz, String name) throws NoSuchFieldException {</p>

<pre><code>  Field field = null;
  try {
      field = clzz.getDeclaredField(name);
  } catch (NoSuchFieldException e) {
      if (clzz.getSuperclass() != null) {
          field = ReflectionUtil.findField(clzz.getSuperclass(), name);
      } else {
          throw e;
      }
  }
  return field;
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Reflection for methods with primitive params]]></title>
    <link href="http://jaketrent.com/post/java-reflection-methods-primitive-params/"/>
    <updated>2009-04-14T08:35:00-06:00</updated>
    <id>http://jaketrent.com/post/java-reflection-methods-primitive-params</id>
    <content type="html"><![CDATA[<p>First-class objects are the norm in the code that I usually write and edit, but every now and then I run across a method with a primitive parameter.  I use EasyMock a lot in testing, and need to find these methods by reflection, this is how it's done...</p>

<!--more-->


<p>This code:</p>

<p>```java
@Test(groups = {"unit"})
public void testJunk() throws NoSuchMethodException {
  Method m = MyBean.class.getDeclaredMethod("test", Boolean.TYPE, Integer.TYPE, Integer.class);
  MyBean bean = createMock(MyBean.class, m);</p>

<p>}
```</p>

<p>will be able to find the method here:</p>

<p><code>java
void test(boolean junk, int prim, Integer cl) {
  System.out.println("blast");
}
</code></p>

<p>Notice, that object params use: Integer.class</p>

<p>Primitive params use: Integer.TYPE</p>

<p>The one other thing that bugs me with this reflection bit is the string representation of the test() method name.  So, when the test() method name changes to test2(), the unit test will break.  Blast!  Hence, the standard out message.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Java Reflection to Get Field w/ Accessor]]></title>
    <link href="http://jaketrent.com/post/use-java-reflection-get-field-w-accessor/"/>
    <updated>2009-02-20T12:36:00-07:00</updated>
    <id>http://jaketrent.com/post/use-java-reflection-get-field-w-accessor</id>
    <content type="html"><![CDATA[<p>Java is about objects.  Reflection is about knowing things about those objects generally without have specific fields and methods in hand.  I must get to one of those field values via its accessor, allowing me to keep the fields private and abstracted away... of course, until I start unit testing.  Here's one method...</p>

<!--more-->


<p>In our application, we use a jsf converter that converts the string representation of the a jpa-managed object into the object proper.</p>

<p>The required format of this string is thus:</p>

<p><code>
fully.qualified.class.name:primarykey
</code></p>

<p>I don't want to override the toString() method because we use it for other things.  And, I don't want to have to create some method to return this formatted string to me in <strong>every</strong> class that I might want to call this on.  So, I created a util method to do this for me.</p>

<p>```java
public static String getEntityConverterString(Object o) {
   String retval = null;
   if (o != null) {</p>

<pre><code>  String id = null;
  for (Field f : o.getClass().getDeclaredFields()) {
  if (f.isAnnotationPresent(Id.class)) {
     String getterName = "get" + StringUtils.capitalize(f.getName());
     for (Method m : o.getClass().getDeclaredMethods()) {
     if (m.getName().equals(getterName)) {
        try {
        Object idObj = m.invoke(o, null);
        if (idObj != null) {
           id = idObj.toString();
           break;
        }
        } catch (IllegalAccessException e) {
        throw new RuntimeException("Cannot find appropriate accessor for @Id field ");
        } catch (InvocationTargetException e) {
        throw new RuntimeException("Exception thrown w/in accessor");
        }
     }
     }
     break;
  }
  }
  retval = o.toString().split("@")[0] + ":" + id;
</code></pre>

<p>   }
   return retval;
}
```</p>

<p>The only stipulation to this working is that the class follows the JavaBean naming convention standard of "get" + capitalized field name following.  Oh, and one more: this is only designed for @Entity's with one @Id field (no composite key).</p>

<p>This method goes through all fields, finds the one with the javax.persistence.Id interface annotation, then tries to find a matching accessor method.  If it is found, it is executed, the value of the id field is given, finally to be used to create the specially formatted string.</p>
]]></content>
  </entry>
  
</feed>
