<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: express | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/express/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-12-15T09:53:49-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Handle Errors in a Node App]]></title>
    <link href="http://jaketrent.com/post/handle-errors-node-app/"/>
    <updated>2016-08-23T16:34:00-06:00</updated>
    <id>http://jaketrent.com/post/handle-errors-node-app</id>
    <content type="html"><![CDATA[<p>As with any software, here you can expect the unexpected.  Node apps experience errors as well.  Let's say that an error crops in our Node API -- what should we do about it?</p>

<p><img src="http://i.imgur.com/1arT8Ho.jpg" alt="nodejs" /></p>

<!--more-->


<p>Errors can be handled in a lot of different ways.  "Handling" in this article will essentially mean error response messaging.</p>

<h4>Specific Messages are Best</h4>

<p>When handling errors, we should do so as specifically and quickly as possible.  As an example, if we can respond to a request that causes an error with a more specific error message, this would be better than responding with a generic, catch-all message.  This first message:</p>

<p><code>
{ errors: [{ title: 'Title field missing', source: '/data/attributes/title' }] }
</code></p>

<p>is better than this:</p>

<p><code>
{ errors: [{ title: 'Bad request' }] }
</code></p>

<p>But <em>some</em> error messaging is better than nothing.</p>

<p>So, starting with the most specific handling cases and going to the most generic.</p>

<h2>Handle Specific Business Errors</h2>

<p>Let's say that we have an endpoint that creates a new book in our books database, requested at <code>POST /books</code>.  It validates the request body data shape to ensure sufficient and correct data is entered for new books.  Let's say that a user submits a new book without the required title field.  It would be great to have specific response that tells the client what exactly is wrong.  The controller code, in part, might look like this in <a href="https://expressjs.com/">Express</a>:</p>

<p>```js
router.post('/books', (req, res, next) => {
  const errors = validate(req.body.data)
  if (errors) {</p>

<pre><code>saveBook(req.body.data, (_, newBook) =&gt; {
  res.status(201).json({ data: newBook })
})
</code></pre>

<p>  } else {</p>

<pre><code>res.status(400).json({ errors })
</code></pre>

<p>  }
})
```</p>

<p>That last line is the error response with specific error messages.  These messages are presumeably generated by the <code>validate</code> function.  We can provide a specific <code>bad request</code> response status code with a <code>400</code>.  We can provide the specific error response body, which would look like:</p>

<p><code>
{ errors: [{ title: 'Title field missing', source: '/data/attributes/title' }] }
</code></p>

<h2>Catch All Other Errors*</h2>

<p>Now there are other errors that might occur that we either haven't, don't want, or will never be able to anticipate enough to provide specific handling for.  In these cases, we still want to handle the error, but we'll only be able to provide minimal value and insight into the nature of the error to clients in the responses.</p>

<p>Let's adjust our controller code to handle potentially errors that might happen in the book saving process.  What could happen?  Anything... like database issues with connections, constraints, locks or just something bad in our code.  In our callback, let's do something with that potential error:</p>

<p>```js
router.post('/books', (req, res, next) => {
  const errors = validate(req.body)
  if (errors) {</p>

<pre><code>saveBook(req.body, (err, newBook) =&gt; {
  if err return next(err) // new line

  res.status(201).json({ data: newBook })
})
</code></pre>

<p>  } else {</p>

<pre><code>res.status(400).json({ errors })
</code></pre>

<p>  }
})
```</p>

<h4>Required Error Contract</h4>

<p>The <code>err</code> that comes back should be an <code>Error</code> or a subtype that at least follows the error contract and has the 3 required fields of <code>name</code> to identify the type of error, <code>message</code> for the human readable main issue of the error, and <code>stack</code> a string of the accurate location and stack trace of the error.</p>

<h4>Express' <code>next</code> for Errors</h4>

<p>The <code>next</code> function in <a href="https://expressjs.com/">Express</a> will advance to the next middleware.  In the case of passing a non-null value to <code>next</code>, remaining normal middleware will be skipped and the first error middleware will be executed.  Error middleware functions have an arity of 4 parameters instead of the usual 3, where <code>err</code> is the first parameter.  Here's a basic catch-all error handler:</p>

<p><code>js
app.use((err, req, res, next) =&gt; {
  res.status(500).json(serializeError(err))
})
</code></p>

<p><code>serializeError</code> is just going to take that and transform it into something to push across the network in the response.</p>

<p><code>
function serializeError(err) {
  return { errors: [{ status: 500, title: err.message, stack: err.stack }] }
}
</code></p>

<h4>Don't Leak Stacktraces</h4>

<p>Let's add a little something else here.  We probably don't want to leak the stack trace to our users in production, so let's protect it by detecting <code>NODE_ENV</code> and update it to be something like:</p>

<p>```
function serializeError(err) {
  const body = { status: 500, title: err.message }
  if (process.env.NODE_ENV !== 'production')</p>

<pre><code>body.stack = err.stack
</code></pre>

<p>  return { errors: [payload] }
}
```</p>

<p>Even better.  Generic errors handled.</p>

<h2>Crash On the Rest</h2>

<p>Now note the asterisk on the previous section.  We aren't actually able to catch <em>all</em> errors in that generic "catch-all" error handler.  To illustrate, let's create two new routes.  The first is a route that does nothing but throw a new <code>Error</code>:</p>

<p><code>js
router.get('/debug/error', (req, res, next) =&gt; {
  throw new Error('Test explosion')
})
</code></p>

<p>The above route, if requested at <code>GET /debug/error</code>, would throw a new Error and it would be caught by the generic error handler of the previous section.  This is because <code>throw</code> delivers that new <code>Error</code> synchronously.  It stays in the context of the current call stack of the request through Express middleware.  And Express can catch the <code>Error</code> and call your first error-handling middleware.</p>

<h4>Out-of-Context Errors</h4>

<p>But we can easily break out of this context and bypass the catch-all handler entirely.  All we have to do is use a <code>setTimeout</code>.  Calling <code>setTimeout</code> will queue a new message for the event loop to, at some later tick of the clock, run the enclosed function.  Within that function, we'll throw another <code>Error</code>:</p>

<p>```js
router.get('/debug/crash', (req, res, next) => {
  setTimeout(_ => {</p>

<pre><code>throw new Error('Error outside request context')
</code></pre>

<p>  }, 1000)
})
```</p>

<h4>Let the Process Die</h4>

<p>And now there's really nothing that Express can do to help us.  The <code>Error</code> will instead bubble up to the Node process running our app.  That process gives us one final opportunity to know about the occurrence of such a fatal error.  Once we know about it, we can log it.  Perhaps we can get off a call to our monitoring service.  After that, we should assume our process is compromised, potentially unstable, and just crash.  Then use a tool like <a href="https://github.com/foreverjs/forever">forever</a> to detect the downed process and restart it.  Such a crash handler might look like:</p>

<p>```js
  process.on('uncaughtException', err => {</p>

<pre><code>log.fatal({ err }, 'uncaught exception')

process.nextTick(_ =&gt; process.exit(1))
</code></pre>

<p>  })
```</p>

<p>The call to <code>process.nextTick</code> is meant to give some leeway for just enough processing time to finish those last ditch logging/monitoring efforts.</p>

<p>Now we have caught all the errors, in hopefully the best and most helpful way possible.</p>

<p>What other things have you done in your app to make Node error handling better?</p>

<h5>Great Resources</h5>

<ul>
<li><a href="https://www.joyent.com/node-js/production/design/errors">Joyent Production Practices</a> for all-around design practices</li>
<li><a href="https://expressjs.com/en/guide/error-handling.html">Express Error Handling</a> for framework-specific understanding</li>
<li><a href="http://jsonapi.org/format/#error-objects">JSON-API Error Objects</a> for sensible info to include in an error response</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">MDN Event Loop</a> for basics on the message queue in the event loop</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Https Redirect for Node on Heroku]]></title>
    <link href="http://jaketrent.com/post/https-redirect-node-heroku/"/>
    <updated>2013-02-26T07:33:00-07:00</updated>
    <id>http://jaketrent.com/post/https-redirect-node-heroku</id>
    <content type="html"><![CDATA[<p>When your app requires users to be using the <code>https</code> protocol to make requests and get responses, it's helpful to have an automatic redirect so the user is always in the right place.  Here's how to do that for a Node Express app on Heroku.</p>

<p><img src="http://i.imgur.com/5rZ8H.png" alt="NodeJs Https Redirect" /></p>

<!--more-->


<h2>Secure Express Requests</h2>

<p>The <a href="http://expressjs.com">Express</a> request object has a bunch of great information.  One of its attributes is <code>secure</code>.  It's a boolean.  Usually, <code>secure == true</code> will mean that you're on <code>https</code>.  When that is not true, you're ready for a redirect.</p>

<p>Unfortunately for apps hosted on Heroku, <code>request.secure</code> will always be false.  The way that Heroku routing works, it will just never be set.</p>

<h2>Heroku Https Header</h2>

<p>Instead, Heroku forwards an http header that allows us to do the same "is secure" test.  On Heroku, <code>request.header('x-forwarded-proto')</code> will contain the actual protocol string (eg, 'http' or 'https').</p>

<h2>Express Middleware SSL Redirect</h2>

<p>If you're using the Express framework on Node, then you have it easy.  There's already a great middleware mechanism for you to send any or all requests through.  If you set your Express app (v3) up like this:</p>

<p><code>coffeescript
app = express()
</code></p>

<p>Then you can use the <code>app.use</code> functionality to specify a middleware.  Since I only have certificates and want the redirect to happen in the production environment, I will likewise wrap this middleware inside <code>app.configure</code> for prod (it inspects <code>NODE_ENV</code> for you).  This redirect will be pretty rudimentary, but it's just that simple, so here it goes:</p>

<p>```coffeescript
app.configure 'production', ->
  app.use forceSsl(req, res, next) -></p>

<pre><code>if req.header 'x-forwarded-proto' != 'https'
  res.redirect "https://#{req.header 'host'}#{req.url}"
else
  next()
</code></pre>

<p>```</p>

<p>If it's not <code>https</code> already, redirect the same url on <code>https</code>.  If it is, that's what I want, and you can pass on through my middleware function.  Note that this middleware will protect <em>all</em> urls on the site with an <code>https</code> redirect.  Your middleware could be more selective.  You could even create this as a stacked middleware per route if you wanted.  We could even enhance our middleware to use inspect both the http header <em>and</em> the <code>secure</code> flag.</p>

<p>Heroku threw us a for a minor, unexpected loop, but it was nothing that we couldn't easily code for.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Organize NodeJs Routes]]></title>
    <link href="http://jaketrent.com/post/how-to-organize-nodejs-routes/"/>
    <updated>2012-10-02T16:52:00-06:00</updated>
    <id>http://jaketrent.com/post/how-to-organize-nodejs-routes</id>
    <content type="html"><![CDATA[<p>A few routes in a NodeJs app -- no problem.  Just put them in your <code>app.js</code>.  More than a handful?  You'll probably want to look at organizing your routes a different way.  This will help keep your core <code>app.js</code> clean and make your actual routes easier to find.</p>

<p><img src="http://i.imgur.com/basH6.jpg" alt="Too many routes" />
http://flic.kr/p/bihZUV</p>

<!--more-->


<h2>Express Routes</h2>

<p>The favorite http framework on <a href="http://nodejs.org/">NodeJs</a> seems to be <a href="http://expressjs.com/">Express</a>.  I personally like it quite a bit.  It's simple, declarative, and allows you to set up all the normal HTTP commands with ease.</p>

<p>Did you know that Express comes with a binary/cli command called <code>express</code>.  This command will setup a project structure and a lot of the boilerplate code for you.  The docs contain a guide on <a href="http://expressjs.com/guide.html#executable">how to run this</a>.  It has support for other cool options like session support or various css preprocessors.</p>

<p>A sample run and the file structure that it will create looks something like this:</p>

<pre><code>$ express --sessions --css stylus --ejs myapp

create : myapp
create : myapp/package.json
create : myapp/app.js
create : myapp/public
create : myapp/public/javascripts
create : myapp/public/images
create : myapp/public/stylesheets
create : myapp/public/stylesheets/style.styl
create : myapp/routes
create : myapp/routes/index.js
create : myapp/views
create : myapp/views/index.ejs
</code></pre>

<p>In that generated code, your <code>app.js</code> references a route like this:</p>

<p>{% codeblock lang:js %}
var routes = require('./routes');
app.get('/', routes.index);
{% endcodeblock %}</p>

<p>And the route, <code>index.js</code>, looks like:</p>

<p>{% codeblock lang:js %}
exports.index = function(req, res){
  res.render('index', { title: 'Express' });
};
{% endcodeblock %}</p>

<p>I like this, but it's still not the best.  I don't like having to list the <code>app.get()</code>, etc. in <code>app.js</code>.  This list will get long.  So, how would I adjust?</p>

<h2>All http commands in separate files</h2>

<p>Instead, I want to tell <code>app.js</code> about my routes, but I want each route file to hook itself up to express directly.</p>

<p>Showing the adjustments, <code>app.js</code>:</p>

<p>{% codeblock lang:js %}
var app = express();
var indexRt = require('./routes/index')(app);
{% endcodeblock %}</p>

<p>This time, more goodies in <code>index.js</code>:</p>

<p>{% codeblock lang:js %}
module.exports = function (app) {
  app.get('/', function (req, res) {</p>

<pre><code>res.render('index');
</code></pre>

<p>  });
}
{% endcodeblock %}</p>

<p>The difference is somewhat slight.  Now, instead of each http command listed in your app, only each resource (in REST terms) is listed in app.  Each command for a resource is listed in that resource's route.js.</p>

<p>There are surely many ways to organize your NodeJs routes.  Express gives a great starting pattern.  Our adjustment adds a slight optimization.  Organizing your routes will help your main <code>app.js</code> file stay way cleaner, and you'll be able to find your routes more easily.</p>

<p>But this surely can't be the best way for everyone.  What are the ways that you've found successful in organizing your routes?</p>

<p>Note: this post uses express 3 syntax.</p>
]]></content>
  </entry>
  
</feed>
