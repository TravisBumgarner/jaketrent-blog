<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: grunt | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/grunt/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-02-09T16:12:29-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Grunt-init Exercism.io]]></title>
    <link href="http://jaketrent.com/post/grunt-init-exercism-io/"/>
    <updated>2014-01-03T07:07:00-07:00</updated>
    <id>http://jaketrent.com/post/grunt-init-exercism-io</id>
    <content type="html"><![CDATA[<p><a href="http://exercism.io">Exercism.io</a> has a great set of JavaScript exercises.  They could be made better by a better test setup and runner.  I've created a small grunt-init template to help in that setup.</p>

<p><img src="http://i.imgur.com/4773D.jpg" alt="Grunt and Exercism" /></p>

<!--more-->


<h2>Exercism.io</h2>

<p>For those unfamiliar, <a href="http://exercism.io">Excercism.io</a> is a great tool that helps coders and potential coders learn and expand their knowledge in several programming languages.  Currently, among the 9 language choices, JavaScript is one.  The JavaScript exercises come with a pre-built <a href="https://github.com/mhevery/jasmine-node">jasmine_node</a> test suite.  The point of the exercise is to write code that will make all the corresponding tests pass.  For more on Excercism.io, see my <a href="/post/exercism-review/">review</a>.</p>

<h2>Vanilla jasmine_node</h2>

<p>As the <a href="http://exercism.io/help/setup/javascript">Exercism JavaScript docs</a> indicate, you can setup your JavaScript environment like this:</p>

<p><code>bash
npm install -g jasmine_node
</code></p>

<p>And then run your tests like this:</p>

<p><code>bash
jasmine_node bob_test.spec.js
</code></p>

<p>This does work perfectly well.  But, we want something more.  Of course.</p>

<h2>Grunt watch</h2>

<p>We want the test suite to re-run as soon as we make a change and save either our test file or our file under test.  Well, it turns out that <a href="http://gruntjs.com">Grunt</a> is a great little command-line tool that has plugins for file watching.</p>

<p>Grunt needs to be told to use a plugin.  Then it needs to be told that we want to run the task that watches our files.  All of this is indicated to Grunt via a local <code>Gruntfile.js</code> or <code>Gruntfile.coffee</code> file.  You could create this file by yourself, but wouldn't it be nice if there was a <code>Gruntfile.js</code> created somewhere for you already that worked well with Exercism?</p>

<h2>Grunt-init</h2>

<p>It turns out that there is a great, separate utility called <a href="http://gruntjs.com/project-scaffolding">grunt-init</a> that you can use to create your <code>Gruntfile.js</code> (and many other things) with a pre-built template.</p>

<p>To install this tool, run:</p>

<p><code>bash
npm install -g grunt-init
</code></p>

<p>To use a grunt-init template, you need to have a local copy.  This template copy could live anywhere, but grunt-init can reference these templates purely by name if you put them in <code>~/.grunt-init/</code>.</p>

<p>To get the <a href="https://github.com/jaketrent/grunt-init-exercism">Exercism grunt-init template</a>, clone it like so:</p>

<p><code>bash
git clone git@github.com:jaketrent/grunt-init-exercism.git ~/.grunt-init/exercism
</code></p>

<p>Then change into your specific Exercism directory, init your <code>Gruntfile.js</code>, and follow the other commands:</p>

<p><code>bash
cd ~/dev/exercism/javascript/bob
grunt-init exercism
npm init
npm install
</code></p>

<p>The <code>npm init</code> will flush out the rest of the generated <code>package.json</code>.  The <code>npm install</code> will install all dependencies that we said Grunt needed to do its job.</p>

<p>Finally, activate Grunt to watch your files with:</p>

<p><code>bash
grunt watch
</code></p>

<p>Now as you write your Exercism code to fulfill tests, you will see the tests get run automatically and become greenlit as your code increases in awesomeness.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Precompile Ember Templates]]></title>
    <link href="http://jaketrent.com/post/precompile-ember-templates/"/>
    <updated>2013-05-21T07:54:00-06:00</updated>
    <id>http://jaketrent.com/post/precompile-ember-templates</id>
    <content type="html"><![CDATA[<p><a href="http://emberjs.com">Ember</a> makes use of the wonderful <a href="http://handlebarsjs.com">Handlebars</a> templates.  These templates, in order to be performant, must be precompiled.  Based on the Ember docs, it's not abundantly clear how this is to happen.  Here's a solution that works well.</p>

<p><img src="http://i.imgur.com/x5HT4FN.jpg" alt="Ember and Handlebars" /></p>

<!--more-->


<h2>Ember Docs for Precompilation</h2>

<p>Every official Ember doc will put templates in a <code>script</code> tag with the <code>type="text/x-handlebars"</code>.  But this is never how you'd write any serious (-ly awesome) app in production.  <a href="http://emberjs.com/guides/templates/handlebars-basics/">The docs</a> say:</p>

<blockquote><p>"If you are using build tools to manage your application's assets, most will know how to precompile Handlebars templates and make them available to Ember.js."</p></blockquote>

<p>Which tools?  Why would I want to precompile?  How <em>are</em> they made available to Ember?  Read, Ember journeyman, read on...</p>

<h2>Grunt</h2>

<p>We'd love for this precompilation to happen previous to the running of your app.  Again, this is in hopes of increased performance.  <a href="http://gruntjs.com">Grunt</a> is a great little Nodejs-based tool for build-level tasks.</p>

<h2>Emblem</h2>

<p>Grunt comes with a variety of plugins.  We're going to use one called <a href="https://github.com/wordofchristian/grunt-emblem/">grunt-emblem</a>.  <a href="http://emblemjs.com/">Emblem</a> is a fantastic templating syntax layered on top of Handlebars (still a dependency).  Its syntax looks very similar to Haml or Ruby Slim or Jade.  It may well be the most flexible of all of them, and it simplifies some Ember helper syntax very nicely.</p>

<h2>Versions Matching</h2>

<p>As I've said before, <a href="/post/match-ember-handlebars-version/">matching Ember dependency version can be a pain</a>.  With precompilation, you have one more dependency to match.  Now not only do you care about the version of Handlebars that Ember uses at runtime, but you care about the version of Handlebars that is used to precompile your templates.  If the precompile Handlebars version doesn't match the runtime Handlebars version, your app will die at runtime.  <code>grunt-emblem</code> helps immensely with this.</p>

<h2>grunt-emblem</h2>

<p>I haven't found another Handlebars precompile plugin that helps as much as <code>grunt-emblem</code>.  It solves the precompile version problem by letting you utilize the actual runtime Handlebars as the precompile Handlebars script.</p>

<p>It is also nice in that it puts the precompiled templates into the collection that Ember expects to find templates in, namely <code>Ember.TEMPLATES</code>.  As you can find on the <a href="https://github.com/wordofchristian/grunt-emblem/"><code>grunt-emblem</code> Github page</a>, your grunt config will look something like the following:</p>

<p>```coffeescript
matchdep = require 'matchdep'</p>

<p>module.exports = (grunt) ->
  grunt.initConfig</p>

<pre><code>watch:
  ember_templates:
    files: ['app/views/templates/**/*.emblem']
    tasks: ['emblem', 'livereload']

emblem:
  compile:
    files:
      "app/static/templates/ember_templates.js": ["app/views/templates/**/*.emblem"]
    options:
      root: "app/views/templates/"
      dependencies:
        jquery: "app/static/js/components/jquery/jquery.js"
        ember: "app/static/js/components/ember/ember.js"
        emblem: "app/static/js/components/emblem/dist/emblem.js"
        handlebars: "app/static/js/components/handlebars/handlebars.js"
</code></pre>

<p>  matchdep.filterDev('grunt-*').forEach grunt.loadNpmTasks</p>

<p>  grunt.renameTask 'regarde', 'watch'</p>

<p>  grunt.registerTask 'dev', [ 'livereload-start', 'watch' ]</p>

<p>```</p>

<p>This particular config has a couple other niceties.  Let me enumerate the awesome:</p>

<ul>
<li>Line 6 - Not only can we precompile the templates, but we'll precompile on the fly, whenever <code>.emblem</code> files are change in the specified directories.</li>
<li>Line 8 and 14 - We're precompiling <code>.emblem</code> templates, but this plugin can do regular Handlebars syntax as well</li>
<li>Line 16 - <code>root</code> is the substring that will be stripped out of your template name.  For instance, you don't want your template to be called <code>app/views/templates/home</code>.  Your home route in Ember will want your template called <code>home</code>.  <code>root</code> to the rescue -- bam!</li>
<li>Line 17 - These <code>dependencies</code> are the libraries that you use at runtime and that Handlebars needs at compile time.  As I said, this plugin simply rocks because of the ability to specify your own Handlebars script.</li>
<li>Line 23 - Remember how you used to have a whole list of npm tasks registered.  This little beaut will load all <code>grunt-*</code> dependencies.</li>
<li>Line 25 - <code>regarde</code> is a cool name, but I understand what <code>watch</code> means a bit better. Rename it.</li>
</ul>


<p>This setup requires the following dependencies:</p>

<p><code>
npm install matchdep grunt grunt-regarde grunt-contrib-livereload grunt-emblem --save-dev
</code></p>

<p>So now, seriously, go write some Emblem templates.  So fun, so precompiled.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LiveReload for NodeJs]]></title>
    <link href="http://jaketrent.com/post/livereload-for-nodejs/"/>
    <updated>2013-04-23T16:44:00-06:00</updated>
    <id>http://jaketrent.com/post/livereload-for-nodejs</id>
    <content type="html"><![CDATA[<p>LiveReload is a wonderful tool/strategy for being able to develop websites more quickly.  You can make a change and see it immediately shown in the browser without requiring you to manually refresh.  To do this in NodeJs with Express, you'll need just a few packages.</p>

<p><img src="http://i.imgur.com/4773D.jpg" alt="grunt" /></p>

<!--more-->


<h2>LiveReload Express</h2>

<p>If you're doing a website on Nodejs these days, you're probably using Express.  Express uses the Connect library for its middleware scheme.  Just grab one more middleware to handle the LiveReload.  It will add a little snippet of JavaScript to each of the html responses that is requested through this middleware.  First, install:</p>

<p><code>
npm install connect-livereload --save-dev
</code></p>

<p>Next, import:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">configure</span> <span class="s">&#39;development&#39;</span><span class="p">,</span> <span class="o">-&gt;</span>
</span><span class='line'>  <span class="nx">app</span><span class="p">.</span><span class="nx">use</span> <span class="nx">require</span><span class="p">(</span><span class="s">&#39;connect-livereload&#39;</span><span class="p">)</span> <span class="mi">35729</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Note that we only want to import and use the middleware when in development.  This matches the fact that we are only declaring this package as in <code>devDependencies</code>.</p>

<h2>LiveReload Grunt</h2>

<p>Now you need to something to start a livereload server, watch files for changes, and broadcast their availability.  The rest of this will be done via Grunt.</p>

<p>First, install:</p>

<p><code>
npm install grunt-cli -g
npm install grunt grunt-regarde grunt-contrib-livereload --save-dev
</code></p>

<ul>
<li><code>grunt-cli</code> will allow you to run the <code>grunt</code> command in the terminal.  Global puts the bin in your path.</li>
<li><code>grunt-regarde</code> is a file watcher.  It senses changes to the filesystem.</li>
<li><code>grunt-contrib-reload</code> will handle the pushing of new code to the browser.</li>
</ul>


<p>Next setup the <code>Gruntfile.coffee</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">module.exports = </span><span class="nf">(grunt) -&gt;</span>
</span><span class='line'>  <span class="nx">grunt</span><span class="p">.</span><span class="nx">initConfig</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nv">regarde:</span>
</span><span class='line'>  <span class="nv">style:</span>
</span><span class='line'>    <span class="nv">files: </span><span class="p">[</span><span class="s">&#39;app/static/css/*.css&#39;</span><span class="p">]</span>
</span><span class='line'>    <span class="nv">tasks: </span><span class="p">[</span><span class="s">&#39;livereload&#39;</span><span class="p">]</span>
</span><span class='line'><span class="o">&lt;/</span><span class="nx">code</span><span class="o">&gt;&lt;/</span><span class="nx">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="nx">grunt</span><span class="p">.</span><span class="nx">loadNpmTasks</span> <span class="s">&#39;grunt-contrib-livereload&#39;</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="nx">grunt</span><span class="p">.</span><span class="nx">registerTask</span> <span class="s">&#39;be-lively&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s">&#39;livereload-start&#39;</span><span class="p">,</span> <span class="s">&#39;regarde&#39;</span> <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now when you run:</p>

<p><code>
grunt be-lively
</code></p>

<p>A livereload server is going to be setup.  Then we watch for filesystem changes.  The only things we're watching are css files in our app.  You could expand the <code>files</code> array to watch more if you wish.</p>

<p>Yay!</p>

<h2>LiveReload all the Things</h2>

<p>There are many ways to make this happen.  There are numerous Node libraries, Grunt plugins, and browser plugins.  Do what works for you.  Just make it happen fast and tend it well from the beginning to the end of your project.  Almost every solution I've found is somewhat high maintenance.  This one has proven to be the same.  What have you found to be your favorite LiveReload solution, and in what environment?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploy Yeoman App on Heroku]]></title>
    <link href="http://jaketrent.com/post/yeoman-app-on-heroku/"/>
    <updated>2013-04-23T07:12:00-06:00</updated>
    <id>http://jaketrent.com/post/yeoman-app-on-heroku</id>
    <content type="html"><![CDATA[<p>Yeoman is great developer tool that will help you generate a project format that is easy to get up and running quickly.  Out of the box, Yeoman only generates static sites.  But, with a few small tweaks, you can get it running on an app server, Nodejs, and up on Heroku.</p>

<p><img src="http://i.imgur.com/1Mc2kXh.jpg" alt="Yeoman" /></p>

<!--more-->


<h2>New Project With Yeoman</h2>

<p>To install Yeoman, run:</p>

<p><code>
npm install -g yo
</code></p>

<p>Now navigate to your new project directory and generate the scaffolding by running:</p>

<p><code>
yo webapp
</code></p>

<p>There are other generators, specifically for angularjs or a handful of other frameworks.  To see more options, run:</p>

<p><code>
yo --help
</code></p>

<h2>Add Node for Heroku</h2>

<p>Since Yeoman creates a static site, it should be read to serve out of any old web server.  But Heroku specifically wants an app server.  Node is one of the options, and it's a great option for a lightweight app server.</p>

<p>To get the node dependencies you need, create a <code>package.json</code> via:</p>

<p><code>
npm init
</code></p>

<p>Then pull down the dependencies you'll need:</p>

<p><code>
npm install gzippo express coffee-script --save
</code></p>

<p>Now create your app server, <code>web.coffee</code>.  It's about as light as they come:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">gzippo = </span><span class="nx">require</span> <span class="s">&#39;gzippo&#39;</span>
</span><span class='line'><span class="nv">express = </span><span class="nx">require</span> <span class="s">&#39;express&#39;</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nv">app = </span><span class="nx">express</span><span class="p">()</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">use</span> <span class="nx">express</span><span class="p">.</span><span class="nx">logger</span> <span class="s">&#39;dev&#39;</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">use</span> <span class="nx">gzippo</span><span class="p">.</span><span class="nx">staticGzip</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">__dirname</span><span class="si">}</span><span class="s">/dist&quot;</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">listen</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">PORT</span> <span class="o">||</span> <span class="mi">5000</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It's going to be serving the static resources that you build w/ Yeoman/Grunt that end up in the <code>dist</code> directory.  In order for code to get to Heroku, it needs to be commited to your git repo.  Thus, you need to remove the "dist" line from your <code>.gitignore</code> file, and don't forget to add and commit the files to git as you build them.  You may also have to add more tasks to the <code>Gruntfile.js</code> to copy over any other assets to <code>dist</code> that your app needs to run.</p>

<p>Finally create a <code>Procfile</code> file for Heroku in the root of your project that points to the <code>web.coffee</code> server:</p>

<p><code>
web: coffee web.coffee
</code></p>

<p>Now it's time to push to Heroku.  You should have the Heroku Toolbelt installed and create a heroku url by running:</p>

<p><code>
heroku create &lt;my_project&gt;
</code></p>

<p>To test your yeoman app as it will be run in production, first build it:</p>

<p><code>
grunt build
</code></p>

<p>Then run the grunt server:</p>

<p><code>
grunt server:dist
</code></p>

<p>Or if you have foreman and want to run the app using your <code>Procfile</code>, run:</p>

<p><code>
foreman start
</code></p>

<p>It's time.  Commit your code, especially that <code>dist</code> directory, and... deploy!</p>

<p><code>
git push heroku master
</code></p>

<p>There are quite a few steps there.  What did we miss?  Or what needs more explanation?  Perhaps we just need a <code>yo heroku</code> target.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Impressions of Grunt]]></title>
    <link href="http://jaketrent.com/post/impressions-of-grunt/"/>
    <updated>2012-12-12T14:24:00-07:00</updated>
    <id>http://jaketrent.com/post/impressions-of-grunt</id>
    <content type="html"><![CDATA[<p>Grunt is a great build tool for JavaScript projects.  It comes with a lot out of the box, and you can write your own custom tasks.  It joins a world fraught with many, glorious build tool options.  So, a bit has been made of the decision to have Grunt join the fray.  Perhaps most prominently, Miller Medeiros had <a href="http://blog.millermedeiros.com/node-js-ant-grunt-and-other-build-tools/">a few problems with Grunt</a>.  And in response, Ben Alman gave his reasoning on <a href="http://benalman.com/news/2012/08/why-grunt/">why he wrote it</a>.  Having used it for a bit, I have a few impressions.  Here they are so far.</p>

<p><img src="http://i.imgur.com/4773D.jpg" alt="Grunt impressions" /></p>

<!--more-->


<h2>Community</h2>

<p>There will probably never be any build tool that gains more mass than what already exists as just a bash or a make script.  And really nothing needs to.  Healthy-sized communities have been built up around different build tool options where those that used it liked the style, it fit their platform, and they found it useful.  Grunt feels like it's on track to become a highlight build tool in the Js community.  There are many using it <a href="https://github.com/gruntjs/gruntjs.com/issues/9">already</a> and more <a href="https://github.com/angular/angular.js/pull/1544">on the way</a>.</p>

<h2>Declarative vs. Procedural</h2>

<p>Which style of project configuration is better?  Declarative or procedural?  Wars have been started with lesser words.  I don't feel like it's a question of better.  It's just a matter of style.  There are pros and cons.  Where you do the many of same things as everyone else, declarative works just fine.  When you have to do new, original things, you have to write code to support that.  You might wrap that in a grunt plugin to encapsulate it then write declarative options to feed it.  But, you still own the plugin implementation.</p>

<h2>JavaScript Build for JavaScript Project</h2>

<p>Maybe obviously, the sweet spot for Grunt is building JavaScript projects.  Js projects are becoming more complex all the time.  Often, complementary build tools are lacking.  There are other projects that are named <a href="https://github.com/280north/jake">awesomely</a>, though they are mostly dead.  Grunt fills a gap for JavaScript projects.  It seems that the advantages of writing client <em>and</em> server js apply here as well:  Js build tools take advantage of the Js (Node) environment.  You can use your Js skills here.  The context switching is diminished.</p>

<h2>Synchronous Exec for JavaScript Build</h2>

<p>One of the main sellings points for NodeJs is that it is built from the ground up for using in asychronous environments and problems.  Build scripts aren't generally asynchronous.  Usually, it's quite the opposite.  Step 1 leads to step 2 and so on.  You can't skip, and future steps rely upon completion of the previous.</p>

<p>So, you can try <a href="http://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback">child_process.exec</a>, but it's asynchronous.  So, make it synchronous and try <a href="https://github.com/jeremyfa/node-exec-sync">exec-sync</a>.  But it has <a href="https://github.com/jeremyfa/node-exec-sync/issues/8">problems</a> vanilla exec doesn't.  The best synchronous exec for JavaScript I've found so far is <a href="http://documentup.com/arturadib/shelljs#command-reference/exec-command-options-callback">shelljs.exec</a>.</p>

<p>In this way, NodeJs/Grunt seems like an awkward fit as a build tool.</p>

<h2>Shell Commands in Grunt</h2>

<p>When I end up doing custom things in my Grunt build, it tends to be that I'm trying to get to the shell and execute something.  If I have a shell script, I can just execute it with <a href="https://github.com/jharding/grunt-exec">grunt-exec</a>.  If I'm trying to keep all logic in Grunt, I'll use <a href="https://github.com/arturadib/shelljs">shelljs</a>.  The thing that gets me with both of these solutions is that I'm in Node, constantly trying to get out of Node to run something in the shell, like a git command.  So my code ends up looking like lots of these:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">shell</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;shelljs&#39;</span><span class="p">);</span>
</span><span class='line'><span class="nx">grunt</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="s1">&#39;Cloning repo&#39;</span><span class="p">);</span>
</span><span class='line'><span class="nx">shell</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;git clone &#39;</span> <span class="o">+</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">repo</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>There's a bit of cruft to recreate bash in Node.  It's not as clean and does not read as well as a vanilla shell script might:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> <span class="s1">&#39;Cloning repo&#39;</span>;
</span><span class='line'>git clone <span class="nv">$repo</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>New APIs</h2>

<p>Grunt does quite a bit for you.  It's now up to me to go figure out all the cool stuff it can do.  Once I found the <a href="https://github.com/gruntjs/grunt/wiki/grunt.file">file API</a>, I was excited and retained a touch of the nagging feeling I just mentioned related to shell commands.</p>

<h2>JavaScript Build Scripts are Cross-OS Compatible</h2>

<p>One of the main reasons you would choose to write JavaScript for a build script instead of a .sh or a .bat file is that you can use it multiple OS'es.  Node <a href="https://github.com/jeremyfa/node-exec-sync/pull/6">should</a> :) execute the same on each platform it supports -- essentially Windows, Linux, and Osx.</p>

<h2>Builds Scripts as Plugins</h2>

<p>When you come up with a new Grunt task that is obviously useful for someone else out in the world, you'll likely generalize it and publish it to npm.  There already a good number of <a href="https://npmjs.org/browse/keyword/gruntplugin">'gruntplugin'</a>s out there.  This is a great sharing mechanism that not every build tool environment will give you.  I'm grateful for the good Grunt plugins shared out there.</p>

<h2>Grunt Configuration</h2>

<p>Grunt, by default, has a declarative configuration style.  This means lots of json, often long and nested.  It's all organized by task names, so it's fairly easy to find stuff.  But the bottom line is that there is a fair bit to navigate in the average grunt file.</p>

<h2>Breaking Changes in Grunt API</h2>

<p>As of this writing, Grunt 0.4 is on the verge of release.  By all accounts it will make things better, and it looks promising.  They have a mostly-straightforward <a href="https://github.com/gruntjs/grunt/wiki/Upgrading-from-0.3-to-0.4">migration guide</a>.  The thing that has been the most painful is the lack of backward compatibility.  My current, working builds rely on Grunt plugins that are not 0.4 compliant, so I have two choices:  Help each of those plugins upgrade or wait until 0.4 reaches critical mass -- ie, most worthy plugins are upgraded.</p>

<h2>Grunt is Fast</h2>

<p>Grunt is faster than Pumba being chased by a hyena.  Previous to Grunt, we were using Maven to do similar tasks.  Now we do more (Grunt has made it easy for us to incorporate more good practices -- eg, linting), and the build is done is a serious fraction of the time.  The speed is super dependant on what operations the build actually performs, but my impression for my builds is that Grunt is fast.</p>

<h2>The Grunt Logo</h2>

<p>Yes, it's superficial, and it's even a lame reason, but I like Grunt because they have a great logo.  Wild boar for logo?  Instant win.  (That is what it is, right?)</p>

<p>So, is Grunt helping you out?  What are your impressions?  Or are you using something else entirely?</p>
]]></content>
  </entry>
  
</feed>
