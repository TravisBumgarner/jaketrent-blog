<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Productivity | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/productivity/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2014-03-17T08:24:37-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Switch: How to Change Things When Change is Hard Review]]></title>
    <link href="http://jaketrent.com/post/switch-review/"/>
    <updated>2014-03-04T07:51:00-07:00</updated>
    <id>http://jaketrent.com/post/switch-review</id>
    <content type="html"><![CDATA[<p>The book is called Switch: How to Change Things When Change is Hard.  It's by Chip Heath and Dan Heath.  It shows interesting anecdotes and good strategies on how to motivate people and situations to change.</p>

<p><img src="http://i.imgur.com/zjnOrqX.jpg" alt="Switch" /></p>

<!--more-->


<h2>Who are you?</h2>

<p>Did you know you are actually a combination elephant and rider?  Your rider represents your analytical thinking.  He wants to know every option.  He gets hung up in analysis paralysis.  It is likely he'll never make a decision.  Your elephant represents your emotions and your instincts on things.  It's much bigger than the rider, who is supposedly in control.  If your elephant decides it wants something, it usually gets its way.</p>

<p>This analogy of our two halves is a bit silly but works quite well.  It illustrates well our internal struggle.  It helps me realize how I approach problems, seek solutions, and eventually make a choice on how to proceed.  I thought it was quite helpful.  As with most of the concepts in the book, it is revisited many times, presumably in order for us to do a better job remembering the concept.</p>

<h2>Practical and Powerful</h2>

<p>The 3 main thrusts of the book are focused around a strategy that the authors stated they hoped was small and simple enough to be memorable and practiced yet real and powerful enough to actually help us exact change.</p>

<h3>1. Direct the Rider</h3>

<p>The rider, admittedly, will not make decisions easily.  So, he needs some direction.  It can be hard to choose how to even begin to change.  The main helps stated in the book are as follows:</p>

<h4>Follow the Bright Spots</h4>

<p>In the problem situation or field that you are considering, there are most definitely things that <em>are</em> working.  These are the bright spots.  Why not replicate these good things in your own way for your own problem?  There are people who have faced a similar problem, whether they knew it or not, and found their way through all or part of it.  These are usually easier to discover than by starting from scratch.  And we know they'll work!</p>

<h4>Script the Critical Moves</h4>

<p>To ensure the rider takes action, you'll want to make it more than abundantly clear what <em>exactly</em> you want him to do.  If there is one thing that will make the biggest impact, that becomes your critical move.  Script, just as in a screenplay, exactly what actors in the program are expect to perform.</p>

<h4>Point to the Destination</h4>

<p>As the rider is weighing options, there will be many that appeal to him (or not).  It will be important to enumerate in an analytical way why the destination you're choosing is worth pointing toward.</p>

<h3>2. Motivate the Elephant</h3>

<p>The elephant, once sufficiently motivated becomes the powerhouse that ensures change will begin.  The elephant is the one to change inertia, bringing us lurching out of our standing position.</p>

<h4>Find the Feeling</h4>

<p>Knowledge alone will not change behavior.  This is obvious considering our clear knowledge of the ill effects of habits such as smoking.  People still smoke.  So we must additional paint an emotional picture of what a change may mean to someone, what it will feel like, and the deeper reasons for attempting it.</p>

<h4>Shrink the Change</h4>

<p>Large changes require a large effort and many steps.  It may look daunting, especially to start.  The elephant starts on emotion, but it will also stop by the same virtues.  Break down the change into steps that are small and readily doable.</p>

<h4>Grow Your People</h4>

<p>People attach themselves to causes.  Causes appeal to the inner values of people and motivate them from within.  Encourage a sense of identity with the change you're promoting.  If people can identify with the behavior as a part of who they are, they are likely to meet the change with a great dose of internal enthusiasm and excitement.</p>

<h3>3. Shape the Path</h3>

<p>Even with great instructions for our riders and motivation for our elephant, the friction to change may still be strong.  There is still more we can do to help.</p>

<h4>Tweak the Environment</h4>

<p>What looks like resistance from a person may just be that person falling into the environmental norms.  It may be the way things have always been done, and it's natural to continue doing them.  Make the change you advocate the most natural thing to do as a product of the environment.  And consider environmental change your responsibility before you blame others for not responding well to change.</p>

<h4>Build Habits</h4>

<p>It turns out that making decisions, especially hard decisions to change, takes energy and will power.  And we only have so much to give.  If something becomes automatic, the effort to enact the behavior will be much lower.  We'll just do it.  Determine how you can create triggers that happen automatically to regularly change behavior along the path.</p>

<h4>Rally the Herd</h4>

<p>Behavior is contagious.  People want to respond as others around them do.  Most people instinctively do not want to stand out, especially in negative ways, compared to the crowd around them.  To encourage change, publicize the majority behavior that is in line with what you seek.</p>

<h2>Style and Read</h2>

<p>Switch is a pretty short book.  The sheer amount of anecdotal and interesting examples of people chaning their lives and communities made it fun and inspiring to read.  I think I'd have to re-read it to have the strategies and tactics for change sink in deep enough to pull them out in the midst of change, but it does seems small enough to remember and powerful enough to be useful.  At the least, it's a great reference.  I'd recommend the book.  And since everyone has encountered and/or wants to change, it seems like an applicable read.  Chip and Dan have several other books I'm going to go check out now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exercism Review]]></title>
    <link href="http://jaketrent.com/post/exercism-review/"/>
    <updated>2013-11-19T07:29:00-07:00</updated>
    <id>http://jaketrent.com/post/exercism-review</id>
    <content type="html"><![CDATA[<p>Exercism.io is a fantastic site and tool that provides a wealth of daily code exercises.  If you want to learn to be better in a language, it's a great resource to do exercises and receive feedback.</p>

<p><img src="http://i.imgur.com/2oAEqBZ.jpg" alt="Exercism" /></p>

<!--more-->


<h2>Origin</h2>

<p><a href="http://exercism.io">Exercism.io</a> was introduced to me by Franklin Webber of gSchool and JumpStart Labs fame.  He and his colleagues use it as a part of their instruction, and it's a great, free tool available to the public.</p>

<h2>Languages</h2>

<p>There is a fun array of language-learning possibilities inside Exercism.  It currently includes a varying number of exercises across these languages:</p>

<ul>
<li>clojure</li>
<li>elixir</li>
<li>haskell</li>
<li>javascript</li>
<li>objective-c</li>
<li>python</li>
<li>ruby</li>
<li>scala</li>
</ul>


<p>I'm currently running through the Ruby exercises.</p>

<h2>Starting Point</h2>

<p>Based on what I've seen of the Ruby and JavaScript exercises, I don't think that Exercism's exercises are meant for an absolute beginner.  Some basic knowledge of the programming language is assumed and required.  You'll start a little deep if you know next to nothing.  These exercises are meant to expand your exposure to and understanding of language features.</p>

<h2>Installation</h2>

<p>Installation consists of a few things:</p>

<ol>
<li>Go to <a href="http://exercism.io">exercism.io</a> and register using your Github credentials.</li>
<li>While on the site, download the CLI.  It's a pre-built binary that you just need to put somewhere that is tied to your system PATH.  That way you can execute it from the terminal.</li>
<li>Setup your environment for the language you'll be learning.  Again, this information is on the site.  None of the environments are automatic in their setup, and you must follow the written steps to be ready to develop in your weapon, er language of choice.</li>
</ol>


<h2>Your First Exercise</h2>

<p>After installation, you're ready for your first exercise.  On the terminal, type:</p>

<p><code>bash
exercism fetch
</code></p>

<p>This will download fresh exercises at the head of each of your language paths.  At first, you'll start on exercise 0 of each of the language paths.  Now, choose a language.  I chose Ruby first.  The first exercise was called <code>bob</code>.  Bob is a lackadaisical teenager who responds with smart remarks to whatever somewhat says to him.  Typical.</p>

<p>Bob comes with a suite of failing tests.  All the tests are written, and it's up to use to write the code that actually makes Bob function and the tests pass.  This is literally TDD or test-driven development, and yay for us, someone has already written the tests!  In the case of Ruby, the tests are written in a MiniTest syntax.  To run them, I'm typing:</p>

<p><code>bash
ruby bob_test.rb
</code></p>

<p>This is where I think we might be able to have a bit of a better setup with the exercises.  It would be nice to have the tests automatically run on a file watch as opposed to having to run them each time manually.  For this, I personally setup <code>guard-minitest</code>.  I would recommend the same.  Of course, I can only think that Exercism doesn't do this by default in order to simplify the environment setup process.</p>

<h2>Nitpicking</h2>

<p>After you complete your first exercise in some form by getting all the tests to pass, you can submit it to the site for feedback.  For example:</p>

<p><code>bash
exercism submit ruby/bob/bob.rb
</code></p>

<p>The CLI will give you a link to your now-online code, and you can go there to see your submission.  Others who have completed the same exercise will also be able to see your solution.  And this is one of the coolest potentials of Exercism.  Others can give you feedback on your solution, called "nitpicks" by default.  This is a great learning opportunity.  We are ready to take feedback given from the perspective of others in their experience with the language.  We can also give feedback, training our eye to be more critical in our observation and future writing of code.  It feels like a great outcome and a great potential community.</p>

<p>I have given nitpicks.  Of course, that's easier to do.  But, I am sad to say that I have never received any.  It's hard to tell how active the community really is.  I see quite a few submissions, but there are definitely fewer nitpicks than submissions.  There's quite a bit untapped community learning potential here.  To help this, I wish the system allowed you to unlock the next exercise in your language path without closing opportunity for nitpicks on submitted exercises.</p>

<p>So, have you used Exercism.io before?  Do you know of similar sites?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How MarkLogic Made Me a Better Programmer]]></title>
    <link href="http://jaketrent.com/post/how-marklogic-made-me-better-programmer/"/>
    <updated>2013-08-08T09:01:00-06:00</updated>
    <id>http://jaketrent.com/post/how-marklogic-made-me-better-programmer</id>
    <content type="html"><![CDATA[<p>I started programming on the <a href="http://www.marklogic.com/">MarkLogic</a> platform in 2010.  It was a very new experience for me.  I don't program in it these days, but I still think back on the experiences I had with MarkLogic and in general believe that they made me a better programmer.  Here's how.</p>

<p><img src="http://i.imgur.com/32OKIUH.png" alt="MarkLogic" /></p>

<!--more-->


<h2>First Functional Language</h2>

<p>MarkLogic is a proprietary platform that uses the XQuery language.  This is MarkLogic-flavor XQuery, augmenting the vanilla.  There are first-level functions.  There are sequences.  There are no side effects.  There is no state outside of function scope.</p>

<p>This language proved to require a new way of thinking.  I came from coding Java at the time.  I was without my <code>StringBuilder</code> class.  I remember the first time I tried to build up a string dynamically in code.  There is no such thing as throwing substrings in a builder or a buffer and building it up (no side effects).  Of course, there is a way to build a dynamic string; it is just different.  I became a lot more comfortable with recursive methods for solving problems.</p>

<p>As a side note, the language isn't 100% functional.  For instance, there actually are side effects.  For example, the <a href="https://docs.marklogic.com/map"><code>map</code></a> api sets values on preexisting maps and returns the same map.  And the terrible <a href="https://docs.marklogic.com/xdmp:set"><code>xmdp:set</code></a> will bypass all of the functional sauce and set whatever whenever and is to be avoided.</p>

<h2>First NoSql Store</h2>

<p>MarkLogic has its own database built in.  It's a document store.  It was the first place I implemented real NoSQL work and pushed it to production.  Here, I learned document design.  I practiced optimizing for reads or writes depending on the use case.  The experience helped me think beyond well-formed tables and embrace the messier data that is more true to life.  I was thinking more in terms of search engines and less in terms of spreadsheets.</p>

<p>Coding in MarkLogic utilizes XQuery which encompasses XPath.  Given that much X technology, the data format was almost assuredly going to be XML.  And so it is.  Every document stored in MarkLogic is XML.  I became a lot better at tree traversal as a result.</p>

<h2>Lack of Libraries</h2>

<p>The MarkLogic ecosystem at the time was really lacking.  I don't follow its current state, but it's probably safe to say that there is less going on here than in the world of Node or Ruby.  You won't find a MarkLogic package manager a la <code>npm</code> or <code>gem</code>.  You probably won't even find a library to reuse.  There are literally just a handful of libraries that are shared widely in my experience, and these are lower-level utility libraries of the flavor of UnderscoreJs.</p>

<p>This meant that if I needed code, I was going to write it.  So, I wrote a lot of code.  I learned to produce everything I needed and not rely on any 3rd party code.</p>

<p>This was the same when it came to utilities on the platform.  For instance, there was not a unit test library at the time I started into XQuery.  There was a framework that was written in Java that would exercise XQuery code, but that didn't fit my environment needs very well and felt odd, so we wrote our own unit testing framework a la Junit or Jasmine, called <a href="https://github.com/irinc/xqtest">XqTest</a>.  We finally open sourced it (also rare for the MarkLogic ecosystem), but by then several similar frameworks had been created.</p>

<h2>Lack of Help</h2>

<p>MarkLogic is a proprietary system.  There aren't many people using it, but those that do license it from the MarkLogic company.  They also pay for support.  Most of the expertise I encountered in MarkLogic was either a visiting consultant from MarkLogic, an engineer I met at the one MarkLogic conference, MarkLogic world, or a fellow in-house engineer.</p>

<p>This means that when you go to StackOverflow, there is a woeful lack of good solutions for common problems.  So, I learned to do a lot of debugging by myself and just keep on keeping on until I figured out the problem.  We had to write almost all of our code, so I was mostly reading my own code, which is easier.  Google wasn't a lot of help, and that's pretty odd in this age of programming.  Upside was that once I wrote the web article about the subject, I was the first-page <a href="http://rockycode.com/blog/tech/marklogic/">result</a>.</p>

<h2>Playing Ops</h2>

<p>MarkLogic has its own web server as well, built into the monolith MarkLogic server product.  It was a new beast for the ops guys I worked with.  I was as new to it as them, thus I got to play ops a lot more than I would have on our older, more traditional systems.  I got to help keep the thing running.</p>

<p>I also got to help keep the apps tuned.  It turns out that MarkLogic can be either really performant or really <em>not</em> performant.  Often, I wrote the "not" way, and I had to help optimize (of course, via our in-house performance monitoring tools).</p>

<h2>The Experience</h2>

<p>I was excited to learn MarkLogic at the time.  It was something new.  I enjoy that.  New code, new team, new thinking.  It was a high-profile product.  It was really a good experience.</p>

<p>I felt like I became very productive on the platform and was able to produce quality and quantity code.  In the end, I chose to not do more more MarkLogic.  I was doing more heavy client-side apps.  The XML just became a stumbling block where Json is king.  The functional paradigm is cool.  I really like it.  But I really don't like the XQuery language.  Its api is not very expressive, and its syntax requires a ton of typing.  MarkLogic is growing in its acceptance and use, but not at a huge pace.  It still seems like a niche product, used mostly in the publishing and defense industries.  It didn't seem like a great investment to keep spending my golden dev years on the platform.</p>

<p> But for all the pros and cons of the platform and all the ups and downs of the experience, I feel like one of the net effects was that I became a better programmer in new, interesting ways.  For that, I'm grateful.  I'm glad I did it, and I'm glad to move on.  There are, after all, soooo many cool things to try in this age of software development.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[So Good They Can't Ignore You]]></title>
    <link href="http://jaketrent.com/post/so-good-they-cant-ignore-you/"/>
    <updated>2013-07-17T22:35:00-06:00</updated>
    <id>http://jaketrent.com/post/so-good-they-cant-ignore-you</id>
    <content type="html"><![CDATA[<p>"<a href="http://www.amazon.com/gp/product/1455509124/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1455509124&amp;linkCode=as2&amp;tag=jaktre-20">So Good They Can't Ignore You</a>" is written by Cal Newport.  He rejects the idea of following your passion in order to find the work you love.  Instead, he suggests the accumulation of career capital.</p>

<p><img src="http://i.imgur.com/VWjzM2c.jpg" alt="So good" /></p>

<!--more-->


<p>What follows are the main sections or rules of the book with a few of my takeaways each.  The man is obviously steeped in science.  The book reads like laws of physics.  Well, not quite that dry, but just as precise and well organized.  I love reading him say, "In which I argue..."  Sounds very professorish.</p>

<h2>The Passion Hypothesis</h2>

<p>Isn't it true that when someone is trying to determine a career path or job, we often ask questions like, "Well, what do you want to do?" And give advice like, "Do something you're passionate about."  The author gives a few individual profiles of people who followed this advice without key ingredients and were, in the end, disappointed by the result.  He also points out a whole class of lifestyle designers who, in their delusion, <a href="http://jaketrent.com/post/quitter-review/">quit their day job</a> to live on their yet-to-be-created passive Internet income and aren't able to make it.</p>

<h2>Career Capital</h2>

<p>(In which) Newport argues that "working right trumps finding the right work."  Essentially, you worry more about what you are producing and the value you're giving (craftsman mindset) instead of whether or not it fits some passion you're predisposed to.</p>

<p>Career capital is essentially the collection of rare and valuable skills that you possess that the market is willing to pay for.  Without this, you will likely not enjoy your work.  With this, your ability to define and magnify your work is much greater.</p>

<p>The title of the book comes from Steve Martin, who remarked in an interview that aspiring comics didn't like his advice.  They wanted quick fix answers like, "How do I get an audition?"  But he would always advise, "Be so good they can't ignore you."  And most likely, judging by your name recognition of Monseiur Martin, he has worked himself to that level.</p>

<h2>Autonomy</h2>

<p>It is autonomy, not passion, that is most likely to help you love your work.  The amount of control you have in a job is likely to influence your liking it.  The more control, the better.  But, it doesn't come immediately.  If you don't have the career capital, you can't purchase it.  And if you're offered it, while you know you probably don't have the capital, it's probably a mirage.  But if you're so good they can't ignore you, your ability to set terms and influence your environment is real.</p>

<h2>Importance of a Mission</h2>

<p>"So good they can't ignore you" hardly sounds like your average work.  Instead it's likely that you're attached to a catchy mission.  You have a vision that people want to share.  You do work that people like to talk about.  Your name is known by peers and leaders in your industry.  You have made it to the edge of your field.  You are pushing boundaries, and are creating new fields, often mixtures of those you have expertise within.</p>

<p>These stages of achievement that push your career and humanity forward are significant.  Little steps or bets need to be made strategically and intentionally in order to create a habit of advancing your knowledge and skill.  The sheer investment required to get to these levels is immense.</p>

<h2>Conclusions</h2>

<p>Newport's book was worth the read.  In fact, I recommend it to anyone about to enter college, desiring to start in a new field, wanting to scratch an entrepreneurial itch, or thinking of changing jobs.</p>

<p>His advice is solid.  It's more grounded and nuanced than the "follow your passion", feel good propaganda.</p>

<p>The writing is a little dry.  It's a short book at just over 200 small pages.  Still, it took me a bit to get through.  I wasn't exactly glued to the pages.  But I do believe the advice is invaluable if it influences one to throw all their potential ability behind producing their best work and becoming their best worker.  It reads well, but sometimes feels like a textbook.  Perfect for all that intentional learning we all want to do, right?</p>

<p>Most importantly, it inspired me to be so good they can't ignore me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn to Procrastinate]]></title>
    <link href="http://jaketrent.com/post/learn-to-procrastinate/"/>
    <updated>2013-06-10T06:57:00-06:00</updated>
    <id>http://jaketrent.com/post/learn-to-procrastinate</id>
    <content type="html"><![CDATA[<p>When making software, sometimes we want everything we can imagine at once.  We want the software to be perfect -- then we'll ship it.  Learn to procrastintate.  You might ship more, and you might like the the eventual outcome better.</p>

<p><img src="http://i.imgur.com/cXx17co.png" alt="Focus on shipping" /></p>

<!--more-->


<h2>Worthless Software</h2>

<p>Software that sits inside of your git repo, unreleased, is worthless software.  You're not going to get paid for it.  You're not going to make someone's life better.  You're not going to attract any new business.  It provides no utility.</p>

<p>When does software return any value?  At the very soonest, software provides value when it ships -- when it's released to the public or your customers.</p>

<p>So why do we wait so long to ship?</p>

<h2>Excuses for Not Shipping</h2>

<h3>It Must Do More</h3>

<p>Software has a fair bit of built-in or essential complexity.  Making software is challenging.  Sometimes we make it worse and introduce our own accidental complexity.  How?  We don't ship.</p>

<p>We iterate on unreleased software, expand it, and pretend to fully understand what we're trying to solve.  The software gets bigger and more complex.  We want our (unshipped) software to somehow solve even <em>more</em> problems before it's solved any.  And any problem we attempt to solve without actually testing it (in production), is still just a guess at how to solve it.</p>

<h3>It's Not Awesome Yet</h3>

<p>Sometimes in an attempt to create a (hopefully) great initial impression, we wait to release anything.  This makes sense to some degree, but it can easily be taken to a less useful extreme.  Once we have a feature set that we judge is sufficiently awesome to blow a potential client's socks off, we'll release it in a big bang.  Boom!  Now the world can see my software in all the glory I have bequeathed it.</p>

<p>Just as we have been guessing as to how may problems the software will solve, we have been guessing as to how warm people will be to the idea of actually using what we've created.</p>

<h2>What to Procrastinate</h2>

<p>So obviously there are problems with procrastinating.  There are definitely things that you <em>don't</em> want to procrastintate: working, shipping, asking for payment.  What <em>should</em> you procrastinate?</p>

<h3>Little Things that are Hard</h3>

<p>At first glance, this just looks like a cop out.  You <em>should</em> do the important things that are hard.  Even the small things can add a nice touch.  But in an effort to ship, these are often the little things that don't add too much but take an inordinate amount of time to figure out or complete.  Skip these things and come back to them later to add the polish.</p>

<h3>Things that are not Core Functionality</h3>

<p>You're trying to ship a small, cohesive feature set as fast as you can.  There will be many features on the perephery that you'll be tempted to work in as well.  Fight the temptation.  Get used to cutting out good features in order to ship the ones you <em>need</em>.  In this way, you'll help ensure that all of your valuable time is used creating the most value for your customers.</p>

<h3>Things that Create Little Tech Debt</h3>

<p>When you start skipping things, this can create problems for you later.  This can be technical debt.  If you want your product to evolve and grow over time, you can't afford large amounts of technical debt.  But watch out!  You can use very large lengths of time doing things that add little value in the name of avoiding technical debt.  Be willing to take on some tech debt.  Do this on a case-by-case basis, because this trade-off requires thinking.</p>

<h2>Why You'll Like Procrastinating</h2>

<p>Your satisfaction will sky-rocket when you feel like shipping is within reach.  Break down the barriers to getting there.</p>

<p>Focus on the most valuable features, and you'll feel like you add maximum value every day -- because you are!</p>

<p>You'll be able to move faster because you aren't getting bogged down in munitia.  By not taking tangents, your flow time will increase.  You won't need to context switch to solve small, hard problems.  You can focus on the important, hard problems for contiguous lengths of time.</p>

<p>You'll have something to show a lot faster.  You'll have a vertical of working features that are fun to use and are useful -- when shipped, that is.</p>

<h2>Different Paths Converge at Shipping</h2>

<p>Of course there are as many different ways to make software as there are types of software and types of software teams.  That's one of the things that makes software creation insanely fun and rewarding.  Find what works for you, and ship lots and lots of awesome software.</p>

<p>In the end, shipping should be a common goal, and we shouldn't procrastinate that.</p>
]]></content>
  </entry>
  
</feed>
