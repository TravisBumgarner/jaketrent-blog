<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: angularjs | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/angularjs/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2014-12-26T09:24:59-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ng-Conf Review]]></title>
    <link href="http://jaketrent.com/post/ng-conf-review/"/>
    <updated>2014-01-24T07:22:00-07:00</updated>
    <id>http://jaketrent.com/post/ng-conf-review</id>
    <content type="html"><![CDATA[<p>Ng-Conf just happened last week in Salt Lake City, Utah.  It was awesome.  Oh blast, I blew the punch line.  Anyway, here's my take.</p>

<p><img src="http://i.imgur.com/4swtO6x.jpg" alt="ng-conf" /></p>

<!--more-->


<h2>Format</h2>

<p>Two days.  Early 'til late.  One track.  20-40 min talks virtually back to back.  Lightning'y?  When we broke for lunch, I felt relieved.  My brain could go into some low-power mode.  Breaks between talks were mostly announced as anywhere from 30 seconds to 3 minutes, this whilst yammering off a short list of swag winners.  The format encouraged content, and there was a lot of it!</p>

<h2>Line Up</h2>

<p>The conference was easy to look forward to.  Looking at the speaker list, I was immediately impressed.  At one point during the event, Aaron Frost said that they hoped if the Angular team would come that they'd get more attendees.  Yes, that was a draw.  It was fun having them there.  Core.  Very core.  I believe that about each member of the team took the stage over the two days.</p>

<p>The speaker list in total was very impressive.  There was a good mix of local and remote talent who came together to cover a broad array of Angular and JavaScript-related topics.</p>

<h2>Talk Quality</h2>

<p>Talk for talk, just numbers-wise, it was definitely one of the most high quality conferences I've attended.  Of course, there were some less-than-stellar presentations.  But, on the whole, I was more than impressed by the subject mastery and teaching ability of the speakers.  Thank you to everyone who prepared.</p>

<p>There were also some definite highlights: Dave Smith on directives, Vojta Jina on DI, Brian Ford on zone.js, and Julie Ralph on Protractor.</p>

<p>And one of the best parts is that each of these talks was recorded on video for a livestream and <a href="http://www.youtube.com/user/ngconfvideos">on youtube for later viewing</a>.</p>

<h2>Venue</h2>

<p>The conference was held at the Little America hotel in Salt Lake City.  It was a beautiful location.  The combined main ballrooms that the talks were held in were awesome.  Plenty of marble.  The food was great.  There weren't tons of snacks, but that was probably good for my health.  The air quality in Salt Lake during the conference wasn't good.  In fact, oobleck!  But, I didn't get food poisoning -- plus!</p>

<h2>Smooth</h2>

<p>I heard it said by multiple people during the conference that it was the best first-time conference they had attended.  Indeed, everything went Domo smooth.  The content was the star.  It was fun.  It was energetic (minus some confusing lack of screaming for all the sweet swag -- probably had something to do with the sheer amount, like clapping for the 3rd curtain call).  The AV crew did a fantastic job.  Usually, it's annoying to sit in an audience as video or audio problems plague the start of a talk.  That simply did not happen here, and it was oh, so refreshing.</p>

<p>Oh yeah, and sweet jacket!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Change Page Title in Angular Route]]></title>
    <link href="http://jaketrent.com/post/change-page-title-angular-route/"/>
    <updated>2013-11-07T07:03:00-07:00</updated>
    <id>http://jaketrent.com/post/change-page-title-angular-route</id>
    <content type="html"><![CDATA[<p>When you change routes in Angular, the page title doesn't change automatically, but this can be done rather simply.</p>

<p><img src="http://i.imgur.com/wVBKD.png" alt="Angular Router" /></p>

<!--more-->


<h2>Servers and Clients</h2>

<p>Client-side routers are pretty awesome.  A new url is pushed into the browser's history to represent the particular resource that pure client code has produced and displayed.  It's pretty cool.  It's also used widely these days.  Angularjs has a nice little router built into its framework.</p>

<p>Route changes from a server always have the page title set automatically in the <code>head &gt; title</code> tag.  Client-side routing doesn't have that exactly.  Nor does the Angularjs router change the page title via an automatic mechanism.  So, let's add our own.</p>

<h2>Add Page Title to Angular Router</h2>

<p>First, notice that you can add any arbitrary attributes to an angular route that you desire.  In the code below, notice that each route has a <code>title</code> attribute:</p>

<p>```coffeescript app.coffee
angular.module('app', []).config ($routeProvider) -></p>

<p>  $routeProvider</p>

<pre><code>.when '/',
  controller: 'HomeCtrl'
  templateUrl: "/templates/home.html"
  title: 'Home'

.when '/about',
  controller: 'AboutCtrl'
  templateUrl: "/templates/about.html"
  title: 'About'
</code></pre>

<p>```</p>

<p>Then in a place that exists on every route -- something like an <code>AppCtrl</code> -- you can gain access to the <code>current</code> route's <code>title</code> every time the route changes:</p>

<p>```coffeescript app-ctrl.coffee
angular.module('app').controller 'AppCtrl', ($rootScope) ->
  $rootScope.$on '$routeChangeSuccess', (event, current, previous) =></p>

<pre><code>$rootScope.pageTitle = $route.current.title
</code></pre>

<p>```</p>

<p>Now we have put the route's <code>title</code> in <code>$rootScope.pageTitle</code> and can use it in our template:</p>

<p>```html app.html
<html>
  <head></p>

<pre><code>&lt;title ng-bind="pageTitle + ' | MyApp'"&gt;&lt;/title&gt;
</code></pre>

<p>  </head>
  <!-- ... -->
```</p>

<p><code>ng-bind</code> is just like using double curlies, but also acts as if it's surrounded by an ng-cloak as well.  Notice that in the title, I'm even concatenating the <code>pageTitle</code> with my app's overall name.</p>

<p>Props go to <a href="http://github.com/danethurber">@danethurber</a> for putting this title changing logic in our most recent app.</p>

<p>Is this how you change your Angular app's title?  Is there a better way?  Specifically, I wonder if <code>AppCtrl</code> really is the best place to listen for <code>$routeChangeSuccess</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Angular Directive With Isolate Scope]]></title>
    <link href="http://jaketrent.com/post/test-angular-directive-isolate-scope/"/>
    <updated>2013-08-21T07:46:00-06:00</updated>
    <id>http://jaketrent.com/post/test-angular-directive-isolate-scope</id>
    <content type="html"><![CDATA[<p>Directives with isolate scope do not inherit their scope from their parent.  Thus, the pattern to test them is slightly different.</p>

<p><img src="http://i.imgur.com/wVBKD.png" alt="Angular Isolate Scope Testing" /></p>

<!--more-->


<p>When testing a directive, you'll often want to setup some fixture element to attach your directive to.  This will act as the DOM that you will compile with scope.  At that point, the variables that you attached to scope will be available within the directive under test.</p>

<p>For example, if I had a directive called <code>AccountList</code> with isolate scope:</p>

<p>```coffeescript account-list.coffee
angular.module('app').directive 'AccountList', ->
  restrict: 'EA'
  replace: true
  scope:</p>

<pre><code>accounts: '='
</code></pre>

<p>  # etc ...
```</p>

<p>Then I would setup my test something like this:</p>

<p>```coffeescript account-list.spec.coffee
describe 'AccountList', -></p>

<p>  elm = null</p>

<p>  beforeEach inject ($rootScope, $compile) -></p>

<pre><code>accounts = []
for num in [1..5]
  accounts.push createFakeAccount()
$rootScope.accounts = accounts

elm = angular.element """
  &lt;account-list accounts="accounts"&gt;&lt;/account-list&gt;
"""

e = $compile(elm)($rootScope)
e.scope().$digest()
</code></pre>

<p>  # actual specs, using elm ...
```</p>

<p>A few points:</p>

<ul>
<li><code>inject()</code> comes from <code>angular-mock</code>.  It is currently only supported in Jasmine.</li>
<li>Before each test of the <code>AccountList</code> directive, a set of 5 accounts will be put in scope so the directive, presumably, has something to display.</li>
<li><code>$rootScope</code> is going to be the only scope that you can get to easily from your tests.  You can attach variables to it directly as above or call <code>$rootScope.$new()</code> to generate a new scope if you'd like.</li>
<li>We initially <code>$compile</code> the fixture element, passing in <code>$rootScope</code>.</li>
<li>To get Angular to actually act internally on the variables that we've passed into the directive and put them on scope, we must call the important line of code: <code>e.scope().$digest()</code>.</li>
</ul>


<p>Now you should be ready to rock and roll with your tests.  Isolate scopes can be tricky.  Testing them, a bit tricky as well.</p>

<p>Do you know a better way?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spies with Sinon and Chai]]></title>
    <link href="http://jaketrent.com/post/spies-sinon-chai/"/>
    <updated>2013-08-19T08:21:00-06:00</updated>
    <id>http://jaketrent.com/post/spies-sinon-chai</id>
    <content type="html"><![CDATA[<p>Spies will help you verify calls to methods without actually calling them.  <a href="http://sinonjs.org/">Sinon</a> is a library that provides spies.  <a href="http://chaijs.com/">Chai</a> will provide assertions appropriate to spying.</p>

<p><img src="http://i.imgur.com/yuKcrP9.jpg" alt="Sinon-chai Spies" /></p>

<!--more-->


<h2>Install Dependencies</h2>

<p>You'll need 3 dependencies in dev mode for running your tests:</p>

<p><code>
npm install sinon chai sinon-chai --save-dev
</code></p>

<p>Now make sure that you import these testing tools into your test environment.  I'm using <a href="http://karma-runner.github.io/0.10/index.html">Karma Runner</a>, so my <code>files</code> array has these 3 lines:</p>

<p><code>javascript
'node_modules/sinon/pkg/sinon.js',
'node_modules/chai/chai.js',
'node_modules/sinon-chai/lib/sinon-chai.js',
</code></p>

<p>Make sure that you are including the packaged version of each of these files.  For instance, the <code>sinon/lib</code> files are not built together, so you'll likely import some subset of needed files; it won't error out, but it won't provide working spies like we're wanting (so use the <code>pkg</code> directory files).</p>

<h2>Spying</h2>

<p>We spy because we care.  We don't want certain methods to be called.  In this case, we're testing Angularjs code.  We don't want our event broadcast to actually happen because we don't care about testing the listeners to that event.  We just want to know that the broadcast happens.  We can test listeners separately in their own unit test.</p>

<p>I found that following the "Getting Started" example on the Sinonjs page didn't lead me to create a spy that worked.  I went spelunking and found a working example on a random tech blog (a la this one).  So, here's this advice:</p>

<ul>
<li><code>sinon.spy</code> api takes the object with the function as a 1st parameter and the string name of the function that you're wanting to spy on as the 2nd parameter.</li>
<li><code>sinon.spy</code> will return a reference to the spy.  You can use that reference to do assertions on or you can use the spied on function itself (ie, <code>$rootScope.$broadcast</code>)</li>
<li>Use <a href="https://github.com/domenic/sinon-chai"><code>sinon-chai</code></a>.  It provides better assertions and works with <code>chai</code>.</li>
</ul>


<p>```coffeescript model.spec.coffee
assert = chai.assert
expect = chai.expect
should = chai.should()</p>

<p>model = null
$rootScope = null
$httpBackend = null</p>

<p>beforeEach module 'app'</p>

<p>beforeEach inject (<em>Model</em>, <em>$rootScope</em>, <em>$httpBackend</em>) ->
  model = new <em>Model</em>
  $rootScope = <em>$rootScope</em>
  $httpBackend = <em>$httpBackend</em></p>

<p>it 'broadcasts model:fetched event w/ model', ->
  spy = sinon.spy($rootScope, '$broadcast')
  model.fetch()
  $httpBackend.flush()
  spy.should.have.been.calledWith 'model:fetched', model
```</p>

<p>Most of that code is setup.  And most of that setup is related to <a href="http://angularjs.org/">Angularjs</a>.  If that doesn't apply to you, ignore it.  It's just there to give a more full picture of the environment.</p>

<p>The interesting part is all in the final <code>it</code> function call.  The code under test is <code>model.fetch()</code>, which is called.  Internal to that function, there is a <code>$rootScope.$broadcast</code> call that we're spying on that we're asserting is called with 2 parameters: 'model:fetched' string and the model itself.</p>

<p>As with most testing environments, it's fairly simple once you discover the pattern.  What do you think of this one?  Does it work for you?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Disable ngClick]]></title>
    <link href="http://jaketrent.com/post/disable-ng-click/"/>
    <updated>2013-08-14T07:53:00-06:00</updated>
    <id>http://jaketrent.com/post/disable-ng-click</id>
    <content type="html"><![CDATA[<p>Angular's ngClicks can be attached to anything.  This makes it easy to add interactivity to elements on the DOM.  Your program might require that these click callbacks be disabled at certain points, such as during form processing.  ngClick doesn't have a toggle built in.  Let's build one that might help.</p>

<p><img src="http://i.imgur.com/wVBKD.png" alt="Angularjs" /></p>

<!--more-->


<p>In our app we're going to track the state of the UI via various events that get passed in scope.  We slap our directive as an attribute on an element and it will respond by disabling or enabling on certain events.  Here's the directive:</p>

<p>```coffeescript disable-toggle.coffee
angular.module('app.directives').directive 'disableToggle', ->
  restrict: 'A'
  replace: false
  link: (scope, element, attrs) -></p>

<pre><code>defaultDisableEvt = 'click:disable'
defaultEnableEvt = 'click:enable'

disableEvt = attrs.disableEvt || defaultDisableEvt
enableEvt = attrs.enableEvt || defaultEnableEvt

disableEvts = disableEvt.split(/\ *?,\ *?/)
enableEvts = enableEvt.split(/\ *?,\ *?/)

for evt in disableEvts
  scope.$on evt, (evt) -&gt;
    element.attr 'disabled', 'disabled'
    element.addClass 'is-disabled'
    scope.disabledToggled = true

for evt in enableEvts
  scope.$on evt, (evt) -&gt;
    element.removeAttr 'disabled'
    element.removeClass 'is-disabled'
    scope.disabledToggled = false
</code></pre>

<p>```</p>

<p>The directive allows for listening on multiple events.  This is useful if your button should be disabled/enabled via multiple events.  Just separate your event list with commas.  If you don't want to specify any events, the directive uses two default events, 'click:disable' and 'click:enable'.</p>

<p>The directive sets the <code>disabled</code> attribute, commonly used in form fields.  It also sets the <code>is-disabled</code> class so your app can style this state consistently in the UI.</p>

<p>Lastly, the directive also sets a <code>scope.disabledToggled</code> variable on the scope of the element.  This will be useful for elements which are not form elements and which do not prevent clicking just because their <code>disabled</code> attribute is set to <code>disabled</code>.  Instead, we'll use this value to short-circuit the <code>ng-click</code> event itself.</p>

<p>So here it is in action on the template:</p>

<p>```html
  &lt;button ng-click="disabledToggled || doClickyThings()"</p>

<pre><code>      disable-toggle enable-evt="click:enable,photo:clear" disable-evt="photo:add"&gt;Click Me&lt;/button&gt;
</code></pre>

<p>```</p>

<p>Here, we're setting custom events for disabling and enabling the button.  And note the <code>ng-click</code> value.  The <code>doClickyThings()</code> function will not get called if <code>disabledToggled</code> is true.</p>

<p>So, what do you think.  Is there an easier way to get this kind of functionality?  What could we do to make it better?</p>
]]></content>
  </entry>
  
</feed>
