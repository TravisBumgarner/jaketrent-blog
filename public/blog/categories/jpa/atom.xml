<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jpa | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/jpa/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-05-20T09:33:33-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hibernate Bind Variable in OrderBy Clause]]></title>
    <link href="http://jaketrent.com/post/hibernate-bind-variable-orderby-clause/"/>
    <updated>2009-08-24T13:29:00-06:00</updated>
    <id>http://jaketrent.com/post/hibernate-bind-variable-orderby-clause</id>
    <content type="html"><![CDATA[<p>I have spent mucho time trying to get some named parameters working in the "order by" clause of a dynamic sql query that I'm building.  The query isn't even HQL/JPQL.  It's native.  And yet, it turns out that you cannot use bind variables, named or ordered, in an order by clause.</p>

<!--more-->


<p>I was trying to do something like this:</p>

<p>```java
public class Service {
   @PersistenceContext
   private EntityManager em;</p>

<p>   public List&lt;Object[]> search(String sortProperty) {</p>

<pre><code>  Query q = em.createNativeQuery("select col from table order by :sortProperty");
  q.setParameter("sortProperty", sortProperty);
  return q.getResultList();   
</code></pre>

<p>   }
}
```</p>

<p>This will yield something awesome, like this:</p>

<p><code>java
java.sql.SQLException: ORA-01745: invalid host/bind variable name
</code></p>

<p>Seriously, the only way I've found around this is append, similar to this:</p>

<p><code>java
/* ... */
Query q = em.createNativeQuery("select col from table order by " + sortProperty);
/* ... */
</code></p>

<p>Just make sure you've got something scrubbing the data coming in.</p>

<p>Any better suggestions?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inner Joins in JPQL Delete Statements ]]></title>
    <link href="http://jaketrent.com/post/inner-joins-jpql-delete-statements/"/>
    <updated>2009-04-29T11:46:00-06:00</updated>
    <id>http://jaketrent.com/post/inner-joins-jpql-delete-statements</id>
    <content type="html"><![CDATA[<p>I'm working on a project that utilizes JPA/Hibernate as its ORM.  I was writing a few named queries for an JPQL/HQL delete and was getting an SQLGrammarException.  I soon found out that I couldn't use inner joins on a delete statement, even at the SQL level.  Here's the query transformation:</p>

<!--more-->


<p>I originally had this query:</p>

<p>```java
@NamedQuery(name = Queue.REMOVE_ROWS_OF_EARLY_RELEASE_REASON,
   query = "delete from Queue q " +</p>

<pre><code>       "where  q.enabledMember = :enabledMember " +
       "and    q.letter.eventReason.event.type = :eventType " +
       "and    q.letter.eventReason.reason = :reason ")
</code></pre>

<p>```</p>

<p>It had to evolve to this:</p>

<p>```java
@NamedQuery(name = Queue.REMOVE_ROWS_OF_EARLY_RELEASE_REASON,
   query = "delete from Queue q " +</p>

<pre><code>       "where q in (select sq from Queue sq " +
       "            where  sq.enabledMember = :enabledMember " +
       "            and    sq.letter.eventReason.event.type = :eventType " +
       "            and    sq.letter.eventReason.reason = :reason )"
</code></pre>

<p>```</p>

<p>The only solution that I could think of in order to keep the filter that I need was to use a subquery.  Anyone know of any other awesome solutions?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hibernate's @Enumerated Annotation is Brittle]]></title>
    <link href="http://jaketrent.com/post/hibernates-enumerated-annotation-brittle/"/>
    <updated>2009-02-23T08:27:00-07:00</updated>
    <id>http://jaketrent.com/post/hibernates-enumerated-annotation-brittle</id>
    <content type="html"><![CDATA[<p>Hibernate's @Enumerated annotation seems much too brittle in the case of using it with EnumType.ORDINAL.   If you're using EnumType.STRING, I think it works beautifully.  This is because the annotation can use the name of the enum to make the mapping.  In the case of ORDINAL, the value of the enum is used.  This presents a couple problems...</p>

<!--more-->


<ol>
<li>The enumeration has a 0th value place, so you need a PLACEHOLDER in your enum.</li>
<li>The enumeration values are contiguous, so your primary keys on the corresponding lookup table in the database must be as well.</li>
</ol>


<p>The second point is the one that seems most problematic.  If a lookup value becomes obsolete, it cannot be deleted.  If a sequence is used to generate the primary key value in the lookup table, it cannot skip a number without needing to put in extra placeholders equal to the amount of numbers skipped.</p>

<p>At least for me in my solution, to get around this problem I am putting the ENUM_NAME's in the database and in my mapping relating the table, replacing @Enumerated(EnumType.ORDINAL) and then using EnumType.STRING on the Entity representing the lookup table in order to link to my enum.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hibernate Boolean Conversion]]></title>
    <link href="http://jaketrent.com/post/hibernate-boolean-conversion/"/>
    <updated>2008-10-09T14:14:00-06:00</updated>
    <id>http://jaketrent.com/post/hibernate-boolean-conversion</id>
    <content type="html"><![CDATA[<p>The object-relational mapping world of JPA and Hibernate has made a lot of things really nice and easy.  As with any framework of this sort, however, it becomes frustrating when the pieces that are supposed to provide magic ease of development do not work as expected.  The frustration is only exacerbated when the docs are skimpy.</p>

<p>Type conversions usually happen automatically in JPA, but possibly due to some databases incredibly not having implemented boolean fields yet (Oracle and pre-5.0 MySQL), an extra bit of help in conversion is needed.</p>

<!--more-->


<p>The object-relational mapping world of JPA and Hibernate has made a lot of things really nice and easy.  As with any framework of this sort, however, it becomes frustrating when the pieces that are supposed to provide magic ease of development do not work as expected.  The frustration is only exacerbated when the docs are skimpy.</p>

<p>Type conversions usually happen automatically in JPA, but possibly due to some databases incredibly not having implemented boolean fields yet (Oracle and pre-5.0 MySQL), an extra bit of help in conversion is needed.</p>

<p>The mechanism for showing that a conversion will need to be manually specified is this annotation:</p>

<p><code>java
@Type(type="[type here]")
private Boolean active;
</code></p>

<p>In your database, if you store your boolean values as 'Y' or 'N', then you will want to use this:</p>

<p><code>java
@Type(type="yes_no")
private Boolean active;
</code></p>

<p>In your database, if you store your boolean values as '1' or '0', then you will want to use this:</p>

<p><code>java
@Type(type="boolean")
private Boolean active;
</code></p>

<p>In your database, if you store your boolean values as 'T or 'F', then you will want to use this:</p>

<p><code>java
@Type(type="true_false")
private Boolean active;
</code></p>

<p>Note that these solutions are Hibernate-dependent, and not sticking with the general standard of JPA.  Too bad JPA doesn't provide something like this (as of now, anyway)!</p>

<p>After much searching, I found this <a href="http://www.hibernate.org/hib_docs/reference/en/html/mapping-types.html">doc</a> that you may find useful.</p>

<p>If you want a Java logic-specific (but more portable) solution, you could try this:</p>

<p>```java
@Basic
private Character active;</p>

<p>public Boolean getActive() {</p>

<pre><code>if (active == null) return null;
return active == 'Y' ? Boolean.TRUE : Boolean.FALSE;
</code></pre>

<p>}</p>

<p>public void setActive(Boolean active) {</p>

<pre><code>if (active == null) {
  this.active = null;
} else {
  this.active = active == true ? 'Y' : 'N';
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
