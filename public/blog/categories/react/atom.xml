<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/react/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2015-07-27T08:46:14-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using JavaScript's Function Bind]]></title>
    <link href="http://jaketrent.com/post/using-javascript-function-bind/"/>
    <updated>2015-06-26T07:51:00-06:00</updated>
    <id>http://jaketrent.com/post/using-javascript-function-bind</id>
    <content type="html"><![CDATA[<p>JavaScript's Function object has a very helpful method, <code>bind</code>.  It is a great tool to give you control of the ever-squirrely <code>this</code> keyword.  Have you ever had trouble predicting what <code>this</code> will be or making equate to what you want?  <code>bind</code> will help you do that with more power and consistency.  It can also help you with partial function application.</p>

<p><img src="http://i.imgur.com/4huM3Xb.jpg" alt="function bind" /></p>

<!--more-->


<h2>The <code>this</code> Keyword</h2>

<p>In JavaScript, what the <code>this</code> keyword refers to changes often.  This can be useful but also unexpected.  Generally <code>this</code>, used within a function, will refer to the context in which that function was called. That calling context might be the global context of <code>window</code> if an event callback is being called in a browser.  That calling context might be an object that contains the function.  For more specific cases, MDN has some <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">great docs on the variety of contexts referred to by <code>this</code></a>.</p>

<h2>Controlling <code>this</code> with <code>bind</code></h2>

<p>When writing code, I often am thinking of <code>this</code> in the context in which I'm writing.  In other words, if I'm writing an object and use the keyword <code>this</code> in a function, I would normally expect <code>this</code> to refer to the object in which I <em>declared</em> the function.  But, again, it is actually the <em>calling</em> context that actually determines the value of <code>this</code>.</p>

<p>To change this default behavior, I can pre-bind the function's value of <code>this</code> to a value of my choosing.  This will happen at the time of <em>declaration</em>, which is what I more naturally would expect.</p>

<p>For example, in <a href="http://facebook.github.io/react/">React</a> we write UI components.  In interesting UIs, we're often handling events like those that occur with user interaction.  Normally events in the browser are attached to the DOM and are executed in the context of the <code>window</code>.  This being the case, it'll be hard for us to create an event handler function in our React Component that can refer back to anything of use in the React Component itself.</p>

<p>As a simple example, we'll write a <code>handleClick</code> function that wants to call the Component's <code>doLog</code> function for interesting logging:</p>

<p>```js event-handling.js
class MyComponent extends React.Component {
  doLog() {</p>

<pre><code>console.log('Yay, you clicked!')
</code></pre>

<p>  }
  handleClick() {</p>

<pre><code>console.log('this is window?', 
            this == window)
console.log('this is component?',
           this.constructor.name == 'MyComponent')
this.doLog()
</code></pre>

<p>  }
  render() {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;h1&gt;Time to start clicking&lt;/h1&gt;
    &lt;button onClick={this.handleClick}&gt;So, click&lt;/button&gt;
  &lt;/div&gt;
)
</code></pre>

<p>  }
}</p>

<p>React.render(<MyComponent />, document.getElementById('app'))
```</p>

<p><a href="http://jsbin.com/lixayanoso/edit?js,console,output">jsbin of broken state</a></p>

<p>If you click the button, <code>this.doLog</code> is not available as a function.  How could it be?  <code>doLog</code> is defined in <code>MyComponent</code>, not the <code>window</code>, which is the original context in which the event callback is executed.</p>

<p>To fix this, one need only pre-bind the <code>handleClick</code> function.  By changing one line, we can fix this:</p>

<p><code>js
&lt;button onClick={this.handleClick.bind(this)}&gt;So, click&lt;/button&gt;
</code></p>

<p>When this line is executed, it's in the <code>MyComponent#render</code> function, thus the <code>MyComponent</code> context.  So <code>this</code>, at that moment, is <code>MyComponent</code>.</p>

<p>The other detail that makes this work is that <code>bind</code> returns a <em>brand new function</em>.  That's how the pre-binding works.  So, the <code>onClick</code> prop that gets given to the <code>button</code> is a new function where we have said we want to permanently control the value of <code>this</code> to be whatever we bound it to.</p>

<p><a href="http://jsbin.com/luwoxegopu/edit?js,console,output">jsbin of fixed state</a></p>

<h2>Passing Specific Arguments with <code>bind</code></h2>

<p>Another great reason to use <code>bind</code> is to pass specific arguments to a function.  Just as <code>bind</code> can create new functions where the value of <code>this</code> is pre-determined (bound), <code>bind</code> can pre-fill (ie, partially apply) function arguments on the newly-created function.</p>

<p>It may not be immediately intuitive why one would want to create a function with parameters just to turn around and permanently make it so an argument to the function equals a specific value.  It almost feels like hard-coding a wart-ridden value on something that was previously dynamic and beautiful.  Perhaps an example will help.</p>

<p>Again, to the world of React...  As in the previous example, we'll pass an event handler for a click event.  Notice, just as above, that we're passing the function itself (<code>this.handleClick</code> above) instead of the return value of the function (which would look like <code>this.handleClick()</code>).  In this example, we'll have several click handlers, each on a list item, where the button will function as a remove button:</p>

<p>```js
class Item extends React.Component {
  render() {</p>

<pre><code>return (
  &lt;li&gt;
    {this.props.text}
    &lt;button onClick={this.props.onRemove}&gt;Rm&lt;/button&gt;
  &lt;/li&gt;
)
</code></pre>

<p>  }
}</p>

<p>class List extends React.Component {
  constructor(props) {</p>

<pre><code>super(props)
this.state = { items: this.props.initalItems }
</code></pre>

<p>  }
  handleClickRemove(index) {</p>

<pre><code>var clonedItems = this.state.items.slice()
clonedItems.splice(index, 1)
this.setState({ items: clonedItems })
</code></pre>

<p>  }
  render() {</p>

<pre><code>return (
  &lt;ul&gt;
    {this.state.items.map((item, i) =&gt; {
      return &lt;Item text={item} onRemove={this.handleClickRemove.bind(this, i)} key={item} /&gt;
    })}
  &lt;/ul&gt;
)
</code></pre>

<p>  }
}</p>

<p>React.render(<List initalItems={['Do', 'More', 'Reakt']} />, document.getElementById('app'))
```</p>

<p><a href="http://jsbin.com/cinovebasu/edit?js,console,output">A working jsbin</a></p>

<p>In <code>List</code>, we have the event handler, the <code>handleClickRemove</code> function, that takes an <code>index</code> parameter.  In order to make this function work as defined, we are using <code>bind</code> on this line:</p>

<p><code>js
return &lt;Item text={item} onRemove={this.handleClickRemove.bind(this, i)} key={item} /&gt;
</code></p>

<p>This <code>bind</code> call is doing a few things for us:</p>

<ol>
<li>Pre-binding <code>handleClickRemove</code> to the <code>List</code> Component so that <code>this.setState</code> works inside the callback.</li>
<li>Creating a new function that always has <code>i</code> as its first parameter.  Since this line is executed in a loop, <code>i</code> changes.  It will be <code>0</code> for the first item, <code>1</code>, then <code>2</code>.  This is perfect, as we want the first remove button to remove the first item, and so on.</li>
</ol>


<p>Isn't that awesome and useful?</p>

<p>So <code>bind</code> can help make <code>this</code> more predictable for you.  It will help you send new functions with pre-filled parameters.  What else have you used <code>bind</code> for?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing React on jsdom]]></title>
    <link href="http://jaketrent.com/post/testing-react-with-jsdom/"/>
    <updated>2015-06-18T07:13:00-06:00</updated>
    <id>http://jaketrent.com/post/testing-react-with-jsdom</id>
    <content type="html"><![CDATA[<p>React allows you to create components that will render UI for your application.  If your UI is of any complexity, you'll likely want to test that it functions correctly and allows for future refactors.  There are numerous ways to do this.  One way that you might appreciate is using <a href="https://github.com/tmpvar/jsdom">jsdom</a>, an in-JavaScript implementation of the DOM.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react on jsdom" /></p>

<!--more-->


<h2>What is jsdom?</h2>

<p>Jsdom is an in-JavaScript implementation of the DOM.  The DOM is the document object model, which is the tree of nodes that make up the UI for documents shown in web browsers.</p>

<p>Because jsdom is implemented in JavaScript, we can have a DOM-like API to work with without needing a browser.  That means that we don't have to capture a browser in order test, a la <a href="http://karma-runner.github.io/">Karma</a>.  That means that we can run our tests in environments without browsers, like in Node or in continuous integration environments.</p>

<p>By not using real browsers, we're also essentially saying that we believe the problems in our client JavaScript will not be browser-dependent (again, because we're not capturing <em>real</em> browsers).</p>

<h2>jsdom Requirements</h2>

<p>The <a href="https://github.com/tmpvar/jsdom">latest version of jsdom</a>, as of this writing, requires <a href="https://iojs.org/en/index.html">io.js</a> instead of Node to run.  If you'd like to run in Node.js instead, the <a href="https://github.com/tmpvar/jsdom/tree/3.x">3.x series of jsdom</a> is required.</p>

<p>As <a href="http://thenextweb.com/dd/2015/06/16/node-js-and-io-js-are-settling-their-differences-merging-back-together/">Node and io.js merge in the future</a>, I expect the new versions of jsdom to support the one, unified platform.</p>

<h2>The Test Runner</h2>

<p>In my JavaScript tests, I prefer to use the <a href="http://mochajs.org/">Mocha</a> test runner.  It's usable in Node or browser environments.  It has great async test support.  It has the familiar behavior-style syntax of <code>describe</code> and <code>it</code> and all the normal test setup hooks that you like.  Most importantly, it features the Nyan cat test reporter:</p>

<p><img src="http://mochajs.org/images/reporter-nyan.png" alt="nyan cat test reporter" /></p>

<p>Mocha lets you choose your own assertion library.  I like <a href="http://shouldjs.github.io/">should.js</a>.</p>

<p>To install both:</p>

<p><code>
npm install mocha should --save-dev
</code></p>

<h2>Configuring Mocha</h2>

<p>By default, Mocha wants a <code>/test</code> directory in your project root in which to put its configuration and potentially your spec files, depending on how you like to organize your projects:</p>

<p><code>
mkdir test
</code></p>

<p>Inside of the <code>/test</code> dir, let's <code>vim mocha.opts</code> and give it a place to configure jsdom and our other libs:</p>

<p><code>text mocha.opts
--require test/utils/dom.js
--require should
--reporter nyan
</code></p>

<p>We have yet to write the <code>test/utils/dom.js</code> file.  We will.  This file includes options for mocha.  Line by line, we're saying that before mocha runs tests, we want to load our <code>dom.js</code> config, the <code>should.js</code> library, and specify our reporter as <code>nyan</code>.</p>

<h2>Configuring jsdom</h2>

<p>I've tried to come up with several configurations that will make jsdom work well with my React projects.  This is the best/simplest that I've come up with.  I'd be interested to hear if you have any suggestions on the approach.</p>

<p>Here's the full configuration with explanatory comments inline, as it would appear in <code>test/utils/dom.js</code>:</p>

<p>```js dom.js
var jsdom = require('jsdom')</p>

<p>// setup the simplest document possible
var doc = jsdom.jsdom('&lt;!doctype html><html><body></body></html>')</p>

<p>// get the window object out of the document
var win = doc.defaultView</p>

<p>// set globals for mocha that make access to document and window feel
// natural in the test environment
global.document = doc
global.window = win</p>

<p>// take all properties of the window object and also attach it to the
// mocha global object
propagateToGlobal(win)</p>

<p>// from mocha-jsdom https://github.com/rstacruz/mocha-jsdom/blob/master/index.js#L80
function propagateToGlobal (window) {
  for (let key in window) {</p>

<pre><code>if (!window.hasOwnProperty(key)) continue
if (key in global) continue

global[key] = window[key]
</code></pre>

<p>  }
}
```</p>

<p>The reason that we want to attach all the <code>window</code> properties to the mocha <code>global</code> object is because developers often write code that is meant for the browser without explicitly using the global environment object.  For instance, in React the developers write:</p>

<p><code>js
navigator.userAgent.indexOf('Chrome') &gt; -1
</code></p>

<p>instead of:</p>

<p><code>js
window.navigator.userAgent.indexOf('Chrome') &gt; -1
</code></p>

<p>Withing taking <code>window.navigator</code> and putting it on <code>global.navigator</code>, you'd get an error like this when running your tests:</p>

<p><code>
ReferenceError: navigator is not defined
</code></p>

<h2>The React Test</h2>

<p>You are now ready to render React components into a document in your tests.  The document will be provided by jsdom.  You don't need a browser environment to run this.</p>

<p>```js mycomponent.spec.js
var React = require('react/addons')
var should = require('should')
var TestUtils = React.addons.TestUtils
var MyComponent = // a React.Component with a <button/> ...
describe('MyComponent', function () {
  it('has button that fires a dom event for click', function (done) {</p>

<pre><code>function handleClick() { done() }
var detachedComp = TestUtils.renderIntoDocument(&lt;MyComponent onClick={handleClick}/&gt;)
var button = TestUtils.findRenderedDOMComponentWithTag(detachedComp, 'button')
var buttonNode = React.findDOMNode(button)
should.exist(buttonNode)
TestUtils.Simulate.click(buttonNode)
</code></pre>

<p>  })
})
```</p>

<p>To run mocha with the configuration above, I like to add an npm script in <code>package.json</code>:</p>

<p>```json package.json
{
   "scripts": {</p>

<pre><code> "test": "mocha test/**/*.spec.js"
</code></pre>

<p>   }
}
```</p>

<p>And then type:</p>

<p><code>bash
npm test
</code></p>

<p>Write the source to satisfy your test, and the lights should go green.  Your DOM is happy.  Your test is happy.</p>

<p>Does it work well for you?  How might you improve on it?  Enjoy testing!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test React componentWillReceiveProps]]></title>
    <link href="http://jaketrent.com/post/test-react-componentwillreceiveprops/"/>
    <updated>2015-02-26T08:34:00-07:00</updated>
    <id>http://jaketrent.com/post/test-react-componentwillreceiveprops</id>
    <content type="html"><![CDATA[<p>Testing React Components has been easier and more enjoyable than any previous UI unit testing I've done in the past.  Components that have interesting things happen in lifecycle methods have a little more setup to get tested.  Components that use the <code>componentWillReceiveProps</code> method are in this category.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react" /></p>

<!--more-->


<h2>React Test Setup</h2>

<p>Not all lifecycle methods require as much setup in a test as <code>componentWillReceiveProps</code>.  This is because:</p>

<ul>
<li>This method is concerned with <strong><em>changing</em></strong> props.</li>
<li>Changing props directly on a React Component (even under test) is against the React code of conduct</li>
</ul>


<p>So, we need something that is legal to change... <code>state</code>!  We need to not modify our subject under test and simply pass it new <code>props</code>.</p>

<p>My solution is to create a React Component specifically for the test.  This Component will be a parent to the subject under test, on which we can set <code>state</code>.  We'll design it so that this state is transferred to the child Component under test.</p>

<h2>React Component using <code>componentWillReceiveProps</code></h2>

<p>You might have a React Component to test that looks like this:</p>

<p>```js
var ComponentToTest = React.createClass({
  getInitialProps() {</p>

<pre><code>return {
  myProp: "blank"
};
</code></pre>

<p>  },
  getInitialState() {</p>

<pre><code>return {
  modified: "still blank"
};
</code></pre>

<p>  },
  componentWillReceiveProps(nextProps) {</p>

<pre><code>this.setState({
  modified: nextProps.myProp + "IsSoModified"
});
</code></pre>

<p>  },
  render() {</p>

<pre><code>return &lt;div class="displayed"&gt;{this.state.modified}&lt;/div&gt;
</code></pre>

<p>  }
});
```</p>

<p>There is nothing particularly interesting about this subject beyond the fact that it uses <code>componentWillReceiveProps</code>.  When new props are received, internal state is modified.  In real life, more interesting things like data fetching or complex calculations might be done here and then stored in state.  We simply are matching the scenario of needing to verify something when <code>componentWillReceiveProps</code> is called.</p>

<h2>A Parent Test Component</h2>

<p>The test to exercise <code>componentWillReceiveProps</code> on the above Component might look like this:</p>

<p>```js
var React = require("react/addons");
var TestUtils = React.addons.TestUtils;</p>

<p>it("displays a modified state upon changing props", function () {
  var TestParent = React.createFactory(React.createClass({</p>

<pre><code>getInitialState() {
  return { testState: "init" };
},
render() {
  return &lt;ComponentToTest ref="sot" myProp={this.state.testState} /&gt;
}
</code></pre>

<p>  }));</p>

<p>  var parent = TestUtils.renderIntoDocument(TestParent());
  parent.refs.sot.props.myProp.should.eql("init");</p>

<p>  parent.setState({</p>

<pre><code>testState: "somethingElse"
</code></pre>

<p>  });</p>

<p>  parent.refs.sot.props.myProp.should.eql("somethingElse");
  parent.refs.sot.state.modified.should.eql("somethingElseIsSoModified"); // assert #1
  var child = TestUtils.scryRenderedDOMComponentsWithClass(parent, "displayed")[0];
  child.getDOMNode().innerText.should.eql("somethingElseIsSoModified");  // assert #2
});
```</p>

<p>The <code>TestParent</code> component is created specifically for this test.  It renders the Component under test.  It sets a <code>ref</code> attribute to it for easy access.  Once we render the parent, the initial state was sent as the prop to the child Component.  As soon as we <code>setState</code> on the parent, a new prop is sent to the child, triggering <code>componentWillReceiveProps</code>.</p>

<p>Finally, I've included two assertion styles.  Again, there are going to be more interesting things that you're asserting here in real life.  In this case I'm verifying that state that renders directly to the UI is set in our lifecycle method.  I can interrogate the state directly.  Here, we reach into the child Component state for assertion method #1.  That may sound bad, but remember that <code>TestParent</code> was created only in the context of this test anyway, so the level we're reaching through to grab child state is just test code.  Assertion method #2 is to go to the DOM to verify final output from the state change.</p>

<p>There is definitely more setup here to make this happen.  I feel like usually testing a React Component doesn't require this much test code.</p>

<h2><code>componentWillReceiveProps</code> in Action</h2>

<p>Here is a Component that uses <code>componentWillReceiveProps</code> to make a simple display change:</p>

<p><a class="jsbin-embed" href="http://jsbin.com/munaxuguta/12/embed?js,output">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>You can also check out this <a href="http://jsbin.com/buwoqod/22/edit?js,output">slightly modified jsbin</a> which does the test assertion.</p>

<p>What methods have you used to test Components that use either <code>componentWillReceiveProps</code> or other interesting lifecycle methods?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test React-Router Previous Params for Component Update]]></title>
    <link href="http://jaketrent.com/post/test-react-router-params-component-update/"/>
    <updated>2015-02-09T15:39:00-07:00</updated>
    <id>http://jaketrent.com/post/test-react-router-params-component-update</id>
    <content type="html"><![CDATA[<p>Once upon a time, react-router transferred params and query params from the url via props into components.  It doesn't happen this way any more.  So, let's say you have a need in your component like overriding <code>shouldComponentUpdate</code> in your component which only has access to <code>this.props</code> and <code>this.state</code>.   How can you use the url data to affect the component re-render or not?</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react" /></p>

<!--more-->


<h2>Why control rendering with the url?</h2>

<p>There are two instances that come to mind when considering the scenarios that it might be needful to control the update of your component based on the url:</p>

<ol>
<li><p><strong>Avoid re-render</strong>: Of course, if the component we're talking about is a page-level component, you'll most likely always be wanting to re-render as the url changes.  But, if you're a little widget component that cares about the url, you might not need to always re-render on url change.</p></li>
<li><p><strong>Trigger re-render when it might not otherwise happen</strong>: For whatever reason, you may have already needed to implement <code>shouldComponentUpdate</code> in your component.  This function returns true or false to flag a "should" or "should not" re-render.  You'll need to access url state and likely previous url state in this method to make re-renders happen that otherwise wouldn't if you had no logic in this function for it.</p></li>
</ol>


<p>Of course, beyond these re-render scenarios, there are many other situations in which knowing previous and current states in the url could come in handy.</p>

<h2>React-Router in shouldComponentUpdate</h2>

<p><code>shouldComponentUpdate</code> determines if component should re-render.  It's called whenever <code>this.props</code> or <code>this.state</code> changes.  It has access to incoming props and state via the function parameters.</p>

<p>React-router gives your component access to params and query params by requiring you to mix in the <code>State</code> param from react-router.  Then you have access to new functions, <code>this.getParams()</code> and <code>this.getQuery()</code>.  If you only need to know current url state, this is enough.  If you want to compare current url state to previous url state, you'll have to save the parts that you care about.  We'll do that in <code>this.state</code>.</p>

<p>Let's say that we want to trigger a redraw on changes to a <code>range</code> query parameter.  The component might, in part, look like this:</p>

<p>```
var { State } = require('react-router')</p>

<p>module.exports = React.createClass({</p>

<p>  mixins: [ State ],</p>

<p>  getInitialState() {</p>

<pre><code>range: nul
</code></pre>

<p>  },</p>

<p>  componentWillReceiveProps() {</p>

<pre><code>this.setState({
  range: this.getQuery().range
})
</code></pre>

<p>  },</p>

<p>  componentWillMount() {</p>

<pre><code>this.setState({
  range: this.getQuery().range
})
</code></pre>

<p>  }</p>

<p>  shouldComponentUpdate() {</p>

<pre><code>return this.state.range !== nextState.range
</code></pre>

<p>  }</p>

<p>  // ...</p>

<p>})
```</p>

<p>When the url params change, <code>componentWillReceiveProps</code> is called.  But this is not called on the first render, thus we implement <code>componentWillMount</code>.  Both these functions save the <code>range</code> from the url to the component state.  Now, as <code>shouldComponentUpdate</code> is called on future <code>this.props</code> and <code>this.state</code> changes, current and next <code>range</code> values can be compared and used in "should re-render" calculation.</p>

<p>What other ways have you found to accomplish this tracking of previous state in the url?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-Router with Flux]]></title>
    <link href="http://jaketrent.com/post/react-router-with-flux/"/>
    <updated>2015-01-15T09:21:00-07:00</updated>
    <id>http://jaketrent.com/post/react-router-with-flux</id>
    <content type="html"><![CDATA[<p>react-router provides great route handling with route params and query params.  Flux provides a pattern for building React apps, including a pattern from providing data to your components.  Here's a straightforward way to make route changes trigger data changes in your components.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react" /></p>

<!--more-->


<p>Note: Code here reflects usage of react-router 0.11.x.</p>

<p>It is often the case that we'll need to trigger data changes in a react component in our Flux app because of a route transition.  A prime example of this would be on an object show page, where the details of a particular object are being shown.  In our example, let's say that we're showing the details of a book, such as title, author, and description.</p>

<p>The route to our book detail page is likely defined as:</p>

<p><code>js routes.js
// ...
&lt;Route name="book" path="/books/:id" handler={require('./books-show')} /&gt;
</code></p>

<p>The handler is just a controller-component that defines the view.  It might look simply like:</p>

<p>```js books-show.js
const React = require('react')
const {State} = require('react-router')</p>

<p>const BooksStore = require('./books-store')</p>

<p>module.exports = React.createClass({</p>

<p>  displayName: 'BooksShow',</p>

<p>  mixins: [ State ],</p>

<p>  getInitialState() {</p>

<pre><code>return this.getStateFromStores()
</code></pre>

<p>  },</p>

<p>  getStateFromStores() {</p>

<pre><code>return {
  book: BooksStore.find({ id: this.getParams().id })
}
</code></pre>

<p>  },</p>

<p>  componentDidMount() {</p>

<pre><code>BooksStore.addChangeListener(this._onChange)
</code></pre>

<p>  },</p>

<p>  componentWillUnmount() {</p>

<pre><code>BooksStore.removeChangeListener(this._onChange)
</code></pre>

<p>  },</p>

<p>  _onChange: function() {</p>

<pre><code>this.setState(this.getStateFromStores())
</code></pre>

<p>  },</p>

<p>  render() {</p>

<pre><code>return (
  &lt;ul&gt;
    &lt;li&gt;{this.state.book.title}&lt;/li&gt;
    &lt;li&gt;{this.state.book.author}&lt;/li&gt;
    &lt;li&gt;{this.state.book.description}&lt;/li&gt;
  &lt;/ul&gt;
)
</code></pre>

<p>  }</p>

<p>})
```</p>

<p>Note that the view component references a <code>BooksStore</code> for getting its initial state.  The state of <code>book</code> will also be updated as the <code>BooksStore</code> emits that its data has changed and <code>this._onChange</code> is called.</p>

<p>Every time a route transitions, react-router has a <code>Router.run</code> callback that will also run in order to render the matching route.  This will also be a great place to put our action to signal to our Flux app that routes are transitioning and therefore other stuff like data in the display might need to change as well.</p>

<p><code>js
Router.run(routes, (Handler, state) =&gt; {
  React.render(&lt;Handler /&gt;, document.body)
  BooksAction.transition(state.params)
})
</code></p>

<p><strong>Important note</strong>: Make sure the transition action is called after <code>React.render</code> so that the change emission will be detected after render, otherwise you'll be one route transition behind.</p>

<p>The <code>BooksAction.transition</code> definition is something very simple -- something that can trigger events on the dispatcher:</p>

<p>```js books-actions.js
exports.transition = () => {
  AppDispatcher.handleViewAction({</p>

<pre><code>type: ActionTypes.TRANSITION
</code></pre>

<p>  })
}
```</p>

<p>The final connection is in the store, where the dispatched action can be listened for an then trigger the store event, updating the component views:</p>

<p>```js books-store.js
var BooksStore = merge(EventEmitter.prototype, {
  find(filter) {</p>

<pre><code>// ...
</code></pre>

<p>  }
})</p>

<p>BooksStore.dispatchToken = AppDispatcher.register((payload) => {
  var action = payload.action
  switch(action.type) {</p>

<pre><code>// ...

case ActionTypes.TRANSITION:
  BooksStore.emitChange()
  break
</code></pre>

<p>  }
})</p>

<p>module.exports = BooksStore</p>

<p>```</p>

<p>At this point, all the route transitions should trigger data changes in views.  Visiting the url <code>/books/1</code> and then the url <code>/books/2</code> should display different data on screen according to which book id was in the route.  <code>Router.Link</code> should work correctly, usable instead of buttons with actions being triggered on click.</p>

<p>react-router and Flux make for a great combo in this way, right?  What adjustments would you make?</p>
]]></content>
  </entry>
  
</feed>
