<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/react/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2016-03-20T16:28:36-06:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Smart and Dumb Components in React]]></title>
    <link href="http://jaketrent.com/post/smart-dumb-components-react/"/>
    <updated>2016-02-17T08:55:00-07:00</updated>
    <id>http://jaketrent.com/post/smart-dumb-components-react</id>
    <content type="html"><![CDATA[<p>Dan Abramov coined the terms <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">Smart and Dumb components</a>.  Later, he called them Container and Presentational components.  I still call them Smart and Dumb.  It's shorter and sits in my mind easier.  How do you identify them?  Why would you want a separation?  What might that separation look like?  Here are a few ideas.</p>

<p><img src="http://i.imgur.com/9VKyXtu.png" alt="Smart and Dumb React components" /></p>

<!--more-->


<h2>Smart vs Dumb Components</h2>

<p>So what sets these components apart?  Smart means "container" or "app-level".  Some have compared it to the "C" in MVC.  Dumb means "presentational" or "ui only", possibly comparable to the "V" in MVC.  Here's a breakdown of a few key characteristics:</p>

<h3>Smart Component Characteristics</h3>

<ul>
<li>Describe <em>how things work</em></li>
<li>Provide no DOM markup or styles</li>
<li>Provide application data, do data fetching</li>
<li>Call Flux actions</li>
<li>Named *Container by convention</li>
</ul>


<h3>Dumb Component Characteristics</h3>

<ul>
<li>Describe <em>how things look</em></li>
<li>Have no app dependencies</li>
<li>Receive only props, providing data and callbacks</li>
<li>Rarely have own state, when they do, it's just UI state</li>
<li>Named anything that's a UI noun</li>
</ul>


<p>Apparently you need each class of components because obviously your app has to smart to be interesting.  But if it's more dumb, it's more simple.  So split it.  You need both.</p>

<p>If you separate concerns, your app will be easier to reason about, complexity will be mostly localized around the Smart components, and you should be left with more simple components.  UI components will be more reusable.</p>

<h2>Where to Split Smart and Dumb Components?</h2>

<p>If you keep all Smart characteristics on one side and the Dumb characteristics on the other, you will have made the separation and be following the guiding principles.</p>

<p>But how should you make that split?  Here are a couple ideas.  These are observations of how I've found myself making the split and what it ends up looking like.</p>

<h3>Deep Split</h3>

<p>"Deep" describes what I usually observe when I split components this way.  There's one Smart component that splits to one Dumb component.  There's a 1:1 relationship.  This seems simple, and it is in a way.  It probably works better if the components are small, because many of the smarts from the Smart component end up getting passed down to the Dumb component.  This makes for a lot of props on the Dumb component.</p>

<p>If the Dumb component does anything interesting, it usually will fan out at that point and start farming <code>props</code> off to the child components that actually need them.  Thus, the hierarchy deepens before it actually ends up doing work.</p>

<p><img src="http://i.imgur.com/scfodt6.png" alt="Deep component split" /></p>

<h3>Broad Split</h3>

<p>"Broad" describes the transition from Smart to Dumb happening sooner.  There is one Smart component that has many Dumb component children.  There aren't necessarily fewer interesting things here or props to pass, but they're scattered out, going straighter to the components that need them instead of going through some Monolith Proxy Dumb component (all the bad words together).</p>

<p><img src="http://i.imgur.com/hxusLJ2.png" alt="Broad component split" /></p>

<p>A highlight advantage here is that there is much readier access to the Smart component's smarts -- store data, event handlers, and actions.  You don't feel like you're passing props <em>through</em> components only to get them to the components that really use them.</p>

<p>A golden quote from Dan Abramov that highlights this is:</p>

<blockquote><p>When you notice that some components don’t use the props they receive but merely forward them down and you have to rewire all those intermediate components any time the children need more data, it’s a good time to introduce some container components.</p></blockquote>

<h2>Nodes as props</h2>

<p>In his quote, Dan recognizes the time to introduce container components.  In my mind, "container" means Smart.  Here, I don't think we necessarily require a Smart Container, because we usually like to get as Dumb as we can as fast as we can.  So, how about a Dumb component that just provides <em>containment</em>?</p>

<p>We can provide DOM markup, component grouping, layout, or other UI abstractions with components that take <code>props.children</code>.  These children are usually components, of type <code>React.PropTypes.node</code>.  Doubtless we've all realized by now that there's just one <code>props.children</code>.  But component can only wrap one thing, right?  Well, this is in the syntax of markup/JSX, but this isn't true <em>inside</em> the Component.  We could have more attributes that pass <code>PropTypes.node</code> arguments.  This allows for <em>containing more</em> nodes and having convenient handles on them within components.</p>

<p>This thought was revelatory at the time it occurred to me.  Looking back, it seems obvious.  But for some reason, probably because I still think of it as HTML sometimes, it feels funny to write something like:</p>

<p><code>js
&lt;Dumb aProp={&lt;AnotherDumb /&gt;} /&gt;
</code></p>

<p>Then inside the Dumb component, we can display those attributes directly:</p>

<p>```js
function Dumb(props) {
  return (</p>

<pre><code>&lt;div className={props.css.awesomeLayout}&gt;
  {props.aProp}
&lt;/div&gt;
</code></pre>

<p>  )
}
```</p>

<h2>What to Pass as Props?</h2>

<p>If we have a split we like, now we have to decide what <code>props</code> to send from the parent to the child components.</p>

<h3>Send Them All</h3>

<p><code>js
&lt;Dumb {...this.props} /&gt;
</code></p>

<p>Yes, you could just send all the parent's props to the child.  I would do this when the parent feels just like a wrapper.  It's a passthrough.  Perhaps it adds something small and targeted.  It's a higher-order component.</p>

<h3>Pass the Reducer/Selector</h3>

<p><code>js
&lt;Dumb reducerName={this.props.reducer} /&gt;
</code></p>

<p>You can pass the whole nested reducer state, sure.  Almost every time I feel myself wanting to do this, I think it's motivated by laziness.  It has a potential downside of tying the reducer format to the view in more places than required.  Of course, if you have custom selectors for everything anyway, you make your break from reducer format coupling there.</p>

<h3>Pass New Variables</h3>

<p><code>js
&lt;Dumb newVar={this.props.var} /&gt;
</code></p>

<p>This is most commonly what passing variables to children components looks like.  These values are usually primitives, but they can you can send down entire new object structures as well.  It has the advantages of being explicit and traceable.  It also avoids the coupling of passing entire nested reducers.</p>

<h2>Rule of Thumb</h2>

<p>In all design decisions, it's good to have some quick guidelines in mind when making decision.  So relative to splitting Smart and Dumb components, here's a rule of thumb.</p>

<p>On many of my projects recently, I use two decorators that help identify Smart and Dumb components:</p>

<p>For Smart, the <a href="https://www.npmjs.com/package/redux-react-connect-by-name">redux-react-connect-by-name</a> component facilitates data fetching from the redux store.  This is equivalent to using redux's vanilla <code>connect</code> with some built-in niceties.</p>

<p>For Dumb, the <a href="http://npmjs.com/react-styleable">react-styleable</a> component allows passing CSS modules into React components.  This is how I like to give my components styling information.</p>

<p>If one is for Smart and the other for Dumb, then I can usually identify a potential split if I ever see them <em>together</em>.  For example, this is what that antipattern might look like:</p>

<p>```js
import connect from 'redux-react-connect-by-name'
import styleable from 'react-styleable'
// ...</p>

<p>@connect([someSelector])
@styleable(someCss)
class MyComponent extends React.Component {
  // ...
}
```</p>

<p>Split that up!</p>

<h2>This Isn't Dogma</h2>

<p>The idea of Smart vs. Dumb components is, itself, just a guideline -- a Pirates' Code-level of guideline.  Keep it and use it where it helps your project.  This is an art form.  No one has the best answer for how to organize your React views.  Do the best you can.  Then, next week, when you find a better way, advance to that.</p>

<p>What are some other observations that you've made when splitting your views into Smart and Dumb components?</p>

<p><em>Adapted from a meetup talk:</em></p>

<script async class="speakerdeck-embed" data-id="26cce4743e5540b48188a35f49de3c4d" data-ratio="1.33333333333333" src="http://jaketrent.com//speakerdeck.com/assets/embed.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What React Stateless Components are Missing]]></title>
    <link href="http://jaketrent.com/post/react-stateless-components-missing/"/>
    <updated>2016-01-04T12:59:00-07:00</updated>
    <id>http://jaketrent.com/post/react-stateless-components-missing</id>
    <content type="html"><![CDATA[<p>Stateless React components got a new syntax in React 0.14.  It's much simpler.  It's just a function call.  Besides it just looking simpler, there are some major differences in what is available in a stateless component written this way.  There are some things missing -- purposefully not included -- that you may be used to.  Let's look at a few things.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="http://i.imgur.com/DXuSNbw.png" /></p>

<!--more-->


<p>Stateless components are now specifically not just components where you don't use <code>this.state</code>.  They're componets that are written in the form of a function:</p>

<p><code>js
function Chips(props) {
  return &lt;div&gt;In the secret {props.place}&lt;/div&gt;
}
</code></p>

<p>The observations made in this article will not apply to components that are created using the <code>class Chips extends React.Component</code> or <code>React.createClass</code> syntax, whether they use state or not.</p>

<h2>No Backing Instance</h2>

<p>A React component's backing instance is the object in memory that represents the node in the view.  This backing instance is the place where state is usually stored (using React's <code>this.state</code>).  Well now there's no <code>this</code> in stateless components.  Thus, there's not going to be a place for <code>this.state</code>.  Stateless, remember?  Data just passes through the pure function and into the resulting view.</p>

<h2>No Lifecycle Methods</h2>

<p>Because there's no backing instance as a place to put hooks for your code in the component lifecycle, you can not use any of the lifecycle methods from <code>React.Component</code>.  Methods such as <code>componentDidMount</code> and <code>componentWillReceiveProps</code> are out.  And since the stateless component is a pure function that just reproduces its view state on <code>props</code> change, why would you need lifecycle methods anyway?</p>

<h2>No Reference to the Component</h2>

<p>Often when testing, it's useful to get a reference to the component itself.  In the case of stateless components, they're just fired and forgotten, rendered into the view without the ability to get a handle on them.  They're just UI at this point, just in the DOM.  You can go to the DOM to do your testing.</p>

<p>Depending on your test environment setup, you may want to wrap your stateless components in a <code>class</code>-based component you <em>can</em> get a reference to.</p>

<p>Note that for stateless components, <code>ReactDOM.render</code> and <code>TestUtils.renderIntoDocument</code> will return <code>null</code>.</p>

<h2>No refs</h2>

<p>Stateless components can't be the target of a <code>ref</code>.  There's no backing instance.  You can't have <code>refs</code> internally to children either.  Remember, <code>this</code> and <code>this.refs</code> aren't around.  If your stateless component has a child that is a <code>class</code>-based component, <em>it</em> may have <code>refs</code>.  <a href="https://facebook.github.io/react/docs/more-about-refs.html">The docs</a> are another good reference on <code>refs</code>.</p>

<h2>No null Returns</h2>

<p>A <code>class</code>-based component may return <code>null</code> as its value in the view.  But a stateless component may not.  To get around this, return <code>&lt;noscript&gt;&lt;/noscript&gt;</code>.  This will be fully invisible in the view.</p>

<p>So what else have you found that is unavailable in stateless functions?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Update Body Class in React]]></title>
    <link href="http://jaketrent.com/post/update-body-class-react/"/>
    <updated>2015-09-23T15:31:00-06:00</updated>
    <id>http://jaketrent.com/post/update-body-class-react</id>
    <content type="html"><![CDATA[<p>React gives us a great component abstraction.  Each of these components represents a node in the DOM.  Each component is self contained, doesn't talk up the component hierarchy directly and passes explicit data and code down the hierarchy.  But what about when you have a React app that wants to reach out and modify something it doesn't control?</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="react modify body tag" /></p>

<!--more-->


<h2>A Couple Use Cases</h2>

<p>There are potentially a few use cases for this.  For instance, modals that need to render outside your application's potentially <code>position: relative</code> containers.  Or, as we'll see below, your app wants to modify the <code>body</code> tag in your html document.</p>

<p>The most common reason I've found for messing with the body tag is to provide some style attribute.  It's not uncommon to have full-page style differences between pages in our apps.  If you have a "single page" js app in the browser, you need to be able to modify the body tag in code.</p>

<p>Let's use an example where on some pages in your app, the theme is "dark", where the body background color should be black.  On other pages, the entire body background color should be the default white.  We'll make a component that lives high in the hierarchy and takes an <code>isDark</code> property to determine if the rendered page is dark or light.</p>

<h2>Body is Outside Your React App</h2>

<p>You can't mount your React app directly on <code>document.body</code>, at least without warnings.  This is considered bad practice, because other scripts or browser plugins often modify the document body directly.  So you'll have to reach <em>out</em> of your React app and modify the body directly.</p>

<h2>Tie Into the React Lifecycle</h2>

<p>First, you just need a point in time in your app's lifecycle where you know you want to modify the <code>body</code> class.  React has a bunch of <a href="https://facebook.github.io/react/docs/component-specs.html">lifecycle hooks</a> that will come in handy.  A great early-lifecycle hook for modifying the DOM is <code>componentDidMount</code>.  Usually, we would be accessing DOM nodes that are children of our Component.  Again, in this case, we're reaching out beyond where a React component usually should.  The usual <code>React.findDOMNode</code> functions will not be needed, because React isn't managing the body node.  Instead, we'll just use the <code>document.body</code> api directly.</p>

<h2>Use JavaScript to Modify the Class</h2>

<p>If you have some utility for modifying class names, use it.  If not, it's small and simple enough in <a href="http://jaketrent.com/post/addremove-classes-raw-javascript/">plain old JavaScript</a>.</p>

<p>With these two bits in hand, you have the pieces necessary for your body-modifying component:</p>

<p>```js
import React from 'react'</p>

<p>class BodyColor extends React.Component {
  static propTypes = {</p>

<pre><code>isDark: React.PropTypes.bool
</code></pre>

<p>  }
  static defaultProps = {</p>

<pre><code>isDark: false
</code></pre>

<p>  }
  componentDidMount() {</p>

<pre><code>document.body.classList.toggle('darkClass', this.props.isDark)
</code></pre>

<p>  }
  componentWillReceiveProps(nextProps) {</p>

<pre><code>document.body.classList.toggle('darkClass', nextProps.isDark)
</code></pre>

<p>  }
  componentWillUnmount() {</p>

<pre><code>document.body.classList.remove('darkClass')
</code></pre>

<p>  }
  render() {</p>

<pre><code>return this.props.children
</code></pre>

<p>  }
}
```</p>

<p>To use, pass an <code>isDark</code> attribute to activate the <code>darkClass</code> class on the body tag:</p>

<p><code>html
&lt;BodyColor isDark={true}&gt;
  &lt;h1&gt;A Very Dark App&lt;/h1&gt;
&lt;/BodyColor&gt;
</code></p>

<p>Are there any other ways you've found to reach out of React and modify the DOM directly.  What have been your use cases?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Rally Review]]></title>
    <link href="http://jaketrent.com/post/react-rally-review/"/>
    <updated>2015-08-27T09:03:00-06:00</updated>
    <id>http://jaketrent.com/post/react-rally-review</id>
    <content type="html"><![CDATA[<p>React Rally is a developer conference created around the library of <a href="http://facebook.github.io/react/">React.js</a> and the community that uses it.  It was the first of its name.  It was the first React-centric conference in Salt Lake City.  I had a great time.  Here are a few of reasons I liked it.</p>

<p><img src="http://i.imgur.com/B8fFS4J.jpg" alt="react rally" /></p>

<!--more-->


<h2>People Breakouts</h2>

<p>It was a happy conference.  A great mood was set by <a href="https://twitter.com/jergason">Jamison</a> on stage, who MC'ed most of the conference.  He's a fun, quirky guy who's not self-important and who did a great job putting speakers and the audience at ease.  There were a ton of participants and attendees at the conference that also fit this (good!) description.  This led to great conversation between sessions.  There were plenty of breaks, some 30 or 60 minutes at a time.  They were well-spaced, allowing plenty of time.  There was a pleasant <a href="http://rangle.io/">Rangle.io</a>-sponsored lounge to gather in.</p>

<p>There were no on-stage questions and answers portions at the end of the talks.  I wondered how I'd like this, since who doesn't like answer to their questions, right?  It turned out to be refreshing.  Speakers finished their talks at the appointed time.  No one had to wait around uncomfortably wondering when either the speaker or the audience would let everyone else off the hook.  No embarrassing questions.  It was nice.  All the speakers were great anyway, but I think this feature also helped prime the conversations that were expected to happen after the talks in the breakouts, giving extra motivation for everyone to be available and approachable.</p>

<h2>The Spoken Word</h2>

<p>I was excited going into the conference because of the solid lineup of speakers.  Not all the talks were the best I had heard or the best treatment of every subject.  There were some highlights thought, and on the whole it was really, really good.  Each of the speakers had obviously prepared a great deal and had taken their time on stage seriously (or not seriously in the case of <a href="https://twitter.com/djsmith42">Dave Smith</a>, whose talk was memorable and awesome as well, btw).</p>

<p>The conference wasn't wholly about React.  There's just so much <em>around</em> React that is exciting.  The community is pushing boundaries all over the place.  (And <em>still</em> all the content in the conference was appropriate, yay! :)  For instance, there were a great many mentions of <a href="http://elm-lang.org/">Elm</a>.  For my part, I spent much of the conference tinkering with that very thing.</p>

<h2>Fun Design</h2>

<p>It'll reveal how much art does for me, but when I first learned about the conference, one of the things that excited me the most was the <a href="http://www.reactrally.com/">website</a>.  It had a fun design!  There were illustrations, interesting colors, and it looked like a fun theme.  (Of course, at the time there was literally nothing else to be excited about outside the mailing list input box.)</p>

<p>We need more illustrations.  We need more mascots.  A menacing purple squid with a React symbol on its forehead?  Yes, please!  My previously bare brushed metal laptop lid is now bestickered with the sweetest conference stickers I have.  So fun!</p>

<p>I'm still not sure what the theme was intended to be.  My interpretation was Creatures of the Black Lagoon in Space.  Right?!</p>

<h2>Feels Like the First Time</h2>

<p>The organizers did a great job.  The preparation was obvious.  They assured me they were putting out fires for the duration of the two days.  That was not apparent.  The thing went off without a hitch.  I can only poke at the annoying AV glitch of a blinky project screen in some talks.</p>

<p>Everything seemed in its place.  The conference was small, about 250 participants, and it seemed like a large house party most of the time.  The venue was prepped very well.  I'm glad they opened up the downstairs lounge.  The food was great.  The breakfast trucks were a wonderful touch, especially <a href="http://saturdayswaffle.com/">Saturdays Waffles</a> day.  Mmmmm, waffles.  The gift card for lunch was a thoughtful touch.  <a href="http://www.yelp.com/biz/atlantic-caf%C3%A9-and-market-salt-lake-city-4">Atlantic Cafe</a> provided my delicious cevapi sausage on the 2nd day.</p>

<p>I have many thanks for the great speakers, the effort of the organizers, and everyone in between that made the 2 days great.  I felt inspired.  I left more informed.  I met a group of fantastic people.  It's been my favorite conference in Salt Lake City so far.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I Love CSS Modules]]></title>
    <link href="http://jaketrent.com/post/i-love-css-modules/"/>
    <updated>2015-08-25T11:03:00-06:00</updated>
    <id>http://jaketrent.com/post/i-love-css-modules</id>
    <content type="html"><![CDATA[<p>I heard a fantastic yesterday by <a href="https://twitter.com/glenmaddern">Glen Maddern</a> where Interoperable CSS was well-illustrated as the fantastic CSS language advancement that it is.  I was happy to hear hushed ooo's and ahh's from the audience as they realized the power of what they were seeing.  I have been enjoying the benefits of CSS modules myself and my team and would share some of my favorite features in hopes that others will be inclined to use this feature as well.  Cleanse the world of global stylesheets!</p>

<p><img src="http://i.imgur.com/MtjAduk.jpg" alt="i love css modules" /></p>

<!--more-->


<h2>Local Variables</h2>

<p>With CSS modules, your selector names are truly local.  They are FRD local variables!  They won't clash with any var names outside your module.  For You don't have to invent a giant namespace.  There's no BEM-style naming to describe a hierarchy.  There's no repetition in those names.  You can name it something much more simple, just related to what the component is.</p>

<p>For instance, if you're creating <code>Link</code> component, you'd previously have something like <code>.nav__item__link</code> selectors to apply style.  Knowledge of global markup structure would seep into your component through this selector and its name.  Now with a combination of encapsulated components and css modules,  you don't have to worry about the outside world.</p>

<p>Now, what would you call your <code>Link</code> component's outer-most <code>a</code> tag?  Well, maybe <code>.link</code> or <code>.root</code>...  Nothing fancy.  Just what it is.  You aren't required to think about the global stylesheet.  You can focus your mind on just the component stylesheet at hand.  The naming game, which can already be challenging, is made much easier.</p>

<h2>Explicit Dependencies</h2>

<p>Now that all the CSS you write is, by default, local to the module you write it in, you have to explicitly pull in dependencies.  You have to explicitly import the stylesheet you are writing where you'll eventually want to use it.  You can write styles without fear that it might influence something else -- until you explicitly ask it to!</p>

<h2>Still CSS</h2>

<p>I've tried some of the inlining styling techniques and libraries that are being made popular in the React community.  <a href="https://github.com/FormidableLabs/radium">Radium</a> is my favorite there.  What makes me happy about CSS modules is that they're still CSS.  It's a language that was invented in order to create declarative styles.  It's not wonderful in many ways, but it's still the best tool available for this.</p>

<p>You can use all the selectors, strategies, and css abilities you're used to.  Pseudo selectors are all available.  Media queries work as expected.  Keyframe animations are easy to declare.  There is also a great ecosystem of CSS enhancements and transforms available from the PostCSS community.  No one should ever write a vendor prefix again with <a href="https://github.com/postcss/autoprefixer">autoprefixer</a>.</p>

<h2>Consistency for Components</h2>

<p>Another thing I'd like to see in the web component community, specifically React for now, is a pattern around how to override CSS in reusable components.  This pattern would be well-used by component developers and well-known by component consumers.  This would help components be more immediately useful -- default styles could be included with components and custom styles would be easily applied.</p>

<p>My favorite solution to this so far is <a href="https://github.com/pluralsight/react-styleable">react-styleable</a> -- full disclosure, I helped write it.  (Anything like this that gains steam, has broad appeal, and is used by many will make me happy.)  I love that CSS modules enable this and provide a foundation for this consistency.  I'll likely write more about this in the future.</p>

<p>CSS modules have changed the styling game for me.  It makes it so, so much better.  Who knows, maybe it'll change the world.</p>

<p>So, how have CSS modules changed your life?  What do you love?  What could still be better?</p>
]]></content>
  </entry>
  
</feed>
