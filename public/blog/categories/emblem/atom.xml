<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: emblem | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/emblem/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2017-01-24T07:53:25-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Broccoli Ember Emblem]]></title>
    <link href="http://jaketrent.com/post/broccoli-ember-emblem/"/>
    <updated>2014-05-30T07:18:00-06:00</updated>
    <id>http://jaketrent.com/post/broccoli-ember-emblem</id>
    <content type="html"><![CDATA[<p>Make broccoli compile your emblem templates so they're ready for your ember app.</p>

<p><img src="http://i.imgur.com/85v8PQP.png" alt="Broccoli Ember Emblem" /></p>

<!--more-->


<h2>The Libraries</h2>

<p><a href="https://www.npmjs.org/package/broccoli">Broccoli</a> builds your assets quickly.  It makes heavy use of caching so it only has to rebuild affected subtrees when files change.  <a href="http://emblemjs.com/">Emblem</a> is a significant whitespace version of <a href="http://handlebarsjs.com/">Handlebars</a> templates, similar in style to <a href="http://slim-lang.com/">Slim</a> or <a href="http://jade-lang.com/">Jade</a>.  <a href="http://emberjs.com/">Ember</a> is a MVC framework for building browser apps.</p>

<p>Put them all together, and you have something that will help you compile your templates quickly for your browser app.  The <a href="https://github.com/jaketrent/broccoli-ember-emblem">broccoli-ember-emblem</a> plugin for Broccoli will do just that.</p>

<h2>Install</h2>

<p>To use the library, you'll need broccoli installed first.  Then, you'll install the plugin via npm:</p>

<p><code>
npm install --save-dev broccoli-ember-emblem
</code></p>

<h2>Usage</h2>

<p>You'll setup the plugin in your app's <code>Brocfile.js</code>.  That setup might look something like this:</p>

<p>```js
var emblem = require('broccoli-ember-emblem')
var mergeTrees = require('broccoli-merge-trees')
var pickFiles = require('broccoli-static-compiler')</p>

<p>function preprocess (tree) {
  tree = emblem(tree, {</p>

<pre><code>stripPathFromName: 'tmpl/'
</code></pre>

<p>  })
  return tree
}</p>

<p>var tmplTree = 'client/tmpl'
tmplTree = pickFiles(tmplTree, {
  srcDir: '/',
  destDir: '/tmpl'
})
tmplTree = preprocess(tmplTree)</p>

<p>module.exports = mergeTrees([ /<em> other trees, </em>/ tmplTree ])
```</p>

<p>Note a few things:</p>

<ul>
<li>I'm using another plugin, <code>broccoli-static-compiler</code> to move files around in the broccoli build directories.  This is to be able to identify separate trees that both use similar file filters (eg, *.js for both src scripts and templates).</li>
<li>I'm using the one option for the <code>broccoli-ember-emblem</code> plugin, <code>stripPathFromName</code>, which allows me to remove the path name from the template name in output.  For example, if I have a file at <code>tmpl/application.emblem</code>, I want the template name in ember to be <code>application</code>, not <code>tmpl/application</code>.</li>
<li>Final output is merged into a single tree via another plugin, <code>broccoli-merge-trees</code>.</li>
</ul>


<h2>Output</h2>

<p>Broccoli will take care of finding all of your template files.  It will use directories and filenames as the input for template names.  As a few examples, here is input and output as it might happen in the above configuration:</p>

<ul>
<li>File: <code>client/tmpl/application.emblem</code> becomes: <code>Ember.TEMPLATES['application']</code></li>
<li>File: <code>client/tmpl/components/song.emblem</code> becomes: <code>Ember.TEMPLATES['components/song']</code></li>
</ul>


<p>Notice that Ember requires all templates to be registered on the <code>Ember.TEMPLATES</code> object.  Later, at app runtime, they are looked up on that object by name.</p>

<p>So, use the plugin and win.  How does your template compilation for Ember/Emblem differ?  What other features do you wish were supported here?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember Parent Templates]]></title>
    <link href="http://jaketrent.com/post/ember-parent-templates/"/>
    <updated>2013-05-29T07:02:00-06:00</updated>
    <id>http://jaketrent.com/post/ember-parent-templates</id>
    <content type="html"><![CDATA[<p><a href="http://emberjs.com">Ember</a>'s convention of template hierarchy is very specific.  Learn it once, and you'll know it every time.</p>

<p><img src="http://i.imgur.com/x5HT4FN.jpg" alt="Ember and Handlebars" /></p>

<!--more-->


<p><strong>Note:</strong> Code examples use <a href="http://emblemjs.com/">Emblem</a> templates and <a href="http://coffeescript.org">CoffeeScript</a>.  Vanilla Handlebars and JavaScript would work just as well.</p>

<h2>Outlets</h2>

<p>Ember templates make use of a special helper called <code>outlet</code>.  You can have one main, unnamed outlet or many named outlets.  The main thing to remember is that a child template will always render inside its parent's outlet -- so always put outlets in templates that have children.</p>

<h2>Application Template</h2>

<p>There is a top-most template that all of your templates will render inside of.  This is called the application template.  It is specified in one of two ways.  If you are including your templates as script tags, simply create a script tag that doesn't have a <code>data-template-name</code> or <code>id</code> attribute, a la:</p>

<p>```html</p>

<script type="x-emblem">
  h1 My Application
  == outlet
</script>


<p>```</p>

<p>If you are <a href="/post/precompile-ember-templates">precompiling your Ember templates</a>, which you should, you have a directory for templates.  You will put your file, called <code>application.emblem</code> in the root of that directory.  The contents of <code>templates/application.emblem</code> would be the same:</p>

<p><code>jade
h1 My Application
== outlet
</code></p>

<h2>Route Templates</h2>

<p>If you have a top-level route, it will have a top-level template.  Your route's template will have only the application template as its parent.  So, your about route:</p>

<p><code>coffeescript
App.Router.map -&gt;
  @route 'about'
</code></p>

<p>Will have an about template at <code>templates/about.emblem</code> and you could define a route as <code>AboutRoute</code>.  It will render inside of <code>application.emblem</code>'s outlet.</p>

<h2>Resource Templates</h2>

<p>Resources are interesting because you can nest other routes inside them.  Nesting routes will also result in nesting templates.  If I defined a <code>league</code> resource with a nested route for creating new leagues, it might look something like this:</p>

<p>```coffeescript
App.Router.map ->
  @resouce 'league', -></p>

<pre><code>@route 'new'
</code></pre>

<p>```</p>

<p>There are two leaf routes (and thus templates) that are created here:</p>

<ul>
<li><code>LeagueIndexRoute</code>, which uses <code>templates/league/index.emblem</code></li>
<li><code>LeagueNewRoute</code>, which uses <code>templates/league/new.emblem</code></li>
</ul>


<p>Note that you create a <code>league</code> directory inside your <code>templates</code> directory for nesting these templates.  Precompiled templates will be created at:</p>

<ul>
<li><code>Ember.TEMPLATES["league/index"]</code></li>
<li><code>Ember.TEMPLATES["league/new"]</code></li>
</ul>


<p>If you wanted to use the <code>linkTo</code> helper in a template to link to these routes, you would use this syntax:</p>

<p><code>jade
linkTo 'league.index' | List Leagues
linkTo 'league.new' | New League
</code></p>

<p>And now as far as templates, there is <em>one more</em> that we're missing.  There is a root league template that these two league leaf templates render inside of.  It should live at <code>templates/league.emblem</code>.  This template would be useful for showing UI elements that are common to all league resource things.  In the case where there is no such need, this template will probably only contain a single outlet:</p>

<p><code>jade
== outlet
</code></p>

<p>So the final template hierarchy for <code>league.new</code>, for example, is <code>application.emblem &gt; league.emblem &gt; league/new.emblem</code>.</p>

<p>There is a bit of a chatter on the Githubs about whether the root resource template is good form or not.  As in, why would you create a file that contains nothing but an empty outlet?  Couldn't the framework infer that if it was missing?</p>

<h2>Children Need All Parents</h2>

<p>Create all parents in your template chain, from the application template to the leaves.  The worst thing that can happen if you don't is that nothing will render at all, and no error messages will be displayed (pretty bad and unhelpful).</p>

<p>Most of the time, Ember will try to be helpful and give you a console warning:</p>

<blockquote><p>WARNING: The immediate parent route ('a') did not render into the main outlet and the default 'into' option ('p') may not be expected</p></blockquote>

<p>In other words: You're trying to render a child template that either doesn't have a parent template it needs or the parent template does not specify a main outlet.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Precompile Ember Templates]]></title>
    <link href="http://jaketrent.com/post/precompile-ember-templates/"/>
    <updated>2013-05-21T07:54:00-06:00</updated>
    <id>http://jaketrent.com/post/precompile-ember-templates</id>
    <content type="html"><![CDATA[<p><a href="http://emberjs.com">Ember</a> makes use of the wonderful <a href="http://handlebarsjs.com">Handlebars</a> templates.  These templates, in order to be performant, must be precompiled.  Based on the Ember docs, it's not abundantly clear how this is to happen.  Here's a solution that works well.</p>

<p><img src="http://i.imgur.com/x5HT4FN.jpg" alt="Ember and Handlebars" /></p>

<!--more-->


<h2>Ember Docs for Precompilation</h2>

<p>Every official Ember doc will put templates in a <code>script</code> tag with the <code>type="text/x-handlebars"</code>.  But this is never how you'd write any serious (-ly awesome) app in production.  <a href="http://emberjs.com/guides/templates/handlebars-basics/">The docs</a> say:</p>

<blockquote><p>"If you are using build tools to manage your application's assets, most will know how to precompile Handlebars templates and make them available to Ember.js."</p></blockquote>

<p>Which tools?  Why would I want to precompile?  How <em>are</em> they made available to Ember?  Read, Ember journeyman, read on...</p>

<h2>Grunt</h2>

<p>We'd love for this precompilation to happen previous to the running of your app.  Again, this is in hopes of increased performance.  <a href="http://gruntjs.com">Grunt</a> is a great little Nodejs-based tool for build-level tasks.</p>

<h2>Emblem</h2>

<p>Grunt comes with a variety of plugins.  We're going to use one called <a href="https://github.com/wordofchristian/grunt-emblem/">grunt-emblem</a>.  <a href="http://emblemjs.com/">Emblem</a> is a fantastic templating syntax layered on top of Handlebars (still a dependency).  Its syntax looks very similar to Haml or Ruby Slim or Jade.  It may well be the most flexible of all of them, and it simplifies some Ember helper syntax very nicely.</p>

<h2>Versions Matching</h2>

<p>As I've said before, <a href="/post/match-ember-handlebars-version/">matching Ember dependency version can be a pain</a>.  With precompilation, you have one more dependency to match.  Now not only do you care about the version of Handlebars that Ember uses at runtime, but you care about the version of Handlebars that is used to precompile your templates.  If the precompile Handlebars version doesn't match the runtime Handlebars version, your app will die at runtime.  <code>grunt-emblem</code> helps immensely with this.</p>

<h2>grunt-emblem</h2>

<p>I haven't found another Handlebars precompile plugin that helps as much as <code>grunt-emblem</code>.  It solves the precompile version problem by letting you utilize the actual runtime Handlebars as the precompile Handlebars script.</p>

<p>It is also nice in that it puts the precompiled templates into the collection that Ember expects to find templates in, namely <code>Ember.TEMPLATES</code>.  As you can find on the <a href="https://github.com/wordofchristian/grunt-emblem/"><code>grunt-emblem</code> Github page</a>, your grunt config will look something like the following:</p>

<p>```coffeescript
matchdep = require 'matchdep'</p>

<p>module.exports = (grunt) ->
  grunt.initConfig</p>

<pre><code>watch:
  ember_templates:
    files: ['app/views/templates/**/*.emblem']
    tasks: ['emblem', 'livereload']

emblem:
  compile:
    files:
      "app/static/templates/ember_templates.js": ["app/views/templates/**/*.emblem"]
    options:
      root: "app/views/templates/"
      dependencies:
        jquery: "app/static/js/components/jquery/jquery.js"
        ember: "app/static/js/components/ember/ember.js"
        emblem: "app/static/js/components/emblem/dist/emblem.js"
        handlebars: "app/static/js/components/handlebars/handlebars.js"
</code></pre>

<p>  matchdep.filterDev('grunt-*').forEach grunt.loadNpmTasks</p>

<p>  grunt.renameTask 'regarde', 'watch'</p>

<p>  grunt.registerTask 'dev', [ 'livereload-start', 'watch' ]</p>

<p>```</p>

<p>This particular config has a couple other niceties.  Let me enumerate the awesome:</p>

<ul>
<li>Line 6 - Not only can we precompile the templates, but we'll precompile on the fly, whenever <code>.emblem</code> files are change in the specified directories.</li>
<li>Line 8 and 14 - We're precompiling <code>.emblem</code> templates, but this plugin can do regular Handlebars syntax as well</li>
<li>Line 16 - <code>root</code> is the substring that will be stripped out of your template name.  For instance, you don't want your template to be called <code>app/views/templates/home</code>.  Your home route in Ember will want your template called <code>home</code>.  <code>root</code> to the rescue -- bam!</li>
<li>Line 17 - These <code>dependencies</code> are the libraries that you use at runtime and that Handlebars needs at compile time.  As I said, this plugin simply rocks because of the ability to specify your own Handlebars script.</li>
<li>Line 23 - Remember how you used to have a whole list of npm tasks registered.  This little beaut will load all <code>grunt-*</code> dependencies.</li>
<li>Line 25 - <code>regarde</code> is a cool name, but I understand what <code>watch</code> means a bit better. Rename it.</li>
</ul>


<p>This setup requires the following dependencies:</p>

<p><code>
npm install matchdep grunt grunt-regarde grunt-contrib-livereload grunt-emblem --save-dev
</code></p>

<p>So now, seriously, go write some Emblem templates.  So fun, so precompiled.</p>
]]></content>
  </entry>
  
</feed>
